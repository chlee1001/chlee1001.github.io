{"posts":[{"title":"[Linux] 리눅스에서 압축 및 해제 하는법","text":"1. tar 압축1234&gt; tar -cvf [파일명.tar] [폴더명]ex) abc라는 폴더를 aaa.tar로 압축하고자 한다면 &gt; tar -cvf aaa.tar abc 2. tar 압축풀기1234&gt; tar -xvf [파일명.tar]ex) aaa.tar라는 tar파일 압축을 풀고자 한다면 &gt; tar -xvf aaa.tar 3. tar.gz 압축1234&gt; tar -zcvf [파일명.tar.gz] [폴더명]ex) abc라는 폴더를 aaa.tar.gz로 압축하고자 한다면 &gt; tar -zcvf aaa.tar.gz abc 4. tar.gz 압축풀기1234&gt; tar -zxvf [파일명.tar.gz]ex) aaa.tar.gz라는 tar.gz파일 압축을 풀고자 한다면 &gt; tar -zxvf aaa.tar.gz 5. zip 압축1234&gt; zip [파일명.zip] [폴더명]ex) abc라는 폴더를 aaa.zip으로 압축하고자 한다면 &gt; zip aaa.zip abc 6. zip 압축풀기1234567&gt; unzip [파일명.zip]ex) aaa.zip라는 zip파일 압축을 풀고자 한다면 &gt; unzip aaa.zip ex) 특정 폴더에 압축풀기 &gt; unzip aaa.zip -d ./target 자주 쓰는 tar 옵션 명령어 옵션 설명 -c 파일을 tar로 묶음 -p 파일 권한을 저장 -v 묶거나 파일을 풀 때 과정을 화면으로 출력 -f 파일 이름을 지정 -C 경로를 지정 -x tar 압축을 풂 -z gzip으로 압축하거나 해제함","link":"/categories/DevOps/LINUX-ZIP-21-07-26/"},{"title":"[C++] String 클래스","text":"출처 string classHeader : .assign : 문자열을 할당 ( 문자열 ) : 문자열을 할당한다. ( 개수, 문자 ) : 문자를 개수만큼 할당한다 ( 문자열, 시작위치, 개수 ) : 매개변수 문자열의 시작위치부터 개수만큼을 호출한 문자열에 할당 1234string s1, s2, s3 ;s1.assign( &quot;ABCDEFG&quot; ) ; // s1 = &quot;ABCDEFG&quot;s2.assign( 3, 'a' ) ; // s2 = &quot;aaa&quot;s3.assign( s, 2, 4 ) ; // s3 = &quot;CDEF&quot; ( 문자열 s의 2부터 4개를 복사하여 할당 ) .append : +연산자의 역할처럼 문자열을 끝에 더한다. ( 문자열 ) : 문자열을 더한다 ( 개수, 문자 ) : 문자를 개수만큼 끝에 더한다 ( 문자열, 시작위치, 개수 ) : 12345string s, s2 ;s.append( &quot;ABCDEF&quot; ) ; // s = &quot;ABCDEF&quot;s.append( 3, 'x' ) ; // s = &quot;ABCDEFxxx&quot;s2.append( s, 2, 4 ) ; // s2 = &quot;CDEF&quot;s2 += &quot;x&quot; ; // s2 = &quot;CDEFx&quot; .clear : 문자열의 내용을 모두 삭제 1s.clear() ; .compare : 문자열을 비교 ( 사전순으로 비교 ) 1s.compare( s2 ) ; // s == s2이면 0, s&lt;s2이면 음수, s&gt;s2이면 양수를 반환 .empty : 문자열이 비었는지 확인 1s.empty() ; .erase : 문자열을 지운다 ( 시작위치, 개수 ) : 시작위치부터 개수만큼의 문자를 지운다. 12string s = &quot;ABCDEF&quot; ;s.erase( 0, 3 ) ; // s = &quot;DEF&quot; ( 인덱스 0부터 3개의 문자를 지운다 ) .find : 특정 문자열을 찾고, 그 시작위치를 반환 ( 문자 ) : 인덱스 0부터 해당 문자를 찾고, 시작위치를 반환한다. ( 문자열 ) : 인덱스 0부터 해당 문자열을 찾고, 그 시작위치를 반환한다. ( 문자열, 시작위치 ) : 시작위치부터 문자열을 찾고, 시작위치를 반환한다. 123456string s1 = &quot;abcd&quot; ;string s2 = &quot;b&quot; ;**int** location = s1.find( s2 ) ;location = s1.find( s2, x ) ;location = s1.find_first_of( s2, x ) ;location = s1.find_first_not_of( s2, x ) ; location = s1.find_last_of s1.find_last_not_of .replace : 문자열을 대체 ( 시작위치, 개수, 문자열 ) : 호출한 문자열의 시작위치부터 개수만큼의 문자를 매개변수 문자열로 대체한다. 12 string s = &quot;abc_def&quot; ;s.replace( 4, 3, &quot;zzz&quot; ) ; // s = &quot;abc_zzz&quot; ( 인덱스 4부터 3개의 문자를 &quot;zzz&quot;로 대체 ) .insert : 문자열을 지정한 위치에 삽입 ( 시작위치, 문자열 ) : 시작위치에 문자열을 삽입한다. string s = “ABCDEF” ; s.insert( 2, “xx” ) ; // s = “ABxxCDEF” .pop_back : 문자열에서 가장 뒤의 문자 하나를 빼낸다. .push_back : 문자열의 가장 뒤에 문자 하나를 추가한다. string s = “ABCDEF” ; s.pop_back() ; // s = “ABCDE” s.push_back( ‘x’ ) ; // s = “ABCDEx” .resize : 문자열의 크기를 재설정 s .size, .length : 문자열의 크기를 반환 .max_size : 문자열이 최대로 가질수 있는 길이를 반환한다. string s = “ABCDEF” ; int size = s.size() ; // size = 6 ( 실제 사용되고 있는 크기 ) int length = s.length() ; // length = 6 ( 문자열의 길이 ) .capacity : 할당된 메모리의 크기를 반환 ( reallocation 없이 사용할 수 있는 문자수를 반환 ) string s = “ABCDEF” ; int capacity = s.capacity() ; // size = 6, capacity = 15 ★ capacity가 size보다 클때, 속도는 더 빠르다 ! = capacity가 size보다 크면, 기존 공간에 문자를 추가하면 되지만 그 반대의 경우에는 문자를 추가하기 위해 새로운 메모리를 할당해야 하기 때문이다. .reserve : reallocation을 피하기 위해, 메모리의 최소용량을 지정 ( 크기 ) : 크기만큼의 여유 메모리를 할당한다. ** 이때, 매개변수의 크기는 현재 capacity보다 크지않으면 의미도 효과도 없다. string s = “ABCDEF” ; // size = 6, capacity = 15 s.reserve( 100 ) ; // size = 6, capacity = 111 s.reserve( 1000 ) ; // size = 6, capacity = 1007 .substr : 문자열의 일부분을 문자열로 반환 ( 시작위치 ) : 시작위치부터 끝까지의 문자들을 문자열로 반환 ( 시작위치, 개수 ) : 시작위치부터 개수만큼의 문자를 문자열로 반환 string s = “ABCDEF” ; string s2 = s.substr( 4 ) ; // s2 = “EF” ( 인덱스 4부터 끝까지의 문자열을 반환 ) string s3 = s.substr( 1, 3 ) ; // s3 = “BCD” ( 인덱스 1부터 3까지의 문자열을 반환 ) .swap : 문자열을 서로 바꾼다 string a = “ABCD” ; string b = “WXYZ” ; a.swap( b ) ; // a = “WXYZ”, b = “ABCD” b.swap( a ) ; // a = “ABCD”, b = “WXYZ” .at : 문자열에서 특정위치의 문자를 액세스 string s = “ABCDEF” ; char c = s.at(3) ; // c = ‘D’ .c_str : string 문자열을 char* 형으로 바꾸어 반환한다. string s = “ABCDEF” ; int length = strlen( s.c_str() ) ; .date .copy .back .front .begin .end","link":"/categories/Programming/%5BC++%5D-String%20%ED%81%B4%EB%9E%98%EC%8A%A4-2019-04-25/"},{"title":"FECConf 2025 다녀와서, 드디어 블로그를 시작하기로 했다","text":"발표가 끝나자마자 노트북을 꺼내 메모장을 열었다. “이제 정말 시작해야겠다”는 생각이 머리를 스쳤다.2025년 8월 23일 토요일, 처음으로 찾은 FECConf 2025 현장은 에너지와 열정으로 가득했다. 발표를 듣는 순간보다도, 세션이 끝나고 스피커 혹은 리더분들과 이야기를 나누는 순간순간이 더 오래 남았다. 컨퍼런스에서 얻은 가장 큰 깨달음FECConf는 항상 개발자로서 한 단계 성장할 수 있는 계기를 주지만, 이번에는 조금 달랐다. 좋은 경험을 가진 리더분들과 대화하면서 느낀 건 꾸준히 쌓아가는 습관이 결국 나를 만든다는 것이었다.기술 스택이나 최신 트렌드보다도 매일 조금씩 기록하고 나누고 돌아보는 과정이 진짜 성장을 만든다는 점을 실감했다. 누군가는 “짧은 글이라도 꾸준히 쓰다 보면 어느 순간 내 글이 다른 사람에게 힘이 된다”고 했다. 그 말이 크게 와 닿았다. 나 역시 지난 몇 년간 다양한 경험을 쌓아왔지만, 그 경험을 흘려보내는 데 그치지 않고 기록으로 남겼다면 지금쯤은 더 단단한 기반을 만들 수 있었을 거다. 블로그를 시작하는 이유그래서 나는 결심했다. 내 경험과 지식을 글로 정리해보자. 그동안 프로젝트에서 겪은 시행착오 새로운 기술을 도입하며 배운 점 개발자로서 성장하며 느낀 고민들 이 모든 것들을 차근차근 풀어내려고 한다. 단순히 기술 정리 노트가 아니라 “내가 어떻게 성장해왔는가””를 보여주는 기록으로 남기고 싶다. 특히 나는 오랜 시간 다양한 분야를 경험해왔다. 프론트엔드, 인프라, CI/CD, 모바일 앱까지… 이 모든 걸 그냥 머릿속에만 두는 건 아깝다는 생각이 들었다.그래서 앞으로는 최소한 한 달에 2편 이상의 글을 꾸준히 올리는 것을 목표로 삼으려 한다. 다짐꾸준함은 늘 어렵다. 하지만 이번에는 컨퍼런스에서 만난 분들이 보여준 태도와 습관을 본받아, 기록하는 습관을 개발자로서의 생활에 꼭 녹여내고 싶다.글을 쓰는 과정에서 나 자신을 돌아보고, 또 누군가에게는 도움이 될 수 있다면 더할 나위 없을 것이다. “성장은 순간이 아니라 과정이다.”이번 블로그는 그 과정을 담는 첫 걸음이 될 것이다. 마무리혹시 이 글을 읽는 분들 중에서도 비슷한 고민을 하고 있다면, 함께 시작해보면 어떨까? 완벽할 필요도 길게 쓸 필요도 없는 것 같다. 중요한 건 멈추지 않는 꾸준함이라는 걸 이번 컨퍼런스에서 확실히 배웠다. 앞으로 차근차근 글을 쌓아가며 함께 성장해나갔으면 좋겠다. 여러분의 경험과 의견도 댓글로 나눠주시면 정말 큰 힘이 될 것 같다.","link":"/categories/%EC%9D%BC%EC%83%81/essay-250826/"},{"title":"[백준] 10039번 평균점수","text":"출처: [백준]10039번 문제상현이가 가르치는 아이폰 앱 개발 수업의 수강생은 원섭, 세희, 상근, 숭, 강수이다. 어제 이 수업의 기말고사가 있었고, 상현이는 지금 학생들의 기말고사 시험지를 채점하고 있다. 기말고사 점수가 40점 이상인 학생들은 그 점수 그대로 자신의 성적이 된다. 하지만, 40점 미만인 학생들은 보충학습을 듣는 조건을 수락하면 40점을 받게 된다. 보충학습은 거부할 수 없기 때문에, 40점 미만인 학생들은 항상 40점을 받게 된다. 학생 5명의 점수가 주어졌을 때, 평균 점수를 구하는 프로그램을 작성하시오. 입력입력은 총 5줄로 이루어져 있고, 원섭이의 점수, 세희의 점수, 상근이의 점수, 숭이의 점수, 강수의 점수가 순서대로 주어진다. 점수는 모두 0점 이상, 100점 이하인 5의 배수이다. 따라서, 평균 점수는 항상 정수이다. 출력첫째 줄에 학생 5명의 평균 점수를 출력한다. 예제 입력 11234510651003095 예제 출력 1168 힌트숭과 원섭이는 40점 미만이고, 보충학습에 참여할 예정이기 때문에 40점을 받게 된다. 따라서, 점수의 합은 340점이고, 평균은 68점이 된다. 출처Olympiad &gt; 일본정보올림피아드 &gt; 일본정보올림피아드 예선 &gt; JOI 2014 예선 1번 문제를 번역한 사람: baekjoon 알고리즘 분류 구현 풀이 조건에 맞는 5개의 숫자를 받으면서 더한 후, 평균을 구한다. 소스코드12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main(){ int result=0,tmp; for(int i=0; i&lt;5; i++){ cin &gt;&gt; tmp; if(tmp&lt;0 || tmp&gt;100 || tmp%5!=0){ return 0; } if(tmp&lt;40){ tmp=40; } result+=tmp; } cout &lt;&lt; result/5; return 0;}","link":"/categories/Algorithm/C++/BAEKJOON-10039-19-04-24/"},{"title":"[백준] 2577번 숫자의 개수","text":"출처: [백준] 2577번 숫자의 개수 문제세 개의 자연수 A, B, C가 주어질 때 A×B×C를 계산한 결과에 0부터 9까지 각각의 숫자가 몇 번씩 쓰였는지를 구하는 프로그램을 작성하시오. 예를 들어 A = 150, B = 266, C = 427 이라면 A × B × C = 150 × 266 × 427 = 17037300 이 되고, 계산한 결과 17037300 에는 0이 3번, 1이 1번, 3이 2번, 7이 2번 쓰였다. 입력첫째 줄에 A, 둘째 줄에 B, 셋째 줄에 C가 주어진다. A, B, C는 모두 100보다 같거나 크고, 1,000보다 작은 자연수이다. 출력첫째 줄에는 A×B×C의 결과에 0 이 몇 번 쓰였는지 출력한다. 마찬가지로 둘째 줄부터 열 번째 줄까지 A×B×C의 결과에 1부터 9까지의 숫자가 각각 몇 번 쓰였는지 차례로 한 줄에 하나씩 출력한다. 예제 입력 1123150266427 예제 출력 1123456789103102000200 출처Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2006 &gt; 초등부 2번 문제의 오타를 찾은 사람: pineapple 잘못된 데이터를 찾은 사람: tncks0121 알고리즘 분류 구현 풀이 세 개의 자연수를 곱한 값을 10으로 나눈 나머지를 확인하여 해당 배열 인덱스에 카운트 1을 증가시켜준다. 곱한 값은 10으로 나누어 1의 자리를 없앤다. ==&gt; 1의 자리 숫자 하나씩 확인하면서, 10으로 나누어서 자릿수를 없애는 방식 소스코드123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main(){ int A, B, C, result; int count[10]={}; // 0으로 초기화 cin &gt;&gt; A &gt;&gt; B &gt;&gt; C; // 3개의 값 입력 result=A*B*C; while(result != 0){ int temp = result %10; result =result/10; count[temp]++; } for(int i=0; i&lt;10; i++){ printf(&quot;%d\\n&quot;,count[i]); } return 0;}","link":"/categories/Algorithm/C++/BAEKJOON-2577-19-04-23/"},{"title":"[백준] 1152번 단어의 개수","text":"출처: [백준] 1152번 단어의 개수 문제영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다. 입력첫 줄에 영어 대소문자와 띄어쓰기로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 띄어쓰기 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열의 앞과 뒤에는 공백이 있을 수도 있다. 출력첫째 줄에 단어의 개수를 출력한다. 예제 입력 11The Curious Case of Benjamin Button 예제 출력 116 예제 입력 21Mazatneunde Wae Teullyeoyo 예제 출력 213 예제 입력 31Teullinika Teullyeotzi 예제 출력 3 복사12 출처 문제를 만든 사람: author5 빠진 조건을 찾은 사람: djm03178 his130 데이터를 추가한 사람: jh05013 내용을 추가한 사람: jh05013 알고리즘 분류 [문자열 처리](https://www.acmicpc.net/problem/tag/문자열 처리) 소스코드123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;using std::string;int main(){ string str={}; int wordCnt=0; // 단어 갯수 getline(cin,str); for(int i=0; i&lt;str.length(); i++) { if(str[i] == ' ') wordCnt++; } if(str.at(0) == ' ') wordCnt--; if(str.at(str.length()-1)==' ') wordCnt--; cout &lt;&lt; wordCnt+1; return 0;}","link":"/categories/Algorithm/C++/BAEKJOON-1152-19-04-22/"},{"title":"[백준] 2920번 음계","text":"출처: [백준]2920번 문제다장조는 c d e f g a b C, 총 8개 음으로 이루어져있다. 이 문제에서 8개 음은 다음과 같이 숫자로 바꾸어 표현한다. c는 1로, d는 2로, …, C를 8로 바꾼다. 1부터 8까지 차례대로 연주한다면 ascending, 8부터 1까지 차례대로 연주한다면 descending, 둘 다 아니라면 mixed 이다. 연주한 순서가 주어졌을 때, 이것이 ascending인지, descending인지, 아니면 mixed인지 판별하는 프로그램을 작성하시오. 입력첫째 줄에 8개 숫자가 주어진다. 이 숫자는 문제 설명에서 설명한 음이며, 1부터 8까지 숫자가 한 번씩 등장한다. 출력첫째 줄에 ascending, descending, mixed 중 하나를 출력한다. 예제 입력 111 2 3 4 5 6 7 8 예제 출력 11ascending 예제 입력 218 7 6 5 4 3 2 1 예제 출력 21descending 예제 입력 318 1 7 2 6 3 5 4 예제 출력 31mixed 출처Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2009/2010 &gt; Contest #1 1번 문제를 번역한 사람: baekjoon 데이터를 추가한 사람: jh05013 문제의 오타를 찾은 사람: thinksong1 알고리즘 분류 배열 풀이 8개의 숫자를 순서대로 string으로 받는다. 그리고 그 string이 ‘12345678’ 인지, ‘87654321’ 인지 아닌지 확인 후 알맞은 결과값을 출력시킨다. 소스코드123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){ string str; string tmp; for(int i=0; i&lt;8; i++){ cin &gt;&gt; tmp; str.append(tmp); } string as=&quot;12345678&quot;; string des=&quot;87654321&quot;; if(str==as){ cout &lt;&lt; &quot;ascending&quot;; } else if(str==des){ cout &lt;&lt; &quot;descending&quot;; } else { cout &lt;&lt; &quot;mixed&quot;; } return 0;}","link":"/categories/Algorithm/C++/BAEKJOON-2920-19-04-24/"},{"title":"[백준] 8958번 OX퀴즈","text":"출처: [백준] 8958번 OX퀴즈 문제“OOXXOXXOOO”와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다. “OOXXOXXOOO”의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다. OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다. 출력각 테스트 케이스마다 점수를 출력한다. 예제 입력 1 복사1234565OOXXOXXOOOOOXXOOXXOOOXOXOXOXOXOXOXOOOOOOOOOOOOOOXOOOOXOOOOX 예제 출력 1 복사1234510975530 출처ACM-ICPC &gt; Regionals &gt; Asia &gt; Korea &gt; Asia Regional - Seoul 2005 A번 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: jh82582 링크 ACM-ICPC Live Archive TJU Online Judge 풀이 소스코드1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main(void){ char str[100]; int number = 0, result =0, flag=1; cin &gt;&gt; number; for (int i=0; i&lt;number; i++){ cin &gt;&gt; str; int length = strlen(str); // str의 길이를 미리 계산하여 loop문에서 계속 계산되는 것을 방지? for(int j=0; j&lt;length; j++){ if (str[j] == 'O'){ // O일 때 결과값 flag만큼 증가 result+=flag; flag++; } else{ // X일 때 flag 1로 초기화 flag=1; } } cout &lt;&lt; result &lt;&lt; endl; result =0; flag =1; } return 0;}","link":"/categories/Algorithm/C++/BAEKJOON-8958-19-04-23/"},{"title":"[JS] Algorithm - 자주 쓰이는 구문 정리(22.02.06)","text":"이채현 💡 Javascript를 이용하여 알고리즘 문제를 풀 때 자주 쓰이는 구문을 정리하자! 배열 중복값 개수 구하기reduce()reduce() 함수는, 배열의 값을 순회하면서 배열의 값을 특정 형태로 누적하는데 사용합니다. 12345678910const inputNum = [1, 1, 2, 3, 4, 2, 1];const result1 = inputNum.reduce((obj, t) =&gt; (obj[t] = obj[t] ? obj[t] + 1 : 1, obj), {});const result2 = inputNum.reduce((obj, t) =&gt; { obj[t] = (obj[t] || 0) + 1; return obj;}, {});// { '1': 3, '2': 2, '3': 1, '4': 1 } forEach()123const cnt = {}inputNum.forEach((x) =&gt; (cnt[x] ? (cnt[x] += 1) : (cnt[x] = 1)));// { '1': 3, '2': 2, '3': 1, '4': 1 } forEach의 callback함수를 풀어쓰면 아래와 같다. 12345if(cnt[x]) { cnt[x] = cnt[x] + 1;} else {cnt[x] = 1;} 즉, 처음에 배열의 첫 번째 값인 ‘1’이 들어오면, cnt[x] (cnt.1)은 undefined이다. cnt[x]가 undefinded이므로 cnt에 key ‘1’를 추가하고 value 1을 세팅해준다. 이후 다시 ‘1’이 들어오면 cnt[1]은 존재하므로, cnt[1]값 1에 1을 더해준다. 배열에 1 ~ N 값 세팅하기기본 반복문을 이용1234567891011const arr = [];const N = 10;for (let i = 1; i &lt;= N; i++) { arr.push(i);}console.log(arr);// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] ES6의 Array from() and keys() 이용123const arr = Array.from(Array(N).keys());console.log(arr);// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] Spread를 이용한 방법123const arr = [...Array(10).keys()];console.log(arr);// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 1부터 시작하기 위해 from과 length property 이용123const arr = Array.from({length: 10}, (_, i) =&gt; i + 1)console.log(arr);// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] 단순 원하는 길이만큼 0으로 채우기12const array = new Array(10001).fill(0);console.log(array)","link":"/categories/Algorithm/Javascript/JS-Algorithm-1-22-01-31/"},{"title":"[AWS] Amazon Web Service&#39;s survey","text":"Survey (EC2, Auto Scaling, S3, RDS)What is Amazon EC2?Abbreviation for Amazon Elastic Compute Cloud, it provides scalable computing capacity in the Amazon Web Services (AWS) cloud. With Amazon EC2, you can, Build as many virtual servers as you want, Manage security, network configuration, storage •Reduces the need to predict server traffic more What is Amazon Auto Scaling?With AWS Auto Scaling, you can configure automatic scaling of the AWS resources in your application in minutes. Amazon Auto Scaling monitors your application, Set up scaling quickly, Make smart scaling decisions, Maintain performance automatically, Reliable, Pay only for what you need. (the lowest possible cost) more What is Amazon S3?Abbreviation for Amazon Simple Storage Service, it provides storage through a web service interface. With Amazon S3, you can easily Organize your data, Fine-grained access controls according to your specific business, organization, and compliance requirements. Designed to provide 99.999999999% durability more What is Amazon RDS?Abbreviation for Amazon Relational Database Service, Amazon RDS is a web service that operates in the cloud. With it, you can easily Set up, Operate, and Scale your relational database in the cloud. Automate Hardware provisioning, Database setup, Patching and Backups more Survey (Detail Specification of EC2)Instance Types:It is divided into “General purpose(T2, T3…)”, “Computing optimization(C4, C5…)”, “Memory optimization(z1d, R5…)”, “Accelerated computing(P4…)”, and “Storage optimization(H1, I3…)”. more Pricing Plans: On-Demand Instance - You are charged for what you use. However, since the unit of billing is 1 minute, even if you use 1 second, you will be charged 1 minute. Spot Instance – You can use EC2 resources that are not currently in use by receiving a cheap bid at auction. They are offered at a discount of up to 90% compared to the On-Demand rate. Reserved Instance - When you reserve the usage period (1 or 3 years) and usage (No/Partial/All Upfront) and pay the initial prepayment, you receive a discount on the hourly usage fee. more","link":"/categories/DevOps/AWS/AWS-1-21-05-05/"},{"title":"[AWS] EC2 Ubuntu에서 MySQL 사용하기","text":"Ubuntu 패키지 정보 업데이트12sudo apt updatesudo apt upgrade MySQL 설치1sudo apt install -y mysql-server MySQL 기본 세팅123sudo ufw allow mysql # 외부 접속 기능 설정 (포트 3306 오픈)sudo systemctl start mysql # Mysql 실행sudo systemctl enable mysql # Ubuntu 서버 재시작시 Mysql 자동 재시작 MySQL 외부접속 설정1sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf bind-address를 127.0.0.1 -&gt; 0.0.0.0 으로 변경 MySQL 언어셋 한글 설정1sudo vi /etc/mysql/my.cnf 맨 밑에 다음 코드 첨부 1234567891011121314[client]default-character-set = utf8[mysqld]init_connect = SET collation_connection = utf8_general_ciinit_connect = SET NAMES utf8character-set-server = utf8collation-server = utf8_general_ci[mysqldump]default-character-set = utf8[mysql]default-character-set = utf8 123sudo systemctl restart mysql # Mysql 재실행sudo mysql # MySQL 접속mysql&gt; status; MySQL 상태확인1sudo systemctl status mysql MySQL 사용자 등록 및 권한 설정12mysql&gt; create user '계정이름'@'%' identified by '패스워드';mysql&gt; grant all privileges on *.* to '계정이름'@'%' with grant option; 인스턴스 인바운드 규칙 설정 외부에서 MySQL 접속확인MySQL Workbench를 이용하여 접속확인을 한다.","link":"/categories/DevOps/AWS/AWS-MYSQL1-21-08-05/"},{"title":"[MySQL] 사용자 계정 생성 및 삭제, 권한관리","text":"MySQL 접속123sudo mysql -------------------mysql -u root -p 새로운 유저 생성1mysql&gt; CREATE USER 'username'@'host' IDENTIFIED WITH authentication_plugin BY 'password'; 사용자 계정 삭제1mysql&gt; DROP USER 'user명'@'server명'; 새로운 데이터베이스 생성12mysql&gt; CREATE DATABASE test;mysql&gt; SHOW DATABASES; 특정 계정에 모든 데이터베이스 사용 권한 부여12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'username'@'localhost';mysql&gt; FLUSH PRIVILEGES; 특정 계정에 특정 데이터베이스 사용 권한 부여12mysql&gt; GRANT ALL PRIVILEGES ON 데이터베이스이름.* TO 'username'@'localhost';mysql&gt; FLUSH PRIVILEGES; 특정 권한 부여1mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,INDEX,ALTER ON 'database명'.'tabel명' TO 'user명'@'server명'; 모든 권한 삭제1mysql&gt; REVOKE ALL ON 'database명'.'table명'FROM 'user명'@'server명'; 특정 권한 삭제1mysql&gt; REVOKE INSERT, DROP ON 'database명'.'table명'FROM 'user명'@'server명';","link":"/categories/DevOps/AWS/AWS-MYSQL2-21-08-05/"},{"title":"[RPI] 라즈베리파이에서 CRIU 작동시키기","text":"라즈베리파이, OS, Kernel, Docker, Criu… 이 다섯개의 각 버전들은 매우 다양하며 checkpoint와 restore 기능이 작동하는 적당한 버전을 찾기까지 많은 노가다 작업이 있었다. 사용 버전기기: 라즈베리파이 3BOS: Ubuntu Mate 16.04.2 라즈베리파이용 우분투 마테 Archive Kernel: rpi-4.12.yDocker version: 17.06.0~CE 라즈베리파이용(armhf) 도커 Archive Criu version: 3.11 criu Archive 작업1. 기기에 OS설치라즈베리파이 3B버전을 이용한 이유는 Ubuntu Mate 16.04버전이 4B버전을 지원하지 않아서다. 16.04버전을 사용하려는 이유를 대충 요약하자면 criu를 사용할 때, 안정적으로 동작한 Docker의 버전은 17.X이였고, 이 버전은 우분투 18.X 버전부터 정상적으로 동작하지 않았다. 그래서 16.04를 사용한다. 2. Docker 설치wget을 이용하여 다운, dpkg를 이용하여 설치 123# wget https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/armhf/docker-ce_17.06.0~ce-0~ubuntu_armhf.deb# dpkg -i docker-ce_17.06.0~ce-0~ubuntu_armhf.deb 3. Criu 설치1apt install criu 위 코드로도 설치가 가능하나, 아래로 설치하겠음. (특정 버전 설치를 위함) 123456curl -O -sSL http://download.openvz.org/criu/criu-3.11.tar.bz2tar xjf criu-3.11.tar.bz2 cd criu-3.11makecp ./criu/criu /usr/local/bincd 4. Kernel config 수정커널의 설정을 criu linux kernel 이 사이트대로 수정해야하지만, 이것은 x86_64 용인 것같고, arm용으로 설정을 약간 더 손봤다. 123456789101112131415161718192021CONFIG_CHECKPOINT_RESTORE=yCONFIG_NAMESPACES=y CONFIG_UTS_NS=yCONFIG_IPC_NS=yCONFIG_SYSVIPC_SYSCTL=yCONFIG_PID_NS=yCONFIG_NET_NS=y CONFIG_FHANDLE=y CONFIG_EVENTFD=y CONFIG_EPOLL=y CONFIG_UNIX_DIAG=y CONFIG_INET_DIAG=yCONFIG_INET_UDP_DIAG=mCONFIG_PACKET_DIAG=yCONFIG_NETLINK_DIAG=yCONFIG_NETFILTER_XT_MARK=mCONFIG_TUN=yCONFIG_PROC_PAGE_MONITOR=yCONFIG_VDSO=nCONFIG_IDLE_PAGE_TRACKING=y 참고 라즈베리파이… ARM는 soft-dirty기능을 미지원 à “CONFIG_MEM_SOFT_DIRTY”가 없음 대신 “CONFIG_PROC_PAGE_MONITOR=y” 이는 Dumpee 메모리 레이아웃에 대한 정보를 얻기 위해 필요하다고 함. 그리고 ARM에는 VDSO라는 매개변수가 없으므로 “CONFIG_VDSO=n” 셋팅을 해야 VDSO 때문에 덤프가 실패하는 것을 피할 수 있음. à 비활성화 시, signal trampoline(?)이 ARM의 VDSO페이지가 아닌 SIG페이지에 자동으로 배치됨. 컴파일 후에 적용하고 재부팅을 하면 기본 설정은 끝이다. 테스트docker와 busy box를 이용하여 체크포인트와 복구를 테스트 12345sudo docker run --name counter busybox /bin/sh -c 'i=0; while true; do echo $i; i=$(expr $i + 1); sleep 1; done'sudo docker checkpoint create counter cp1sudo docker start -a --checkpoint cp1 counter","link":"/categories/DevOps/RaspberryPi/RASP-CRIU-21-07-29/"},{"title":"[AWS] Start Amazon EC2","text":"Select Instance(Amazon Linux2 AMI) With t2.micro Configure Security group - Add types [SSH(22), HTTP(80)] Instance Spec","link":"/categories/DevOps/AWS/AWS-2-21-06-16/"},{"title":"[Fastlane] Fastlane을 통해 빌드를 자동화하자 1편","text":"이채현 노션으로 보기 What is the Fastlane? ruby 코드로 만들어진 앱 배포 자동화 툴 커맨드라인으로 빌드 할 수 있음 CI 시스템과의 통합 용이 여러 구성원이 App Store에 앱을 배포하거나 단일 장치에 앱을 설치할 때 별도의 코드 서명 ID가 필요하지만, fastlane의 match를 사용하여 하나의 중앙저장소를 만들 수 있음 기존 배포 인증서는 팀원 각각 만들어야 하고, 만료 기한이 있었던 것과 달리 깃 저장소에 저장된 배포 인증서로 사용 가능 단, 이중인증 필요하다는 한계 존재 Run Fastlane01. settingfastlane 설치 및 세팅#1. Install the latest Xcode command line tools 1xcode-select --install #2. ruby 2.5.0이상 버전 다운로드 필요 Homebrew를 이용한 설치 macOS Sierra 기준으로, 맥에는 이미 ruby가 설치되어 있음 기본설치 되어 있는 Ruby가 오래된 버전이라면 rbenv를 다운로드 하여 버전관리를 하는 것이 좋음 1brew install rbenv ruby-build rbenv 초기화 rbenv의 설치가 완료되었다면 아래에 명령어를 실행하여 rbenv을 초기화한다. 아래 명령어를 실행하면 다음과 같이 나온다 12345rbenv init---# Load rbenv automatically by appending# the following to ~/.bashrc_profile:*eval &quot;$(rbenv init -)&quot;` 위에 설명과 같이 .bashrc_profile 파일을 열고 아래와 같이 수정한다. 12345eval &quot;$(rbenv init -)&quot; 또는eval &quot;$(rbenv init - zsh)&quot;# 그리고 아래 줄을 작성한다.export PATH=$HOME/bin:/usr/local/bin:$PATH 1source ~/.zshrc 루비 2.5.0 이상 설치 12345rbenv install 3.1.2rbenv global 3.1.2 rbenv rehashruby -v #3. fastlane을 설치하는 두가지 방법 Install fastlane using RubyGems 1sudo gem install fastlane -NV ✅ Alternatively using Homebrew 1brew install fastlane 공식문서에서는 brew로 설치하는 방법을 권장 이유: RubyGems로 설치할 경우 전역적으로 설치되어 rbenv를 사용하는 의미가 사라짐 → Homebrew로 설치하는 것을 권장 참고 링크 https://jojoldu.tistory.com/288 https://dev-yakuza.posstree.com/ko/ruby-on-rails/rails-on-mac/ 02. Init Fastlanefastlane을 위해 사용할 폴더 구조는 다양하다. 필자는 RN 프로젝트에서 다음과 같이 사용하고 있음. #1. 프로젝트 최상위 루트에서 init 후 아래와 같은 폴더 구조 생성 123bundle exec fastlane init이후 4번 선택 root project |_ fastlane |_ android |Fastfile | ios |Fastfile | android |_ ios #2. Fastfile설정 1234567fastlane_require 'dotenv'before_all doendimport(&quot;./ios/Fastfile&quot;)import(&quot;./android/Fastfile&quot;) #3. env 설정 Android와 iOS의 빌드를 위해 env를 분리시킨다. 프로젝트 최상위 루트에 .env.FLAndroid, .env.FLIos 파일을 생성한다. env파일 .env.FAndroid 123456789101112# 개발APPCENTER_API_TOKEN={앱센터 토큰}APPCENTER_OWNER_NAME={&quot;앱센터 사용자 이름&quot;}APPCENTER_APP_NAME={&quot;앱센터 앱 이름&quot;}APPCENTER_DISTRIBUTE_APK=&quot;./android/app/build/outputs/apk/development/release/app-development-release.apk&quot;# 상용JSON_KEY={&quot;플레이스토어 API 액세스 키&quot;}STORE_DISTRIBUTE_AAB=&quot;./android/app/build/outputs/bundle/productionRelease/app-production-release.aab&quot;PACKAGE_NAME=&quot;앱 패키지 이름&quot; .env.FLIos 12345678910111213141516171819202122IOS_PROJECT_PATH=&quot;./ios/project.xcodeproj&quot;SIGNING_IDENTITY_DEBUG=&quot;Apple Development: &quot;SIGNING_IDENTITY_RELEASE=&quot;Apple Distribution: &quot;# 개발MATCH_ENV_PREFIX_DEVELOPMENT=&quot;sigh_io.project.dev_development&quot;MATCH_ENV_PREFIX_DEVELOPMENT_EXT=&quot;sigh_io.project.dev.OneSignalNotificationServiceExtension-Dev_development&quot;MATCH_ENV_PREFIX_ADHOC=&quot;sigh_io.project.dev_adhoc&quot;MATCH_ENV_PREFIX_ADHOC_EXT=&quot;sigh_io.project.dev.OneSignalNotificationServiceExtension-Dev_adhoc&quot;APPCENTER_API_TOKEN=앱센터 토큰APPCENTER_OWNER_NAME=&quot;앱센터 사용자 이름&quot;APPCENTER_APP_NAME=&quot;앱센터 앱 이름&quot;APPCENTER_DISTRIBUTE_IPA=&quot;./projectDev.ipa&quot;# 상용MATCH_ENV_PREFIX_APPSTORE=&quot;sigh_io..project.app_appstore&quot;MATCH_ENV_PREFIX_APPSTORE_EXT=&quot;sigh_io.project.app.OneSignalNotificationServiceExtension-Prod_appstore&quot;STORE_DISTRIBUTE_IPA=&quot;./project.ipa&quot; #4. env 로드 1234567891011121314151617platform :android do before_all do Dotenv.overload '../.env.FLAndroid' ... end ...en----------------------------------------------platform :ios do before_all do Dotenv.overload '../.env.FLIos' ... end ...en #5. Appfile 셋팅 (환경변수 파일) 필요에 따라 작성하면 된다. 12345# app_identifier('io.project') # The bundle identifier of your appapple_id('ABCE@ABCD.com') # Your Apple email address# itc_team_id('####') # App Store Connect Team ID# team_id(&quot;ABCDE&quot;) # Developer Portal Team ID 03. How to Run Fastlanelocal에 설치 된 ruby 버전이 아닌 프로젝트에서 지정한 ruby버전을 사용하기 위해 bundle exec 명령어를 이용 12bundle update --bunderbundle exec fastane .... Install Plugin12345bundle exec fastlane add_plugin appcenterbundle exec fastlane add_plugin load_jsonbundle exec fastlane add_plugin yarn# ... 등등 필요한 플러그인을 추가한다. add plugin 이후, fastlane 폴더 내 Pluginfile이 생성 1234567# Autogenerated by fastlane## Ensure this file is checked in to source control!gem 'fastlane-plugin-appcenter'gem 'fastlane-plugin-load_json'gem 'fastlane-plugin-yarn' Pluginfile 생성 체크 후, 프로젝트 루트 디렉토리에 Gemfile 내에 생성된 경로와 일치한지 확인하기 1234...plugins_path = File.join(File.dirname(__FILE__), 'fastlane', 'Pluginfile')eval_gemfile(plugins_path) if File.exist?(plugins_path) 마무리 12bundle install# 이후, Gemfile.lock에 추가한 플러그인이 생겼는지 확인","link":"/categories/DevOps/Fastlane/Fastlane-1-22-06-01/"},{"title":"[백준] 10026번 적록색약","text":"출처: [백준] 10026번 적록색약 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 19449 11275 8904 58.025% 문제적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다. 크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다. 또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다) 예를 들어, 그림이 아래와 같은 경우에 12345RRRBBGGBBBBBBRRBBRRRRRRRR 적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1) 그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100) 둘째 줄부터 N개 줄에는 그림이 주어진다. 출력적록색약이 아닌 사람이 봤을 때의 구역의 개수와 적록색약인 사람이 봤을 때의 구역의 수를 공백으로 구분해 출력한다. 예제 입력 11234565RRRBBGGBBBBBBRRBBRRRRRRRR 예제 출력 114 3 출처Olympiad &gt; USA Computing Olympiad &gt; 2013-2014 Season &gt; USACO March 2014 Contest &gt; Bronze 3번 문제를 번역한 사람: baekjoon 어색한 표현을 찾은 사람: corea 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_DFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546import syssys.setrecursionlimit(10**6)input = sys.stdin.readline# 방향정의dx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]def dfs(matrix, x, y, value): matrix[x][y] = 0 for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; N: if matrix[nx][ny] == value: dfs(matrix, nx, ny, value)N = int(input())grid = [list(input().rstrip()) for _ in range(N)] # people(R,G,B)grid2 = [[0] * N for _ in range(N)] # people(R=G, B)for i in range(N): for j in range(N): if grid[i][j] == 'R' or grid[i][j] == 'G': grid2[i][j] = 1 else: grid2[i][j] = 2rgb_count = 0b_count = 0for i in range(N): for j in range(N): if grid[i][j] != 0: dfs(grid, i, j, grid[i][j]) rgb_count += 1 if grid2[i][j] != 0: dfs(grid2, i, j, grid2[i][j]) b_count += 1print(rgb_count, b_count)","link":"/categories/Algorithm/Python/BAEKJOON-10026-21-04-24/"},{"title":"[백준] 1009번 분산처리","text":"출처: [백준] 1009번 분산처리 문제재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다. 1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터, … , 10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터, … 총 데이터의 개수는 항상 ab개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라. 입력입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 a와 b가 주어진다. (1 ≤ a &lt; 100, 1 ≤ b &lt; 1,000,000) 출력각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다. 예제 입력 112345651 63 76 27 1009 635 예제 출력 11234517619 힌트 출처 문제를 만든 사람: hellodj 데이터를 추가한 사람: kjiwhan0120, sait2000 알고리즘 분류 수학 구현 시간 제한 풀이 소스코드123456789101112131415import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): a, b = map(int, input().split()) result = [(a ** i) % 10 for i in range(1, 5)] result = result[(b % 4) - 1] if result != 0: print(result) else: print(10)","link":"/categories/Algorithm/Python/BAEKJOON-1009-21-03-26/"},{"title":"[백준] 1003번 피보나치 함수","text":"출처: [백준] 1003번 피보나치 함수 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 0.25 초 (추가 시간 없음) 128 MB 115259 30059 23610 30.125% 문제다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다. 1int` `fibonacci(``int` `n) {`` ``if` `(n == 0) {`` ``printf``(``&quot;0&quot;``);`` ``return` `0;`` ``} ``else` `if` `(n == 1) {`` ``printf``(``&quot;1&quot;``);`` ``return` `1;`` ``} ``else` `{`` ``return` `fibonacci(n‐1) + fibonacci(n‐2);`` ``}``} fibonacci(3)을 호출하면 다음과 같은 일이 일어난다. fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다. fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다. 두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다. fibonacci(0)은 0을 출력하고, 0을 리턴한다. fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다. 첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다. fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다. 1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오. 입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다. 출력각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다. 예제 입력 112343013 예제 출력 11231 00 11 2 힌트 출처 문제를 번역한 사람: baekjoon 어색한 표현을 찾은 사람: cyj101366 데이터를 추가한 사람: doju, wonrok97 알고리즘 분류 다이나믹 프로그래밍 풀이 소스코드12345678910111213141516import sysinput = sys.stdin.readlinet = int(input())cnt0 = [1, 0]cnt1 = [0, 1]for i in range(2, 41): cnt0.append(cnt0[i - 1] + cnt0[i - 2]) cnt1.append(cnt1[i - 1] + cnt1[i - 2])for _ in range(t): n = int(input()) print(f&quot;{cnt0[n]} {cnt1[n]}&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-1003-21-04-05/"},{"title":"[백준] 10162번 전자레인지","text":"출처: [백준] 10162번 전자레인지 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 64 MB 13024 7454 6471 58.339% 문제3개의 시간조절용 버튼 A B C가 달린 전자레인지가 있다. 각 버튼마다 일정한 시간이 지정되어 있어 해당 버튼을 한번 누를 때마다 그 시간이 동작시간에 더해진다. 버튼 A, B, C에 지정된 시간은 각각 5분, 1분, 10초이다. 냉동음식마다 전자레인지로 요리해야할 시간 T가 초단위로 표시되어 있다. 우리는 A, B, C 3개의 버튼을 적절히 눌러서 그 시간의 합이 정확히 T초가 되도록 해야 한다. 단 버튼 A, B, C를 누른 횟수의 합은 항상 최소가 되어야 한다. 이것을 최소버튼 조작이라고 한다. 만일 요리시간이 100초라고 하면(T=100) B를 1번, C는 4번 누르면 된다. 이와 다르게 C를 10번 눌러도 100초가 되지만 이 경우 10번은 최소 횟수가 아니기 때문이 답이 될 수 없다. 이 경우 B 1번, C 4번, 총 5번이 최소버튼 조작이다. 그리고 T=234와 같이 3개의 버튼으로 시간을 정확히 맞출 수 없는 경우도 있다. 여러분은 주어진 요리시간 T초를 맞추기 위한 최소버튼 조작 방법을 구하는 프로그램을 작성해야 한다. 입력첫 번째 줄에는 요리시간 T(초)가 정수로 주어져 있으며 그 범위는 1 ≤ T ≤ 10,000 이다. 출력여러분은 T초를 위한 최소버튼 조작의 A B C 횟수를 첫 줄에 차례대로 출력해야 한다. 각각의 횟수 사이에는 빈 칸을 둔다. 해당 버튼을 누르지 않는 경우에는 숫자 0을 출력해야한다. 만일 제시된 3개의 버튼으로 T초를 맞출 수 없으면 음수 -1을 첫 줄에 출력해야 한다. 서브태스크 번호 배점 제한 1 30 T ≤ 60 2 30 T ≤ 300 3 40 T ≤ 10,000 예제 입력 11100 예제 출력 110 1 4 예제 입력 21189 예제 출력 21-1 출처 Olympiad &gt; 한국정보올림피아드 &gt; KOI 2014 &gt; 초등부 1번 문제의 오타를 찾은 사람: 79brue, ojh3316 데이터를 만든 사람: baekjoon 알고리즘 분류 수학 구현 그리디 알고리즘 소스코드123456789101112131415161718import sysinput = sys.stdin.readlineT = int(input())control = [300, 60, 10]count = [0, 0, 0]for i in range(3): if T &gt;= control[i]: count[i] = T // control[i] T %= control[i]if not T: print(*count)else: print(-1)","link":"/categories/Algorithm/Python/BAEKJOON-10162-21-08-02/"},{"title":"[백준] 1012번 유기농 배추","text":"출처: [백준] 1012번 유기농 배추 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 512 MB 72068 27007 18264 35.782% 문제차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. (한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다) 한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. (0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.) 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 1 1 1 0 0 0 0 1 0 0 1 1 1 입력입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 출력각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다. 예제 입력 1123456789101112131415161718192021210 8 170 01 01 14 24 34 52 43 47 48 49 47 58 59 57 68 69 610 10 15 5 예제 출력 11251 예제 입력 21234567815 3 60 21 22 23 24 24 0 예제 출력 212 힌트 출처 문제를 만든 사람: author2 빠진 조건을 찾은 사람: jinsj1 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_DFS(List)123456789101112131415161718192021222324252627282930313233343536373839import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readline# 이동할 네 방향 정의 (상, 하, 좌, 우)dx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]def dfs(x, y): ground[x][y] = 0 # 해당 지점은 확인 for i in range(4): nx = x + dx[i] ny = y + dy[i] if nx &lt; 0 or ny &lt; 0 or nx &gt;= N or ny &gt;= M: continue else: if ground[nx][ny] == 1: dfs(nx, ny)T = int(input())for _ in range(T): M, N, K = map(int, input().split()) ground = [[0 for _ in range(M)] for _ in range(N)] count = 0 for _ in range(K): X, Y = map(int, input().split()) ground[Y][X] = 1 for i in range(N): for j in range(M): if ground[i][j] == 1: dfs(i, j) count += 1 print(count)","link":"/categories/Algorithm/Python/BAEKJOON-1012-21-04-20/"},{"title":"[백준] 1018번 체스판 다시 칠하기","text":"출처: [백준] 1018번 체스판 다시 칠하기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 37375 17060 13949 46.314% 문제지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 MN 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 88 크기의 체스판으로 만들려고 한다. 체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다. 보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8x8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8x8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다. 출력첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다. 예제 입력 11234567898 8WBWBWBWBBWBWBWBWWBWBWBWBBWBBBWBWWBWBWBWBBWBWBWBWWBWBWBWBBWBWBWBW 예제 출력 111 예제 입력 2123456789101110 13BBBBBBBBWBWBWBBBBBBBBBWBWBBBBBBBBBWBWBWBBBBBBBBBWBWBBBBBBBBBWBWBWBBBBBBBBBWBWBBBBBBBBBWBWBWBBBBBBBBBWBWBWWWWWWWWWWBWBWWWWWWWWWWBWB 예제 출력 2112 힌트 출처 문제를 번역한 사람: 데이터를 추가한 사람: 문제를 다시 작성한 사람: jh05013 알고리즘 분류 브루트포스 알고리즘 시간 제한 풀이 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243import sysinput = sys.stdin.readlineN, M = map(int, input().split())board = [list(input().rstrip()) for _ in range(N)]def check_BW(slice_board): # print(slice_board) black_cnt = 0 # black 시작 [bwbwbwbw],[wbwbwbwb] for row in range(8): for col in range(8): if (row % 2 == 0 and col % 2 == 0) or (row % 2 == 1 and col % 2 == 1): if slice_board[row][col] != &quot;B&quot;: black_cnt += 1 if (row % 2 == 0 and col % 2 == 1) or (row % 2 == 1 and col % 2 == 0): if slice_board[row][col] != &quot;W&quot;: black_cnt += 1 white_cnt = 0 # white 시작 [wbwbwbwb],[bwbwbwbw] for row in range(8): for col in range(8): if (row % 2 == 0 and col % 2 == 0) or (row % 2 == 1 and col % 2 == 1): if slice_board[row][col] != &quot;W&quot;: white_cnt += 1 if (row % 2 == 0 and col % 2 == 1) or (row % 2 == 1 and col % 2 == 0): if slice_board[row][col] != &quot;B&quot;: white_cnt += 1 return min(black_cnt, white_cnt)check = []for row in range(N - 7): for col in range(M - 7): cnt1, cnt2 = 0, 0 # 체스판 경우의 수 slicing c = [board[row + i][col:col + 8] for i in range(8)] # c = [c[(0 + col):(8 + col)] for c in board[(0 + row):(8 + row)]] check.append(check_BW(c))print(min(check))","link":"/categories/Algorithm/Python/BAEKJOON-1018-21-04-13/"},{"title":"[백준] 1032번 명령 프롬프트","text":"출처: [백준] 1032번 명령 프롬프트 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 17770 8716 7470 50.740% 문제시작 -&gt; 실행 -&gt; cmd를 쳐보자. 검정 화면이 눈에 보인다. 여기서 dir이라고 치면 그 디렉토리에 있는 서브디렉토리와 파일이 모두 나온다. 이때 원하는 파일을 찾으려면 다음과 같이 하면 된다. dir *.exe라고 치면 확장자가 exe인 파일이 다 나온다. “dir 패턴”과 같이 치면 그 패턴에 맞는 파일만 검색 결과로 나온다. 예를 들어, dir a?b.exe라고 검색하면 파일명의 첫 번째 글자가 a이고, 세 번째 글자가 b이고, 확장자가 exe인 것이 모두 나온다. 이때 두 번째 문자는 아무거나 나와도 된다. 예를 들어, acb.exe, aab.exe, apb.exe가 나온다. 이 문제는 검색 결과가 먼저 주어졌을 때, 패턴으로 뭘 쳐야 그 결과가 나오는지를 출력하는 문제이다. 패턴에는 알파벳과 “.” 그리고 “?”만 넣을 수 있다. 가능하면 ?을 적게 써야 한다. 그 디렉토리에는 검색 결과에 나온 파일만 있다고 가정하고, 파일 이름의 길이는 모두 같다. 입력첫째 줄에 파일 이름의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에는 파일 이름이 주어진다. N은 50보다 작거나 같은 자연수이고 파일 이름의 길이는 모두 같고 길이는 최대 50이다. 파일이름은 알파벳과 “.” 그리고 “?”로만 이루어져 있다. 출력첫째 줄에 패턴을 출력하면 된다. 예제 입력 112343config.sysconfig.infconfigures 예제 출력 11config???? 출처 문제를 번역한 사람: baekjoon 알고리즘 분류 구현 문자열 소스코드1234567891011121314151617import sysinput = sys.stdin.readlineN = int(input())file_list = [list(input().rstrip()) for _ in range(N)]input_word = file_list[-1]for i in range(N - 1): for j in range(len(input_word)): if input_word[j] == file_list[i][j]: continue else: input_word[j] = '?'print(''.join(input_word))","link":"/categories/Algorithm/Python/BAEKJOON-1032-21-05-29/"},{"title":"[백준] 1051번 숫자 정사각형","text":"출처: [백준] 1051번 숫자 정사각형 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 10235 3747 3173 37.528% 문제N*M크기의 직사각형이 있다. 각 칸은 한 자리 숫자가 적혀 있다. 이 직사각형에서 꼭짓점에 쓰여 있는 수가 모두 같은 가장 큰 정사각형을 찾는 프로그램을 작성하시오. 이때, 정사각형은 행 또는 열에 평행해야 한다. 입력첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 수가 주어진다. 출력첫째 줄에 정답 정사각형의 크기를 출력한다. 예제 입력 112343 5421012210022101 예제 출력 119 출처 빠진 조건을 찾은 사람: adh0463 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: jh05013 알고리즘 분류 구현 브루트포스 알고리즘 소스코드1234567891011121314151617import sysinput = sys.stdin.readlineN, M = map(int, input().split())rectangle = [list(map(int, input().rstrip())) for _ in range(N)]max_edge = min(N, M)result = 0for i in range(N): for j in range(M): for k in range(max_edge): if i + k &lt; N and j + k &lt; M: if rectangle[i][j] == rectangle[i][j + k] == rectangle[i + k][j] == rectangle[i + k][j + k]: result = max(result, (k + 1) ** 2)print(result)","link":"/categories/Algorithm/Python/BAEKJOON-1051-21-06-20/"},{"title":"[백준] 10546번 배부른 마라토너","text":"출처: [백준] 10546번 배부른 마라토너 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 2023 867 681 44.597% 문제마라토너라면 국적과 나이를 불문하고 누구나 참가하고 싶어하는 백준 마라톤 대회가 열린다. 42.195km를 달리는 이 마라톤은 모두가 참가하고 싶어했던 만큼 매년 모두가 완주해왔다. 단, 한 명만 빼고! 모두가 참가하고 싶어서 안달인데 이런 백준 마라톤 대회에 참가해 놓고 완주하지 못한 배부른 참가자 한 명은 누굴까? 입력첫째 줄에는 참가자 수 N이 주어진다. (1 ≤ N ≤ 105) N개의 줄에는 참가자의 이름이 주어진다. 추가적으로 주어지는 N-1개의 줄에는 완주한 참가자의 이름이 쓰여져 있다. 참가자들의 이름은 길이가 1보다 크거나 같고, 20보다 작거나 같은 문자열이고, 알파벳 소문자로만 이루어져 있다. 참가자들 중엔 동명이인이 있을 수도 있다. 출력마라톤을 완주하지 못한 참가자의 이름을 출력한다. 예제 입력 11234563leokikiedenedenkiki 예제 출력 11leo 예제 입력 2123456789105marinajosipanikolavinkofilipajosipafilipamarinanikola 예제 출력 21vinko 예제 입력 3123456784mislavstankomislavanastankoanamislav 예제 출력 31mislav 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2014/2015 &gt; Contest #2 2번 잘못된 번역을 찾은 사람: plzrun 문제를 번역한 사람: yang 알고리즘 분류 자료 구조 해시를 사용한 집합과 맵 소스코드123456789101112131415161718192021222324import sysinput = sys.stdin.readlineN = int(input())participants = {}for _ in range(N): participant = input().rstrip() if participant in participants: participants[participant] += 1 else: participants[participant] = 0for _ in range(N - 1): participants[input().rstrip()] += 1for key, value in participants.items(): if value % 2 == 0: print(key) break else: continue","link":"/categories/Algorithm/Python/BAEKJOON-10546-21-07-02/"},{"title":"[백준] 10797번 10부제","text":"출처: [백준] 10797번 10부제 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 11595 9291 8405 81.880% 문제서울시는 6월 1일부터 교통 혼잡을 막기 위해서 자동차 10부제를 시행한다. 자동차 10부제는 자동차 번호의 일의 자리 숫자와 날짜의 일의 자리 숫자가 일치하면 해당 자동차의 운행을 금지하는 것이다. 예를 들어, 자동차 번호의 일의 자리 숫자가 7이면 7일, 17일, 27일에 운행하지 못한다. 또한, 자동차 번호의 일의 자리 숫자가 0이면 10일, 20일, 30일에 운행하지 못한다. 여러분들은 일일 경찰관이 되어 10부제를 위반하는 자동차의 대수를 세는 봉사활동을 하려고 한다. 날짜의 일의 자리 숫자가 주어지고 5대의 자동차 번호의 일의 자리 숫자가 주어졌을 때 위반하는 자동차의 대수를 출력하면 된다. 입력첫 줄에는 날짜의 일의 자리 숫자가 주어지고 두 번째 줄에는 5대의 자동차 번호의 일의 자리 숫자가 주어진다. 날짜와 자동차의 일의 자리 숫자는 모두 0에서 9까지의 정수 중 하나이다. 출력주어진 날짜와 자동차의 일의 자리 숫자를 보고 10부제를 위반하는 차량의 대수를 출력한다. 예제 입력 11211 2 3 4 5 예제 출력 111 예제 입력 2123111 예제 출력 212 예제 입력 31251 3 0 7 4 예제 출력 310 출처 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2015 &gt; 초등부 1번 데이터를 만든 사람: baekjoon 잘못된 데이터를 찾은 사람: jh05013 알고리즘 분류 구현 소스코드1234567891011N = int(input())car_list = list(map(int, input().split()))count = 0for car in car_list: if N == car: count += 1print(count)","link":"/categories/Algorithm/Python/BAEKJOON-10797-21-06-14/"},{"title":"[백준] 10808번 알파벳 개수","text":"출처: [백준] 10808번 알파벳 개수 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 18151 12517 10446 69.850% 문제알파벳 소문자로만 이루어진 단어 S가 주어진다. 각 알파벳이 단어에 몇 개가 포함되어 있는지 구하는 프로그램을 작성하시오. 입력첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다. 출력단어에 포함되어 있는 a의 개수, b의 개수, …, z의 개수를 공백으로 구분해서 출력한다. 예제 입력 11baekjoon 예제 출력 111 1 0 0 1 0 0 0 0 1 1 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 출처 문제를 만든 사람: baekjoon 잘못된 데이터를 찾은 사람: djm03178 문제의 오타를 찾은 사람: eric00513 알고리즘 분류 구현 문자열 소스코드123456789101112131415import sysinput = sys.stdin.readlinestring = list(input().rstrip())alpha_count = {}for i in range(ord('z') - ord('a') + 1): alpha_count[chr(ord('a') + i)] = 0for alphabet in string: alpha_count[alphabet] += 1print(*list(alpha_count.values()))","link":"/categories/Algorithm/Python/BAEKJOON-10808-21-05-22/"},{"title":"[백준] 10773번 제로","text":"출처: [백준] 10773번 제로 문제나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다. 재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다. 재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다. 재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자! 입력첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000) 이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 “0” 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다. 정수가 “0”일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.출력 출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다. 출력재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 231-1보다 작거나 같은 정수이다. 예제 입력 11234543040 예제 출력 110 예제 입력 21234567891011101354007006 예제 출력 217 힌트 예제 2의 경우를 시뮬레이션 해보면, [1] [1,3] [1,3,5] [1,3,5,4] [1,3,5] (0을 불렀기 때문에 최근의 수를 지운다) [1,3] (0을 불렀기 때문에 그 다음 최근의 수를 지운다) [1,3,7] [1,3] (0을 불렀기 때문에 최근의 수를 지운다) [1] (0을 불렀기 때문에 그 다음 최근의 수를 지운다) [1,6] 합은 7이다. 출처 Olympiad &gt; Canadian Computing Competition &amp; Olympiad &gt; 2015 &gt; CCC 2015 Senior Division 1번 문제의 오타를 찾은 사람: busyhuman 문제를 번역한 사람: koosaga 알고리즘 분류 구현 자료 구조 문자열 스택 시간 제한 풀이 소스코드123456789101112131415import sysinput = sys.stdin.readlineK = int(input())stack_list = []for _ in range(K): comm = int(input()) if comm == 0: stack_list.pop() else: stack_list.append(comm)print(sum(stack_list))","link":"/categories/Algorithm/Python/BAEKJOON-10773-21-03-27/"},{"title":"[백준] 10798번 세로읽기","text":"출처: [백준] 10798번 세로읽기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 12502 6979 6023 57.758% 문제아직 글을 모르는 영석이가 벽에 걸린 칠판에 자석이 붙어있는 글자들을 붙이는 장난감을 가지고 놀고 있다. 이 장난감에 있는 글자들은 영어 대문자 ‘A’부터 ‘Z’, 영어 소문자 ‘a’부터 ‘z’, 숫자 ‘0’부터 ‘9’이다. 영석이는 칠판에 글자들을 수평으로 일렬로 붙여서 단어를 만든다. 다시 그 아래쪽에 글자들을 붙여서 또 다른 단어를 만든다. 이런 식으로 다섯 개의 단어를 만든다. 아래 그림 1은 영석이가 칠판에 붙여 만든 단어들의 예이다. 12345A A B C D Da f z z 0 9 1 2 1a 8 E W g 6P 5 h 3 k x &lt;그림 1&gt; 한 줄의 단어는 글자들을 빈칸 없이 연속으로 나열해서 최대 15개의 글자들로 이루어진다. 또한 만들어진 다섯 개의 단어들의 글자 개수는 서로 다를 수 있다. 심심해진 영석이는 칠판에 만들어진 다섯 개의 단어를 세로로 읽으려 한다. 세로로 읽을 때, 각 단어의 첫 번째 글자들을 위에서 아래로 세로로 읽는다. 다음에 두 번째 글자들을 세로로 읽는다. 이런 식으로 왼쪽에서 오른쪽으로 한 자리씩 이동 하면서 동일한 자리의 글자들을 세로로 읽어 나간다. 위의 그림 1의 다섯 번째 자리를 보면 두 번째 줄의 다섯 번째 자리의 글자는 없다. 이런 경우처럼 세로로 읽을 때 해당 자리의 글자가 없으면, 읽지 않고 그 다음 글자를 계속 읽는다. 그림 1의 다섯 번째 자리를 세로로 읽으면 D1gk로 읽는다. 그림 1에서 영석이가 세로로 읽은 순서대로 글자들을 공백 없이 출력하면 다음과 같다: Aa0aPAf985Bz1EhCz2W3D1gkD6x 칠판에 붙여진 단어들이 주어질 때, 영석이가 세로로 읽은 순서대로 글자들을 출력하는 프로그램을 작성하시오. 입력총 다섯줄의 입력이 주어진다. 각 줄에는 최소 1개, 최대 15개의 글자들이 빈칸 없이 연속으로 주어진다. 주어지는 글자는 영어 대문자 ‘A’부터 ‘Z’, 영어 소문자 ‘a’부터 ‘z’, 숫자 ‘0’부터 ‘9’ 중 하나이다. 각 줄의 시작과 마지막에 빈칸은 없다. 출력영석이가 세로로 읽은 순서대로 글자들을 출력한다. 이때, 글자들을 공백 없이 연속해서 출력한다. 예제 입력 112345ABCDEabcde01234FGHIJfghij 예제 출력 11Aa0FfBb1GgCc2HhDd3IiEe4Jj 예제 입력 212345AABCDDafzz09121a8EWg6P5h3kx 예제 출력 21Aa0aPAf985Bz1EhCz2W3D1gkD6x 출처 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2015 &gt; 초등부 2번 데이터를 만든 사람: baekjoon 알고리즘 분류 구현 문자열 소스코드123456789101112131415161718import sysinput = sys.stdin.readlineinput_string = [[0] * 15 for _ in range(5)]for i in range(5): temp = list(input().rstrip()) for j in range(len(temp)): input_string[i][j] = temp[j]for i in range(15): for j in range(5): if input_string[j][i] == 0: continue else: print(input_string[j][i], end=&quot;&quot;) 소스코드12345678910111213import sysinput = sys.stdin.readlineinput_string = [list(input().rstrip()) for _ in range(5)]for i in range(15): for j in range(5): if not input_string[j]: continue else: print(input_string[j].pop(0), end=&quot;&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-10798-21-06-22/"},{"title":"[백준] 10799번 쇠막대기","text":"출처: [백준] 10799번 쇠막대기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 25974 16167 11772 62.497% 문제여러 개의 쇠막대기를 레이저로 절단하려고 한다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다. 쇠막대기와 레이저의 배치는 다음 조건을 만족한다. 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다. 각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다. 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다. 아래 그림은 위 조건을 만족하는 예를 보여준다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다. 이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다. 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반드시 레이저를 표현한다. 쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다. 위 예의 괄호 표현은 그림 위에 주어져 있다. 쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다. 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하시오. 입력한 줄에 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 공백없이 주어진다. 괄호 문자의 개수는 최대 100,000이다. 출력잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력한다. 예제 입력 11()(((()())(())()))(()) 예제 출력 1117 예제 입력 21(((()(()()))(())()))(()()) 예제 출력 2124 출처 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2015 &gt; 중등부 2번 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2015 &gt; 초등부 3번 데이터를 만든 사람: baekjoon 데이터를 추가한 사람: djm03178 알고리즘 분류 자료 구조 스택 소스코드1234567891011121314151617181920212223import sysinput = sys.stdin.readlinerazer = list(input().rstrip())# print(razer)answer = 0stack = []for i in range(len(razer)): if razer[i] == '(': stack.append('(') else: if razer[i - 1] == '(': # )가 왔는데 이전이 바로 (일 경우 stack.pop() answer += len(stack) else: stack.pop() answer += 1print(answer)","link":"/categories/Algorithm/Python/BAEKJOON-10799-21-07-07/"},{"title":"[백준] 10826번 피보나치 수4","text":"출처: [백준] 10826번 피보나치 수4 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 8506 2779 2352 39.437% 문제피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다. n=17일때 까지 피보나치 수를 써보면 다음과 같다. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597 n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 n이 주어진다. n은 10,000보다 작거나 같은 자연수 또는 0이다. 출력첫째 줄에 n번째 피보나치 수를 출력한다. 예제 입력 1110 예제 출력 1155 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 다이나믹 프로그래밍 임의 정밀도 / 큰 수 연산 비슷한 문제 2747번. 피보나치 수 2748번. 피보나치 수 2 2749번. 피보나치 수 3 10870번. 피보나치 수 5 풀이 소스코드 1 (반복문을 이용한 다이나믹 프로그래밍)12345678910111213import sysinput = sys.stdin.readlinefibo = [-1] * 10001fibo[0] = 0fibo[1] = 1N = int(input())for i in range(2, N + 1): fibo[i] = fibo[i - 1] + fibo[i - 2]print(fibo[N])","link":"/categories/Algorithm/Python/BAEKJOON-10826-21-04-04/"},{"title":"[백준] 10828번 스택","text":"출처: [백준] 10828번 스택 문제정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오. 명령은 총 다섯 가지이다. push X: 정수 X를 스택에 넣는 연산이다. pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 스택에 들어있는 정수의 개수를 출력한다. empty: 스택이 비어있으면 1, 아니면 0을 출력한다. top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다. 입력첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다. 출력출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다. 예제 입력 112345678910111213141514push 1push 2topsizeemptypoppoppopsizeemptypoppush 3emptytop 예제 출력 1123456789101122021-101-103 예제 입력 2123456787poptoppush 123toppoptoppop 예제 출력 2123456-1-1123123-1-1 힌트 출처 문제를 만든 사람: baekjoon 데이터를 추가한 사람: djm03178 알고리즘 분류 자료 구조 스택 시간 제한 풀이 소스코드12345678910111213141516171819202122232425262728import sysinput = sys.stdin.readlineN = int(input())stack = []for _ in range(N): command = list(input().split()) if command[0] == 'push': stack.append(command[1]) elif command[0] == 'pop': if not stack: print(-1) else: print(stack.pop()) elif command[0] == 'size': print(len(stack)) elif command[0] == 'empty': if not stack: print(1) else: print(0) elif command[0] == 'top': if not stack: print(-1) else: print(stack[-1])","link":"/categories/Algorithm/Python/BAEKJOON-10828-21-03-26/"},{"title":"[백준] 10820번 문자열 분석","text":"출처: [백준] 10820번 문자열 분석 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 16180 6710 5581 42.714% 문제문자열 N개가 주어진다. 이때, 문자열에 포함되어 있는 소문자, 대문자, 숫자, 공백의 개수를 구하는 프로그램을 작성하시오. 각 문자열은 알파벳 소문자, 대문자, 숫자, 공백으로만 이루어져 있다. 입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. (1달러 = 100센트) (1&lt;=C&lt;=500) 출력첫째 줄부터 N번째 줄까지 문자열이 주어진다. (1 ≤ N ≤ 100) 문자열의 길이는 100을 넘지 않는다. 예제 입력 11234This is StringSPACE 1 SPACE S a M p L e I n P u T 0L1A2S3T4L5I6N7E8 예제 출력 1123410 2 0 20 10 1 85 6 0 160 8 9 0 출처 문제를 만든 사람: baekjoon 알고리즘 분류 구현 문자열 소스코드123456789101112131415161718192021222324import sysinput = sys.stdin.readlinewhile True: input_string = input().rstrip('\\n') if not input_string: break lower, upper, digit, space = 0, 0, 0, 0 for ch in input_string: if ch.islower(): lower += 1 elif ch.isupper(): upper += 1 elif ch.isdigit(): digit += 1 elif ch.isspace(): space += 1 print(f&quot;{lower} {upper} {digit} {space}&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-10820-21-07-30/"},{"title":"[백준] 10830번 행렬제곱","text":"출처: [백준] 2740번 행렬곱셈 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 10162 3490 2817 34.179% 문제크기가 N x N인 행렬 A가 주어진다. 이때, A의 B제곱을 구하는 프로그램을 작성하시오. 수가 매우 커질 수 있으니, A^B의 각 원소를 1,000으로 나눈 나머지를 출력한다. 입력첫째 줄에 행렬의 크기 N과 B가 주어진다. (2 ≤ N ≤ 5, 1 ≤ B ≤ 100,000,000,000) 둘째 줄부터 N개의 줄에 행렬의 각 원소가 주어진다. 행렬의 각 원소는 1,000보다 작거나 같은 자연수 또는 0이다. 출력첫째 줄부터 N개의 줄에 걸쳐 행렬 A를 B제곱한 결과를 출력한다. 예제 입력 11232 51 23 4 예제 출력 11269 558337 406 예제 입력 212343 31 2 34 5 67 8 9 예제 출력 2123468 576 68462 305 548656 34 412 예제 입력 31234565 101 0 0 0 11 0 0 0 11 0 0 0 11 0 0 0 11 0 0 0 1 예제 출력 312345512 0 0 0 512512 0 0 0 512512 0 0 0 512512 0 0 0 512512 0 0 0 512 힌트 출처 문제를 만든 사람: baekjoon 데이터를 추가한 사람: doju 잘못된 조건을 찾은 사람: dreammusic23 알고리즘 분류 수학 분할 정복 분할 정복을 이용한 거듭제곱 선형대수학 시간 제한 풀이 소스코드123456789101112131415161718192021222324252627282930313233343536373839404142import sysinput = sys.stdin.readlineN, B = map(int, input().split())matrix = [list(map(int, input().split())) for _ in range(N)]def matrix_multiple(a, b): if b == 1: for i in range(N): for j in range(N): a[i][j] %= 1000 return a else: if b % 2 == 0: # 제곱수가 짝수일 때 AAAAAA --&gt; (A^2)^2^2 temp_matrix = [[0 for _ in range(N)] for _ in range(N)] c = matrix_multiple(a, b // 2) for i in range(N): for j in range(N): for k in range(N): temp_matrix[i][j] += c[i][k] * c[k][j] temp_matrix[i][j] %= 1000 return temp_matrix else: # AAAAA --&gt; (A^2)^2 * A temp_matrix = [[0 for _ in range(N)] for _ in range(N)] c = matrix_multiple(a, b - 1) for i in range(N): for j in range(N): for k in range(N): temp_matrix[i][j] += c[i][k] * a[k][j] temp_matrix[i][j] %= 1000 return temp_matrixresult = matrix_multiple(matrix, B)for row in result: for value in row: print(value, end=&quot; &quot;) print()","link":"/categories/Algorithm/Python/BAEKJOON-10830-21-04-03/"},{"title":"[백준] 1021번 회전하는 큐","text":"출처: [백준] 1021번 회전하는 큐 문제지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다. 지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다. 첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 a1, …, ak이었던 것이 a2, …, ak와 같이 된다. 왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, …, ak가 a2, …, ak, a1이 된다. 오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, …, ak가 ak, a1, …, ak-1이 된다. 큐에 처음에 포함되어 있던 수 N이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오. 입력첫째 줄에 큐의 크기 N과 뽑아내려고 하는 수의 개수 M이 주어진다. N은 50보다 작거나 같은 자연수이고, M은 N보다 작거나 같은 자연수이다. 둘째 줄에는 지민이가 뽑아내려고 하는 수의 위치가 순서대로 주어진다. 위치는 1보다 크거나 같고, N보다 작거나 같은 자연수이다. 출력첫째 줄에 문제의 정답을 출력한다. 예제 입력 11210 31 2 3 예제 출력 110 예제 입력 21210 32 9 5 예제 출력 218 예제 입력 31232 627 16 30 11 6 23 예제 출력 3159 예제 입력 41210 101 6 3 2 7 9 8 4 10 5 예제 출력 4114 힌트 출처 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: dhdh6190 데이터를 추가한 사람: djm03178://www.acmicpc.net/user/sungjune222) 알고리즘 분류 자료 구조 덱 시간 제한 풀이 소스코드123456789101112131415161718192021222324252627282930313233import sysfrom collections import dequeinput = sys.stdin.readlineN, M = map(int, input().split())pick_list = list(map(int, input().split()))count = 0num_list = deque([x for x in range(1, N + 1)])for i in range(M): num_len = len(num_list) num_index = num_list.index(pick_list[i]) if num_index &lt; num_len - num_index: # 왼쪽에 가까우면 while True: if num_list[0] == pick_list[i]: num_list.popleft() break else: num_list.rotate(-1) count += 1 else: # 오른쪽에 가까우면 while True: if num_list[0] == pick_list[i]: num_list.popleft() break else: num_list.rotate(1) count += 1print(count)","link":"/categories/Algorithm/Python/BAEKJOON-1021-21-03-25/"},{"title":"[백준] 10844번 쉬운 계단 수","text":"출처: [백준] 10844번 쉬운 계단 수 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 77392 23572 16910 28.505% 문제45656이란 수를 보자. 이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다. 세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다. N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.) 입력첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다. 출력첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다. 예제 입력 111 예제 출력 119 예제 입력 212 예제 출력 2117 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 다이나믹 프로그래밍 시간 제한 풀이 소스코드12345678910111213141516171819import sysinput = sys.stdin.readlinedp = [[1 for _ in range(10)]]for i in range(99): dp.append([0 for _ in range(10)])for i in range(99): for j in range(10): if 1 &lt;= j &lt; 9: dp[i + 1][j] = dp[i][j - 1] + dp[i][j + 1] elif j &gt;= 9: dp[i + 1][j] = dp[i][j - 1] elif j &lt;= 0: dp[i + 1][j] = dp[i][j + 1]# print(dp)n = int(input())print((sum(dp[n - 1]) - dp[n - 1][0]) % 1000000000)","link":"/categories/Algorithm/Python/BAEKJOON-10844-21-04-14/"},{"title":"[백준] 10845번 큐","text":"출처: [백준] 10845번 큐 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 0.5 초 (추가 시간 없음) 256 MB 52286 24664 19014 48.962% 문제정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오. 명령은 총 여섯 가지이다. push X: 정수 X를 큐에 넣는 연산이다. pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 큐에 들어있는 정수의 개수를 출력한다. empty: 큐가 비어있으면 1, 아니면 0을 출력한다. front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다. back: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다. 입력첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다. 출력출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다. 예제 입력 11234567891011121314151615push 1push 2frontbacksizeemptypoppoppopsizeemptypoppush 3emptyfront 예제 출력 1123456789101112122012-101-103 출처 문제를 만든 사람: baekjoon 문제의 오타를 찾은 사람: compro0317 알고리즘 분류 자료 구조 큐 소스코드123456789101112131415161718192021222324252627282930313233import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())q = deque([])for _ in range(N): command = input().split() if command[0] == 'push': q.append(command[1]) elif command[0] == 'pop': if not q: print(-1) else: print(q.popleft()) elif command[0] == 'size': print(len(q)) elif command[0] == 'empty': if not q: print(1) else: print(0) elif command[0] == 'front': if not q: print(-1) else: print(q[0]) elif command[0] == 'back': if not q: print(-1) else: print(q[-1])","link":"/categories/Algorithm/Python/BAEKJOON-10845-21-05-19/"},{"title":"[백준] 10866번 덱","text":"출처: [백준] 10866번 덱 문제정수를 저장하는 덱(Deque)를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오. 명령은 총 여덟 가지이다. push_front X: 정수 X를 덱의 앞에 넣는다. push_back X: 정수 X를 덱의 뒤에 넣는다. pop_front: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. pop_back: 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 덱에 들어있는 정수의 개수를 출력한다. empty: 덱이 비어있으면 1을, 아니면 0을 출력한다. front: 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. back: 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. 입력첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다. 출력출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다. 예제 입력 11234567891011121314151615push_back 1push_front 2frontbacksizeemptypop_frontpop_backpop_frontsizeemptypop_backpush_front 3emptyfront 예제 출력 1123456789101112212021-101-103 예제 입력 2123456789101112131415161718192021222322frontbackpop_frontpop_backpush_front 1frontpop_backpush_back 2backpop_frontpush_front 10push_front 333frontbackpop_backpop_backpush_back 20push_back 1234frontbackpop_backpop_back 예제 출력 212345678910111213141516-1-1-1-111223331010333201234123420 힌트 출처 문제를 만든 사람: baekjoon 데이터를 추가한 사람: jh05013 문제의 오타를 찾은 사람: sungjune222 알고리즘 분류 자료 구조 덱 시간 제한 풀이 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())queue = deque([])for _ in range(N): comm = input().split() if comm[0] == 'push_front': queue.appendleft(comm[1]) elif comm[0] == 'push_back': queue.append(comm[1]) elif comm[0] == 'pop_front': if not queue: print(-1) else: print(queue.popleft()) elif comm[0] == 'pop_back': if not queue: print(-1) else: print(queue.pop()) elif comm[0] == 'size': print(len(queue)) elif comm[0] == 'empty': if not queue: print(1) else: print(0) elif comm[0] == 'front': if not queue: print(-1) else: print(queue[0]) elif comm[0] == 'back': if not queue: print(-1) else: print(queue[-1])","link":"/categories/Algorithm/Python/BAEKJOON-10866-21-03-24/"},{"title":"[백준] 10972번 다음 순열","text":"출처: [백준] 10972번 다음 순열 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 17068 7204 5176 43.001% 문제1부터 N까지의 수로 이루어진 순열이 있다. 이때, 사전순으로 다음에 오는 순열을 구하는 프로그램을 작성하시오. 사전 순으로 가장 앞서는 순열은 오름차순으로 이루어진 순열이고, 가장 마지막에 오는 순열은 내림차순으로 이루어진 순열이다. N = 3인 경우에 사전순으로 순열을 나열하면 다음과 같다. 1, 2, 3 1, 3, 2 2, 1, 3 2, 3, 1 3, 1, 2 3, 2, 1 입력첫째 줄에 N(1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄에 순열이 주어진다. 출력첫째 줄에 입력으로 주어진 순열의 다음에 오는 순열을 출력한다. 만약, 사전순으로 마지막에 오는 순열인 경우에는 -1을 출력한다. 예제 입력 11241 2 3 4 예제 출력 111 2 4 3 예제 입력 21255 4 3 2 1 예제 출력 21-1 출처 문제를 만든 사람: baekjoon 알고리즘 분류 수학 조합론 소스코드1234567891011121314151617181920212223242526import sysinput = sys.stdin.readlineN = int(input())compare_list = list(map(int, input().split()))i, j, k = [len(compare_list) - 1 for _ in range(3)] # 맨 뒤부터...while i &gt; 0 and compare_list[i - 1] &gt;= compare_list[i]: # 맨 뒤부터 오름차순... 즉 내림차순일 경우 i -= 1if not i: # 다음 순열이 없을 경우 print(-1) exit(0)while compare_list[i - 1] &gt;= compare_list[j]: j -= 1compare_list[i - 1], compare_list[j] = compare_list[j], compare_list[i - 1]while i &lt; k: compare_list[i], compare_list[k] = compare_list[k], compare_list[i] i += 1 k -= 1print(*compare_list)","link":"/categories/Algorithm/Python/BAEKJOON-10972-21-06-18/"},{"title":"[백준] 10973번 이전 순열","text":"출처: [백준] 10973번 이전 순열 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 7635 4771 3960 64.780% 문제1부터 N까지의 수로 이루어진 순열이 있다. 이때, 사전순으로 바로 이전에 오는 순열을 구하는 프로그램을 작성하시오. 사전 순으로 가장 앞서는 순열은 오름차순으로 이루어진 순열이고, 가장 마지막에 오는 순열은 내림차순으로 이루어진 순열이다. N = 3인 경우에 사전순으로 순열을 나열하면 다음과 같다. 1, 2, 3 1, 3, 2 2, 1, 3 2, 3, 1 3, 1, 2 3, 2, 1 입력첫째 줄에 N(1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄에 순열이 주어진다. 출력첫째 줄에 입력으로 주어진 순열의 이전에 오는 순열을 출력한다. 만약, 사전순으로 가장 처음에 오는 순열인 경우에는 -1을 출력한다. 예제 입력 11241 2 3 4 예제 출력 11-1 예제 입력 21255 4 3 2 1 예제 출력 215 4 3 1 2 출처 문제를 만든 사람: baekjoon 알고리즘 분류 수학 구현 조합론 소스코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import sysinput = sys.stdin.readlineN = int(input())compare_list = list(map(int, input().split()))i, j, k = [len(compare_list) - 1 for _ in range(3)] # 맨 뒤부터...while i &gt; 0 and compare_list[i - 1] &lt;= compare_list[i]: # 맨 뒤부터 내림차순... 즉 오름차순일 경우 i -= 1if not i: # 이전 순열이 없을 경우 print(-1) exit(0)while compare_list[i - 1] &lt;= compare_list[j]: j -= 1compare_list[i - 1], compare_list[j] = compare_list[j], compare_list[i - 1]while i &lt; k: compare_list[i], compare_list[k] = compare_list[k], compare_list[i] i += 1 k -= 1print(*compare_list)------------메모리초과import sysfrom itertools import permutationsinput = sys.stdin.readlineN = int(input())compare_list = list(map(int, input().split()))num_list = [i for i in range(1, N + 1)]perm_list = list(permutations(num_list))for i in range(len(perm_list)): if list(perm_list[i]) == compare_list: if i==0: print(-1) else: for num in perm_list[i-1]: print(num, end=&quot; &quot;)","link":"/categories/Algorithm/Python/BAEKJOON-10973-21-06-18/"},{"title":"[백준] 10988번 팰린드롬인지 확인하기","text":"출처: [백준] 10988번 팰린드롬인지 확인하기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 10543 7038 6104 68.546% 문제알파벳 소문자로만 이루어진 단어가 주어진다. 이때, 이 단어가 팰린드롬인지 아닌지 확인하는 프로그램을 작성하시오. 팰린드롬이란 앞으로 읽을 때와 거꾸로 읽을 때 똑같은 단어를 말한다. level, noon은 팰린드롬이고, baekjoon, online, judge는 팰린드롬이 아니다. 입력첫째 줄에 단어가 주어진다. 단어의 길이는 1보다 크거나 같고, 100보다 작거나 같으며, 알파벳 소문자로만 이루어져 있다. 출력첫째 줄에 팰린드롬이면 1, 아니면 0을 출력한다. 예제 입력 11level 예제 출력 111 예제 입력 21baekjoon 예제 출력 210 출처 문제를 만든 사람: baekjoon 데이터를 추가한 사람: oopar2, pda_pro12 알고리즘 분류 구현 문자열 소스코드123456789101112131415161718import sysinput = sys.stdin.readlineinput_string = list(input().rstrip())while len(input_string) &gt;= 1: if len(input_string) == 1: break elif input_string[0] == input_string[-1]: input_string.pop(0) input_string.pop(-1) else: print(0) exit(0)print(1) 소스코드2123456789101112import sysinput = sys.stdin.readlineinput_string = list(input().rstrip())compare_string = list(reversed(input_string))if input_string == compare_string: print(1)else: print(0) 소스코드3123456789101112131415import sysinput = sys.stdin.readlineinput_string = list(input().rstrip())palindrome = 1for i in range(len(input_string) // 2): if input_string[i] != input_string[len(input_string) - 1 - i]: palindrome = 0if palindrome: print(1)else: print(0)","link":"/categories/Algorithm/Python/BAEKJOON-10988-21-06-23/"},{"title":"[백준] 10991번 별 찍기 - 16","text":"출처: [백준] 10991번 별 찍기 - 16 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 9810 7659 7074 79.181% 문제예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요. 입력첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다. 출력첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다. 예제 입력 111 예제 출력 11* 예제 입력 212 예제 출력 212 ** * 예제 입력 313 예제 출력 3123 * * ** * * 예제 입력 414 예제 출력 41234 * * * * * ** * * * 힌트 출처 문제를 만든 사람: baekjoon 문제의 오타를 찾은 사람: eric00513, moonhi123 알고리즘 분류 구현 시간 제한 풀이 소스코드123456789101112import sysinput = sys.stdin.readlineN = int(input())for i in range(1, N + 1): print(' ' * (N - i), end='') for j in range(i): print('*', end=' ') print()","link":"/categories/Algorithm/Python/BAEKJOON-10991-21-04-17/"},{"title":"[백준] 10870번 피보나치 수5","text":"출처: [백준] 10870번 피보나치 수5 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 32430 20856 18483 65.290% 문제피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다. n=17일때 까지 피보나치 수를 써보면 다음과 같다. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597 n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다. 출력첫째 줄에 n번째 피보나치 수를 출력한다. 예제 입력 1110 예제 출력 1155 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 수학 다이나믹 프로그래밍 비슷한 문제 2747번. 피보나치 수 2748번. 피보나치 수 2 2749번. 피보나치 수 3 10826번. 피보나치 수 4 풀이 소스코드 1 (재귀를 이용한 다이나믹 프로그래밍)12345678910111213141516171819202122import sysinput = sys.stdin.readlinen = int(input())fibo_memo = [-1] * 99def fibo_dynamic(n): if 0 &lt; n &lt;= 2: return 1 elif n == 0: return 0 if fibo_memo[n] != -1: return fibo_memo[n] fibo_memo[n] = fibo_dynamic(n - 1) + fibo_dynamic(n - 2) return fibo_memo[n]print(fibo_dynamic(n))","link":"/categories/Algorithm/Python/BAEKJOON-10870-21-04-04/"},{"title":"[백준] 1110번 더하기 사이클","text":"출처: [백준] 1110번 더하기 사이클 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 135236 64039 53523 47.801% 문제0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자. 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다. 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다. N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오. 입력첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다. 출력첫째 줄에 N의 사이클 길이를 출력한다. 예제 입력 1126 예제 출력 114 예제 입력 2155 예제 출력 213 예제 입력 311 예제 출력 3160 예제 입력 410 예제 출력 411 출처 문제를 번역한 사람: baekjoon 어색한 표현을 찾은 사람: doju 문제의 오타를 찾은 사람: eric00513 데이터를 추가한 사람: jh05013 알고리즘 분류 수학 구현 소스코드12345678910111213141516171819N = int(input())new_num = Nresult = 0while True: ten = new_num // 10 one = new_num % 10 sum_num = ten + one if sum_num &gt;= 10: sum_num = sum_num % 10 new_num = one * 10 + sum_num result += 1 if N == new_num: breakprint(result)","link":"/categories/Algorithm/Python/BAEKJOON-1110-21-08-07/"},{"title":"[백준] 1100번 하얀 칸","text":"출처: [백준] 1100번 하얀 칸 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 14533 9611 8429 68.724% 문제체스판은 8*8크기이고, 검정 칸과 하얀 칸이 번갈아가면서 색칠되어 있다. 가장 왼쪽 위칸 (0,0)은 하얀색이다. 체스판의 상태가 주어졌을 때, 하얀 칸 위에 말이 몇 개 있는지 출력하는 프로그램을 작성하시오. 입력첫째 줄부터 8개의 줄에 체스판의 상태가 주어진다. ‘.’은 빈 칸이고, ‘F’는 위에 말이 있는 칸이다. 출력첫째 줄에 문제의 정답을 출력한다. 예제 입력 112345678.F.F...FF...F.F....F.F.FF.F...F..F...F..F...F.F..F.F.F.F..FF..F. 예제 출력 111 출처 문제를 번역한 사람: baekjoon 알고리즘 분류 구현 문자열 소스코드1234567891011121314import sysinput = sys.stdin.readlineinput_board = [list(input().rstrip()) for _ in range(8)]count = 0for i in range(8): for j in range(8): if (i + j) % 2 == 0: if input_board[i][j] == 'F': count += 1print(count)","link":"/categories/Algorithm/Python/BAEKJOON-1100-21-05-29/"},{"title":"[백준] 11116번 교통량","text":"출처: [백준] 11116번 교통량 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 55 35 31 62.000% 문제승민이는 마포대교의 교통량이 얼마인지를 측정하고있다. 승민이는 도로 맞은 편을 잇는 두개의 끈을 일정 간격 사이로 매달아 놓았다. 그리고 자동차가 끈위로 지나갈때 끈 끝에 있는 작은 박스에는 그 때 의 시간이 기록된다. 예를 들어, 자동차가 왼쪽에서 올 때 네 번의 기록을 얻게 된다. 왼쪽 줄 위로 앞 바퀴가 지나 간 시간 t 왼쪽 줄 위로 뒷 바퀴가 지나 간 시간 t + 500 오른쪽 줄 위로 앞 바퀴가 지나 간 시간 t + 1000 오른쪽 줄 위로 뒷 바퀴가 지나 간 시간 t + 1500 자동차가 오른쪽에서 올 때도 같은 규칙으로 오른쪽과 왼쪽을 바꾸어 측정하면 된다. 주어진 두개의 시간 기록으로 왼쪽에서 얼마나 많은 차가 왔는지 알아내면 된다. 한 끈 위에는 많아야 한 대의 차량이 지나가고 있다. 입력첫 번째 줄에 n (1 ≤ n ≤ 100) 까지의 테스트 케이스의 개수를 입력 한다. 각각의 테스트 케이스에는 박스에서 측정 된 시간 기록의 개수 m (m ≤ 200)을 입력한다. 다음 줄에는 왼쪽 박스에서 측정된 109 보다 작은 시간 기록 m개를 입력한다. 그 다음 줄에는 오른쪽 박스에서 측정된 109 보다 작은 시간 기록 m개를 입력한다. 출력각각의 테스트케이스에 대해 왼쪽에서 오는 차의 숫자를 출력한다. 예제 입력 112345672417 517 1432 1932432 932 1017 15176235 451 735 951 2351 28511235 1351 1451 1735 1851 1951 예제 출력 11212 힌트예제의 첫 번째 테스트 케이스인 Case #1은 문제에서 예로들어서 설명한 세 개의 물품에 대한 정상가격과 할인가격 6개입니다. 또한 예제의 Case #2에서는 여러 품목이 동일한 가격을 가질 수 있고, 어떤 품목의 할인가격이 다른 품목 정상가격과 같을 수도 있습니다. 출처 Contest &gt; IDI Open Contest &gt; IDI Open 2008 I번 문제를 번역한 사람: tols91 알고리즘 분류 구현 자료 구조 큐 소스코드123456789101112131415161718192021222324import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())for _ in range(N): M = int(input()) left_box = deque(map(int, input().split())) right_box = deque(map(int, input().split())) car_count = 0 count = 0 while left_box: temp = left_box.popleft() if temp + 1000 in right_box: count += 1 if count == 2: count = 0 car_count += 1 print(car_count)","link":"/categories/Algorithm/Python/BAEKJOON-11116-21-07-21/"},{"title":"[백준] 1138번 한 줄로 서기","text":"출처: [백준] 1138번 한 줄로 서기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 6699 3604 3033 55.939% 문제N명의 사람들은 매일 아침 한 줄로 선다. 이 사람들은 자리를 마음대로 서지 못하고 오민식의 지시대로 선다. 어느 날 사람들은 오민식이 사람들이 줄 서는 위치를 기록해 놓는다는 것을 알았다. 그리고 아침에 자기가 기록해 놓은 것과 사람들이 줄을 선 위치가 맞는지 확인한다. 사람들은 자기보다 큰 사람이 왼쪽에 몇 명 있었는지만을 기억한다. N명의 사람이 있고, 사람들의 키는 1부터 N까지 모두 다르다. 각 사람들이 기억하는 정보가 주어질 때, 줄을 어떻게 서야 하는지 출력하는 프로그램을 작성하시오. 입력첫째 줄에 사람의 수 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 둘째 줄에는 키가 1인 사람부터 차례대로 자기보다 키가 큰 사람이 왼쪽에 몇 명이 있었는지 주어진다. i번째 수는 0보다 크거나 같고, N-i보다 작거나 같다. 출력첫째 줄에 줄을 선 순서대로 키를 출력한다. 예제 입력 11242 1 1 0 예제 출력 114 2 1 3 출처 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: dsa2341, taedy0311 알고리즘 분류 구현 소스코드12345678910111213141516171819import sysinput = sys.stdin.readlineN = int(input())memo = list(map(int, input().split()))result = [0 for _ in range(N)]for i in range(N): cnt = 0 for j in range(N): if memo[i] == cnt and result[j] == 0: result[j] = i + 1 break elif result[j] == 0: cnt += 1print(*result)","link":"/categories/Algorithm/Python/BAEKJOON-1138-21-06-21/"},{"title":"!!![백준] 11401번 이항 계수3","text":"출처: [백준] 11401번 이항 계수3 문제자연수 N과 정수 K가 주어졌을 때 이항 계수를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 4,000,000, 0 ≤ K ≤ N) 출력 를 1,000,000,007로 나눈 나머지를 출력한다. 예제 입력 115 2 예제 출력 1110 힌트 페르마의 소정리 이용 출처 문제를 만든 사람: baekjoon 데이터를 추가한 사람: kjo7811 알고리즘 분류 수학 정수론 페르마의 소정리 시간 제한 풀이 소스코드 1123456789101112131415161718192021222324252627282930313233343536373839import sysinput = sys.stdin.readlineN, K = map(int, input().split())mod = 1000000007def power(a, b): if b == 0: return 1 else: if b % 2 == 0: # B가 짝수일 때 return (power(a, b // 2) ** 2) % mod else: return (power(a, b // 2) ** 2 * a) % mod# Factorial dpfact = [1 for _ in range(N + 1)]for i in range(2, N + 1): fact[i] = fact[i - 1] * i % modchild = fact[N]parent = (fact[K] * fact[N - K]) % mod# 페르마의 소정리print((child % mod) * (power(parent, mod - 2) % mod) % mod)# -------------------------------------------------# for i in range(2, N + 1):# fact[i] = fact[i - 1] * i## child = fact[N]# parent = fact[K] * fact[N - K]# print(int(child / parent) % mod) ==&gt; 메모리초과","link":"/categories/Algorithm/Python/BAEKJOON-11401-21-04-02/"},{"title":"[백준] 11497번 통나무 건너뛰기","text":"출처: [백준] 11497번 통나무 건너뛰기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 3887 2184 1803 59.643% 문제남규는 통나무를 세워 놓고 건너뛰기를 좋아한다. 그래서 N개의 통나무를 원형으로 세워 놓고 뛰어놀려고 한다. 남규는 원형으로 인접한 옆 통나무로 건너뛰는데, 이때 각 인접한 통나무의 높이 차가 최소가 되게 하려 한다. 통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다. 높이가 {2, 4, 5, 7, 9}인 통나무들을 세우려 한다고 가정하자. 이를 [2, 9, 7, 4, 5]의 순서로 세웠다면, 가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 즉, 높이가 2인 것과 높이가 5인 것도 서로 인접해 있다. 배열 [2, 9, 7, 4, 5]의 난이도는 |2-9| = 7이다. 우리는 더 나은 배열 [2, 5, 9, 7, 4]를 만들 수 있으며 이 배열의 난이도는 |5-9| = 4이다. 이 배열보다 난이도가 낮은 배열은 만들 수 없으므로 이 배열이 남규가 찾는 답이 된다. 입력입력은 T개의 테스트 케이스로 이루어져 있다. 첫 줄에 T가 주어진다. 이어지는 각 줄마다 첫 줄에 통나무의 개수를 나타내는 정수 N(5 ≤ N ≤ 10,000), 둘째 줄에 각 통나무의 높이를 나타내는 정수 Li가 주어진다. (1 ≤ Li ≤ 100,000) 출력각 테스트 케이스마다 한 줄에 주어진 통나무들로 만들 수 있는 최소 난이도를 출력하시오. 예제 입력 112345673713 10 12 11 10 11 1252 4 5 7 986 6 6 6 6 6 6 6 예제 출력 1123140 출처 ICPC &gt; Regionals &gt; Asia Pacific &gt; Korea &gt; Asia Regional - Daejeon 2015 E번 문제를 번역한 사람: kks227 문제의 오타를 찾은 사람: ntopia 알고리즘 분류 그리디 알고리즘 정렬 소스코드1234567891011121314151617181920212223242526272829303132import sysinput = sys.stdin.readlineT = int(input())def lowLevelSort(trees): new_trees = [0] * len(trees) for i in range(len(trees)): if (i + 1) % 2 == 1: new_trees[i // 2] = trees[i] else: new_trees[len(trees) - (i // 2 + 1)] = trees[i] return new_treesfor _ in range(T): N = int(input()) log_trees = list(map(int, input().split())) log_trees = lowLevelSort(sorted(log_trees)) max_level = 0 for i in range(N - 1): if abs(log_trees[i] - log_trees[i + 1]) &gt; max_level: max_level = abs(log_trees[i] - log_trees[i + 1]) if abs(log_trees[-1] - log_trees[0]) &gt; max_level: max_level = abs(log_trees[-1] - log_trees[0]) print(max_level)","link":"/categories/Algorithm/Python/BAEKJOON-11497-21-08-13/"},{"title":"[백준] 11444번 피보나치 수6","text":"출처: [백준] 11444번 피보나치 수6 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 3363 1774 1450 57.494% 문제피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다. n=17일때 까지 피보나치 수를 써보면 다음과 같다. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597 n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다. 출력첫째 줄에 n번째 피보나치 수를 1,000,000,007으로 나눈 나머지를 출력한다. 예제 입력 111000 예제 출력 11517691607 힌트 피보나치 수를 구하는 여러가지 방법 출처 문제를 만든 사람: baekjoon 알고리즘 분류 수학 분할 정복을 이용한 거듭제곱 풀이 소스코드12345678910111213141516171819202122232425262728293031323334import sysinput = sys.stdin.readlineN = int(input())mod = 1000000007fibo = {}def fibo_dp(n): if n &lt;= 1: return n elif fibo.get(n): return fibo[n] else: if n % 2 == 1: # 홀수 m = (n + 1) // 2 temp1 = fibo_dp(m) temp2 = fibo_dp(m - 1) fibo[n] = temp1 ** 2 + temp2 ** 2 fibo[n] %= mod return fibo[n] else: # 짝수 m = n // 2 temp1 = fibo_dp(m - 1) temp2 = fibo_dp(m) fibo[n] = (2 * temp1 + temp2) * temp2 fibo[n] %= mod return fibo[n]print(fibo_dp(N))","link":"/categories/Algorithm/Python/BAEKJOON-11444-21-04-04/"},{"title":"[백준] 1158번 요세푸스 문제","text":"출처: [백준] 1158번 요세푸스 문제 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 256 MB 43385 20955 15031 48.193% 문제요세푸스 문제는 다음과 같다. 1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &lt;3, 6, 2, 7, 5, 1, 4&gt;이다. N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000) 출력예제와 같이 요세푸스 순열을 출력한다. 예제 입력 117 3 예제 출력 11&lt;3, 6, 2, 7, 5, 1, 4&gt; 출처 문제를 만든 사람: author5 알고리즘 분류 자료 구조 큐 소스코드123456789101112131415161718import sysfrom collections import dequeinput = sys.stdin.readlineN, K = map(int, input().split())queue = deque([i for i in range(1, N + 1)])print('&lt;', end='')while queue: for _ in range(K - 1): queue.append(queue[0]) queue.popleft() print(queue.popleft(), end=&quot;&quot;) if queue: print(',', end=&quot; &quot;)print('&gt;')","link":"/categories/Algorithm/Python/BAEKJOON-1158-21-05-12/"},{"title":"[백준] 11655번 ROT13","text":"출처: [백준] 11655번 ROT13 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 10304 6324 5522 62.729% 문제ROT13은 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다. 예를 들어, “Baekjoon Online Judge”를 ROT13으로 암호화하면 “Onrxwbba Bayvar Whqtr”가 된다. ROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. 앞에서 암호화한 문자열 “Onrxwbba Bayvar Whqtr”에 다시 ROT13을 적용하면 “Baekjoon Online Judge”가 된다. ROT13은 알파벳 대문자와 소문자에만 적용할 수 있다. 알파벳이 아닌 글자는 원래 글자 그대로 남아 있어야 한다. 예를 들어, “One is 1”을 ROT13으로 암호화하면 “Bar vf 1”이 된다. 문자열이 주어졌을 때, “ROT13”으로 암호화한 다음 출력하는 프로그램을 작성하시오. 입력첫째 줄에 알파벳 대문자, 소문자, 공백, 숫자로만 이루어진 문자열 S가 주어진다. S의 길이는 100을 넘지 않는다. 출력첫째 줄에 S를 ROT13으로 암호화한 내용을 출력한다. 예제 입력 11Baekjoon Online Judge 예제 출력 11Onrxwbba Bayvar Whqtr 예제 입력 21One is 1 예제 출력 21Bar vf 1 출처 문제를 만든 사람: baekjoon 알고리즘 분류 구현 문자열 소스코드12345678910111213141516171819202122232425import sysinput = sys.stdin.readlinesentence = list(input().rstrip())result = []for x in sentence: if x.isupper(): if ord(x) + 13 &lt;= 90: result.append(chr(ord(x) + 13)) else: result.append(chr(ord(x) - 13)) elif x.islower(): if ord(x) + 13 &lt;= 122: result.append(chr(ord(x) + 13)) else: result.append(chr(ord(x) - 13)) else: result.append(x)for x in result: print(x, end='')","link":"/categories/Algorithm/Python/BAEKJOON-11655-21-06-24/"},{"title":"[백준] 11723번 집합","text":"출처: [백준] 11723번 집합 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1.5 초 4 MB (하단 참고) 32627 10094 7070 30.218% 문제비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오. add x: S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다. remove x: S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다. check x: S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20) toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20) all: S를 {1, 2, …, 20} 으로 바꾼다. empty: S를 공집합으로 바꾼다. 입력첫째 줄에 수행해야 하는 연산의 수 M (1 ≤ M ≤ 3,000,000)이 주어진다. 둘째 줄부터 M개의 줄에 수행해야 하는 연산이 한 줄에 하나씩 주어진다. 출력check 연산이 주어질때마다, 결과를 출력한다. 예제 입력 112345678910111213141516171819202122232425262726add 1add 2check 1check 2check 3remove 2check 1check 2toggle 3check 1check 2check 3check 4allcheck 10check 20toggle 10remove 20check 10check 20emptycheck 1toggle 1check 1toggle 1check 1 예제 출력 1123456789101112131415161101010101100010 출처 문제를 만든 사람: baekjoon 빠진 조건을 찾은 사람: djm03178 데이터를 추가한 사람: houma757 문제의 오타를 찾은 사람: pichulias://www.acmicpc.net/user/djm03178) 알고리즘 분류 구현 비트마스킹 소스코드1234567891011121314151617181920212223242526272829import sysinput = sys.stdin.readlineM = int(input())S = set()for _ in range(M): comm = input().strip().split() if comm[0] == 'add': S.add(int(comm[1])) elif comm[0] == 'remove': S.discard(int(comm[1])) elif comm[0] == 'check': if int(comm[1]) in S: print(1) else: print(0) elif comm[0] == 'toggle': if int(comm[1]) in S: S.discard(int(comm[1])) else: S.add(int(comm[1])) elif comm[0] == 'all': S = set([i for i in range(1, 21)]) elif comm[0] == 'empty': S = set()","link":"/categories/Algorithm/Python/BAEKJOON-11723-21-06-16/"},{"title":"[백준] 11724번 연결 요소의 개수","text":"출처: [백준] 11724번 연결 요소의 개수 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 3 초 512 MB 42149 20184 13181 44.965% 문제방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다. 출력첫째 줄에 연결 요소의 개수를 출력한다. 예제 입력 11234566 51 22 55 13 44 6 예제 출력 112 예제 입력 21234567896 81 22 55 13 44 65 42 42 3 예제 출력 211 힌트 출처 문제를 만든 사람: baekjoon 데이터를 추가한 사람: djm03178, YunGoon 잘못된 조건을 찾은 사람: songjuh 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_DFS(List1)123456789101112131415161718192021222324252627282930import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readlinedef dfs(graph, v, visited): visited[v] = True for i in graph[v]: if not visited[i]: dfs(graph, i, visited)N, M = map(int, input().split())graph = [[] for _ in range(N + 1)]visited = [False] * (N + 1)component = 0for _ in range(M): src, dest = map(int, input().split()) graph[src].append(dest) graph[dest].append(src)for i in range(1, N + 1): if not visited[i]: dfs(graph, i, visited) component += 1print(component) 소스코드_DFS(List2)1234567891011121314151617181920212223242526272829import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readlinedef dfs(graph, v, visited): visited[v] = True for i in range(1, N + 1): if not visited[i] and graph[v][i] == 1: dfs(graph, i, visited)N, M = map(int, input().split())graph = [[0] * (N + 1) for _ in range(N + 1)]for _ in range(M): x, y = map(int, input().split()) graph[x][y] = 1 graph[y][x] = 1visited = [False] * (N + 1)component = 0for i in range(1, N + 1): if not visited[i]: dfs(graph, i, visited) component += 1print(component) 소스코드_DFS(Dict)123456789101112131415161718192021222324252627282930313233import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readlinedef dfs(graph, v, visited): visited[v] = True for i in graph[v]: if not visited[i]: dfs(graph, i, visited)N, M = map(int, input().split())graph = {}for i in range(N + 1): graph[i] = set()for _ in range(M): u, v = map(int, input().split()) graph[u].add(v) graph[v].add(u)visited = [False] * (N + 1)component = 0for i in range(1, N + 1): if not visited[i]: dfs(graph, i, visited) component += 1print(component)","link":"/categories/Algorithm/Python/BAEKJOON-11724-21-04-20/"},{"title":"[백준] 11725번 트리의 부모 찾기","text":"출처: [백준] 11725번 트리의 부모 찾기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 21429 9096 6766 43.043% 문제루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오. 입력첫째 줄에 노드의 개수 N (2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 트리 상에서 연결된 두 정점이 주어진다. 출력첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다. 예제 입력 1123456771 66 33 54 12 44 7 예제 출력 1123456461314 예제 입력 2123456789101112121 21 32 43 53 64 74 85 95 106 116 12 예제 출력 2123456789101111233445566 출처 문제를 만든 사람: baekjoon 잘못된 조건을 찾은 사람: jh05013 알고리즘 분류 그래프 이론 그래프 탐색 트리 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_DFS123456789101112131415161718192021222324252627282930import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readlineN = int(input())trees = {}for i in range(N): trees[i + 1] = set()for i in range(N - 1): a, b = map(int, input().split()) trees[a].add(b) trees[b].add(a)parents = [False] * (N + 1)def dfs(graph, v, visited): for i in graph[v]: if not visited[i]: visited[i] = v dfs(graph, i, visited)dfs(trees, 1, parents)for i in range(2, N + 1): print(parents[i])","link":"/categories/Algorithm/Python/BAEKJOON-11725-21-04-28/"},{"title":"[백준] 11729번 하노이 탑 이동 순서","text":"출처: [백준] 11729번 하노이 탑 이동 순서 문제세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다. 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. 이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다. 아래 그림은 원판이 5개인 경우의 예시이다. 입력첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다. 출력첫째 줄에 옮긴 횟수 K를 출력한다. 두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다. 예제 입력 113 예제 출력 11234567871 31 23 21 32 12 31 3 힌트 출처 문제를 만든 사람: baekjoon 빠진 조건을 찾은 사람: hayman42 알고리즘 분류 재귀 시간 제한 풀이 소스코드1234567891011121314151617def hanoi(n, a, b, c): if n == 1: move.append([a, c]) else: hanoi(n - 1, a, c, b) move.append([a, c]) hanoi(n - 1, b, a, c)N = int(input())move = []hanoi(N, 1, 2, 3)print(len(move))print('\\n'.join([' '.join(str(i) for i in row) for row in move]))","link":"/categories/Algorithm/Python/BAEKJOON-11729-21-03-31/"},{"title":"[백준] 11866번 요세푸스 문제0","text":"출처: [백준] 11866번 요세푸스 문제0 문제 요세푸스 문제는 다음과 같다. 1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &lt;3, 6, 2, 7, 5, 1, 4&gt;이다. N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000) 출력예제와 같이 요세푸스 순열을 출력한다. 예제 입력 117 3 예제 출력 11&lt;3, 6, 2, 7, 5, 1, 4&gt; 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 자료 구조 큐 시간 제한 풀이 소스코드12345678910111213141516import sysfrom collections import dequeN, K = map(int, input().split())people_deque = deque([i for i in range(1, N + 1)])print(&quot;&lt;&quot;, end=&quot;&quot;)while people_deque: for _ in range(K - 1): people_deque.append(people_deque[0]) people_deque.popleft() print(people_deque.popleft(), end=&quot;&quot;) if people_deque: print(',', end=&quot; &quot;)print(&quot;&gt;&quot;, end=&quot;&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-11866-21-03-23/"},{"title":"[백준] 11899번 괄호 끼워넣기","text":"출처: [백준] 11899번 괄호 끼워넣기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 32 MB 864 586 498 69.071% 문제심심한 승현이는 너무 심심한 나머지 올바른 괄호열을 가지고 놀고 있었습니다. 1(()(()))()() 그러다가 어쩌다 보니 괄호열을 부러뜨렸습니다. 1(() (( )))() () 크게 낙담한 승현이는 노력해 보았지만, 대부분이 부러져 버려 단 한 부분만 재사용할 수 있다는 것을 깨닫게 되었습니다. 1)))() 승현이는 이 괄호열을 가지고 놀려고 했으나 올바른 괄호열이 아니기 때문에 행복하지 않았습니다. 이를 보던 지학이는 승현이에게 “그러면 앞과 뒤에 적절하게 괄호를 붙이면 올바른 괄호열이 되지 않을까?”라고 했고, 승현이는 조금 생각한 뒤 그렇게 하기로 했습니다. 예를 들어, 위의 올바르지 않은 괄호열의 경우 앞에 여는 괄호 3개를 붙이면 올바른 괄호열이 됩니다. 1((()))() 그러나 괄호열을 사서 붙이는 데에는 돈이 들고 많이 붙일수록 놀기가 불편해지기 때문에, 승현이는 가능한 한 괄호열을 적게 추가하려고 합니다. 승현이가 망가뜨리고 사용 가능한 올바르지 않은 괄호열이 주어질 때, 올바른 괄호열으로 만들기 위해 앞과 뒤에 붙여야 할 괄호의 최소 개수를 구하는 프로그램을 작성하세요. 입력첫 번째 줄에 올바르지 않은 괄호열 S가 주어집니다. S의 길이는 1 이상 50 이하입니다. 출력첫 번째 줄에 S를 올바른 괄호열으로 만들기 위해 앞과 뒤에 붙여야 할 괄호의 최소 개수를 출력합니다. 불가능한 경우는 주어지지 않습니다. 예제 입력 11)))() 예제 출력 113 예제 입력 21)(() 예제 출력 212 예제 입력 31))()(( 예제 출력 314 예제 입력 41)(()(())) 예제 출력 411 힌트괄호열이란 여는 괄호 ‘(’와 닫는 괄호 ‘)’로만 구성된 문자열을 말합니다. 올바른 괄호열은 아래와 같이 정의할 수 있습니다. “()”는 올바른 괄호열입니다. A가 올바른 괄호열이라면 “(A)” 역시 올바른 괄호열입니다. A와 B가 모두 올바른 괄호열이라면 “AB” 역시 올바른 괄호열입니다. 출처 Contest &gt; GENIUSainta.com - oj.uz Contest &gt; GA6 1번 알고리즘 분류 자료 구조 문자열 스택 소스코드1234567891011121314151617181920import sysinput = sys.stdin.readlineinput_string = list(input().rstrip())left = []right = []for x in input_string: if x == '(': left.append(x) elif x == ')': if left: left.pop() else: right.append(x)print(len(left) + len(right))","link":"/categories/Algorithm/Python/BAEKJOON-11899-21-07-14/"},{"title":"[백준] 12018번 Yonsei TOTO","text":"출처: [백준] 12018번 Yonsei TOTO 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 1951 677 577 35.204% 문제연세대학교 수강신청이 얼마 전부터 바뀌어, 마일리지 제도로 바뀌었다. 이 제도는 각각의 학생들에게 마일리지를 주어 듣고 싶은 과목에 마일리지를 과목당 1~36을 분배한다. 그리고 모두 분배가 끝이 나면 과목에 대해서 마일리지를 많이 투자한 순으로 그 과목의 수강인원만큼 신청되는 방식이다. 성준이는 연세대학교 재학 중인 학생이다. 성준이는 저번 수강신청에서 실패하여 휴학을 했기 때문에 이번 수강신청만은 필사적으로 성공하려고 한다. 그래서 성준이는 학교 홈페이지를 뚫어버렸다. 그 덕분에 다른 사람들이 신청한 마일리지를 볼 수 있게 되었다. 성준이는 주어진 마일리지로 최대한 많은 과목을 신청하고 싶어 한다. (내가 마일리지를 넣고 이후에 과목을 신청하는 사람은 없다) 마일리지는 한 과목에 1에서 36까지 넣을 수 있다. 입력첫째 줄에는 과목 수 n (1 ≤ n ≤ 100)과 주어진 마일리지 m (1 ≤ m ≤ 100)이 주어진다. 각 과목마다 2줄의 입력이 주어지는데 첫째 줄에는 각 과목에 신청한 사람 수 Pi과 과목의 수강인원 Li이 주어지고 그 다음 줄에는 각 사람이 마일리지를 얼마나 넣었는지 주어진다. (1 ≤ Pi ≤100, 1 ≤ Li ≤ 100) (단 마일리지가 같다면 성준이에게 우선순위가 주어진다고 하자.) 출력첫째 줄에 주어진 마일리지로 최대로 들을 수 있는 과목 개수를 출력한다. 예제 입력 112345678910115 765 4 36 25 1 36 364 430 24 25 206 436 36 36 36 36 362 43 75 427 15 26 8 14 예제 출력 114 출처 University &gt; 연세대학교 &gt; 2016 연세대 컴퓨터과학과 프로그래밍 경진대회 A번 문제를 만든 사람: zych1751 알고리즘 분류 자료 구조 그리디 알고리즘 정렬 우선순위 큐 소스코드1234567891011121314151617181920212223242526272829303132import sysimport heapqinput = sys.stdin.readlineN, M = map(int, input().split())answer = 0sugang = []for _ in range(N): P, L = map(int, input().split()) mileages = list(map(int, input().split())) heapq.heapify(mileages) available = L - P if available &gt; 0: heapq.heappush(sugang, 1) else: for i in range(abs(available)): heapq.heappop(mileages) heapq.heappush(sugang, heapq.heappop(mileages))count = 0while sugang: sugang_mileage = heapq.heappop(sugang) if M - sugang_mileage &gt;= 0: M -= sugang_mileage count += 1 else: breakprint(count)","link":"/categories/Algorithm/Python/BAEKJOON-12018-21-05-06/"},{"title":"[백준] 1259번 팰린드롬수","text":"출처: [백준] 1259번 팰린드롬수 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 10385 6386 5764 62.659% 문제어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. ‘radar’, ‘sees’는 팰린드롬이다. 수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자. 입력입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다. 출력각 줄마다 주어진 수가 팰린드롬수면 ‘yes’, 아니면 ‘no’를 출력한다. 예제 입력 112341211231124210 예제 출력 1123yesnoyes 출처 ICPC &gt; Regionals &gt; South Pacific &gt; South Pacific Region &gt; New Zealand Programming Contest &gt; NZPC 2006 B번 문제를 번역한 사람: kks227 알고리즘 분류 구현 문자열 소스코드1234567891011121314151617181920212223import sysinput = sys.stdin.readlinedef isPalindrome(value): for i in range(len(value)): if value[i] != value[len(value) - 1 - i]: return 0 return 1while True: num = int(input()) if not num: break else: arr = list(str(num)) if isPalindrome(arr): print('yes') else: print('no')","link":"/categories/Algorithm/Python/BAEKJOON-1259-21-06-23/"},{"title":"[백준] 12034번 김인천씨의 식료품가게 (Large)","text":"출처: [백준] 12034번 김인천씨의 식료품가게 (Large) 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 5 초 512 MB 253 128 118 50.862% 문제전설적인 인천 식료품가게의 주인인 김인천 씨는 대대적인 할인행사를 계획하고 있습니다. 계산을 단순하게하기 위해 그는 25% 할인된 가격으로 상점의 모든 품목을 판매하기로 결정했습니다. 즉, 각 품목의 판매 가격은 정상 가격의 정확히 75 %입니다. 우연하게도 인천 식료품가게에서 판매하는 모든 물건의 정상가는 4의 배수인 정수이고, 할인된 가격 역시 편리하게도 모두 정수입니다. 김인천씨는 이 할인행사를 준비하기위해서 먼저 모든 판매물품의 할인된 판매가격을 프린터로 출력을 실행했고, 또한 할인행사 종료후 다시 쓸 모든 품목에 정상가격표 역시 출력을 실행하였습니다. 손님이 찾아와 잠깐 자리를 비웠던 김인천씨가 다시 가격표의 출력을 확인하기 위해서 프린터로 돌아와보니, 공교롭게 프린터는 모든 물품의 할인가격과 정상가격을 따로 구분하지 않고 오름차순으로 정렬한 뒤 순서대로 출력하여 하나의 출력물 더미를 만들었습니다. 각 품목의 할인가격표와 정상가격표 모두가 출력물 더미의 어딘가에 있습니다. 그러나 두 유형(할인가격, 정상가격)의 가격표는 비슷하게 보이고, 모든 품목의 가격을 기억하지 못하기 때문에 김인천씨는 어느 가격표가 할인가격표인지 확신할 수 없습니다. 이 상황에서 김인천씨는 무엇이 할인가격표인지 구분해낼 수 있을까요? 예를 들어, 정상가격이 20, 80, 100 인 경우 할인가격은 15, 60, 75이며 프린터의 인쇄출력더미는 오름차순으로 정렬된 15, 20, 60, 75, 80, 100 가격표들로 구성됩니다. 입력입력의 첫 번째 라인(줄)은 테스트 사례의 케이스의 수 T를 나타냅니다. 이후의 라인은 T개의 테스트 케이스가 이어집니다. 각 테스트 케이스는 두 줄로 구성됩니다. 첫 번째 줄에는 INU 식료품가게에 존재하는 상품수인 단일 정수 N이 포함됩니다. 두 번째 줄에는 프린터에서 가격의 오름차순으로 인쇄한 2N개의 정수 P1, P2, …, P2N이 주어집니다. 입력값의 제한은 아래와 같습니다 1 ≤ T ≤ 100. 모든 i에 대해서 1 ≤ Pi ≤ 109. 모든 i에 대해서 Pi ≤ Pi+1. (가격은 오름차순으로 존재) 정답은 단 하나만 존재하는것이 보장되어 있음. 1 ≤ N ≤ 100 출력개별 테스트 케이스에 대해서 출력라인은 “Case #x: y” 형식(큰 따옴표는 제외)으로 출력하며, x는 1부터 시작하는 테스트 케이스의 번호 (인덱스)이며, y는 할인가격에 해당하는 오름차순으로 정렬된 N개의 정수들이다. 예제 입력 1123452315 20 60 75 80 10049 9 12 12 12 15 16 20 예제 출력 112Case #1: 15 60 75Case #2: 9 9 12 15 힌트예제의 첫 번째 테스트 케이스인 Case #1은 문제에서 예로들어서 설명한 세 개의 물품에 대한 정상가격과 할인가격 6개입니다. 또한 예제의 Case #2에서는 여러 품목이 동일한 가격을 가질 수 있고, 어떤 품목의 할인가격이 다른 품목 정상가격과 같을 수도 있습니다. 출처 Contest &gt; Google Code Jam &gt; Code Jam to I/O 2016 for Women &gt; Code Jam A2번 알고리즘 분류 구현 자료 구조 큐 소스코드123456789101112131415161718192021import sysinput = sys.stdin.readlineT = int(input())for t in range(T): N = int(input()) price_list = sorted(map(int, input().split()), reverse=True) dc_list = [] while price_list: price = price_list.pop() if price * 100 // 75 in price_list: dc_list.append(price) price_list.remove(price * 100 // 75) print(&quot;Case #{0}: &quot;.format(t + 1), end=&quot;&quot;) print(*dc_list)","link":"/categories/Algorithm/Python/BAEKJOON-12034-21-07-21/"},{"title":"[백준] 1269번 대칭 차집합","text":"출처: [백준] 1269번 대칭 차집합 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 256 MB 4426 2319 1763 53.295% 문제자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 이때, 두 집합의 대칭 차집합의 원소의 개수를 출력하는 프로그램을 작성하시오. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다. 예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때, A-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로, 대칭 차집합의 원소의 개수는 1 + 3 = 4개이다. 입력첫째 줄에 집합 A의 원소의 개수와 집합 B의 원소의 개수가 빈 칸을 사이에 두고 주어진다. 둘째 줄에는 집합 A의 모든 원소가, 셋째 줄에는 집합 B의 모든 원소가 빈 칸을 사이에 두고 각각 주어진다. 각 집합의 원소의 개수는 200,000을 넘지 않으며, 모든 원소의 값은 100,000,000을 넘지 않는다. 출력첫째 줄에 대칭 차집합의 원소의 개수를 출력한다. 예제 입력 11233 51 2 42 3 4 5 6 예제 출력 114 출처 문제를 만든 사람: author5 알고리즘 분류 자료 구조 트리를 사용한 집합과 맵 해시를 사용한 집합과 맵 소스코드1234567891011121314import sysinput = sys.stdin.readlineA, B = map(int, input().split())set_A = set(map(int, input().split()))set_B = set(map(int, input().split()))AB = set_A - set_BBA = set_B - set_Aprint(len(AB) + len(BA))","link":"/categories/Algorithm/Python/BAEKJOON-1269-21-07-01/"},{"title":"[백준] 12738번 가장 긴 증가하는 부분 수열 3","text":"출처: [백준] 12738번 가장 긴 증가하는 부분 수열 3 문제수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오. 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다. 입력첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000) 출력첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다. 예제 입력 112610 20 10 30 20 50 예제 출력 114 힌트 출처 문제를 만든 사람: baekjoon 데이터를 추가한 사람: harinboy/www.acmicpc.net/user/citizen) 비슷한 문제 11053번. 가장 긴 증가하는 부분 수열 11054번. 가장 긴 바이토닉 부분 수열 11055번. 가장 큰 증가 부분 수열 11722번. 가장 긴 감소하는 부분 수열 12015번. 가장 긴 증가하는 부분 수열 2 14002번. 가장 긴 증가하는 부분 수열 4 14003번. 가장 긴 증가하는 부분 수열 5 알고리즘 분류 이분 탐색 가장 긴 증가하는 부분 수열: O(n log n) 풀이 소스코드123456789101112131415161718192021222324import sysfrom bisect import bisect_leftinput = sys.stdin.readlineN = int(input())num_list = list(map(int, input().split()))dp = []def binary_search(arr, x): k = bisect_left(arr, x) if k &gt;= len(arr): arr.append(x) else: arr[k] = x return arrfor num in num_list: dp = binary_search(dp, num)print(len(dp))","link":"/categories/Algorithm/Python/BAEKJOON-12738-21-03-20/"},{"title":"[백준] 12605번 단어순서 뒤집기","text":"출처: [백준] 12605번 단어순서 뒤집기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 5 초 512 MB 1349 822 710 61.525% 문제스페이스로 띄어쓰기 된 단어들의 리스트가 주어질때, 단어들을 반대 순서로 뒤집어라. 각 라인은 w개의 영단어로 이루어져 있으며, 총 L개의 알파벳을 가진다. 각 행은 알파벳과 스페이스로만 이루어져 있다. 단어 사이에는 하나의 스페이스만 들어간다. 입력첫 행은 N이며, 전체 케이스의 개수이다. N개의 케이스들이 이어지는데, 각 케이스는 스페이스로 띄어진 단어들이다. 스페이스는 라인의 처음과 끝에는 나타나지 않는다. N과 L은 다음 범위를 가진다. N = 5 1 ≤ L ≤ 25 출력각 케이스에 대해서, 케이스 번호가 x일때 “Case #x: “ 를 출력한 후 그 후에 이어서 단어들을 반대 순서로 출력한다. 예제 입력 112343this is a testfoobarall your base 예제 출력 1123Case #1: test a is thisCase #2: foobarCase #3: base your all 출처 Contest &gt; Google Code Jam &gt; Google Code Jam Africa 2010 &gt; Qualification Round B1번 알고리즘 분류 구현 자료 구조 문자열 스택 소스코드12345678910111213import sysinput = sys.stdin.readlineN = int(input())for i in range(N): sentence = list(input().rstrip().split()) result = [] while sentence: result.append(sentence.pop()) print('Case #{0}: {1}'.format(i + 1, ' '.join(result)))","link":"/categories/Algorithm/Python/BAEKJOON-12605-21-07-09/"},{"title":"[백준] 12789번 도키도키 간식드리미","text":"출처: [백준] 12789번 도키도키 간식드리미 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 3083 1189 952 38.715% 문제인하대학교 학생회에서는 중간, 기말고사 때마다 시험 공부에 지친 학우들을 위해 간식을 나눠주는 간식 드리미 행사를 실시한다. 승환이는 시험 기간이 될 때마다 간식을 받을 생각에 두근두근 설레서 시험 공부에 집중을 못 한다. 이번 중간고사에서도 역시 승환이는 설레는 가슴을 안고 간식을 받기 위해 미리 공지된 장소에 시간 맞춰 도착했다. 그런데 이게 무슨 날벼락인가! 그 곳에는 이미 모든 학생들이 모여있었고, 승환이는 마지막 번호표를 받게 되었다. 설상가상으로 몇몇 양심에 털이 난 학생들이 새치기를 거듭한 끝에 대기열의 순서마저 엉망이 되고 말았다. 간식을 나눠주고 있던 인규는 학우들의 터져 나오는 불만에 번호표 순서로만 간식을 줄 수 있다고 말했다. 그제야 학생들이 순서대로 줄을 서려고 했지만 공간이 너무 협소해서 마음대로 이동할 수 없었다. 다행히도 대기열의 왼쪽에는 1열로 설 수 있는 공간이 존재하여 이 공간을 잘 이용하면 모두가 순서대로 간식을 받을 수 있을지도 모른다. 자칫 간식을 못 받게 될지도 모른다는 위기감을 느낀 승환이는 자신의 컴퓨터 알고리즘적 지식을 활용해 과연 모든 사람들이 순서대로 간식을 받을 수 있는지 확인하는 프로그램을 만들기로 했다. 만약 불가능 하다면 승환이는 이번 중간고사를 망치게 될 것 이고 가능하다면 힘을 얻어 중간고사를 잘 볼 수 있을지도 모른다. 사람들은 현재 1열로 줄을 서있고, 맨 앞의 사람만 이동이 가능하다. 인규는 번호표 순서대로만 통과할 수 있는 라인을 만들어 두었다. 이 라인과 대기열의 맨 앞 사람 사이에는 한 사람씩 1열이 들어갈 수 있는 공간이 있다. 현재 대기열의 사람들은 이 공간으로 올 수 있지만 반대는 불가능하다. 승환이를 도와 프로그램을 완성하라. 현재 간식 배부 공간을 그림으로 나타내면 다음과 같다. 위 예제는 다음 그림과 같이 움직였을 때 모두가 순서대로 간식을 받을 수 있다.. 입력입력의 첫째 줄에는 현재 승환이의 앞에 서 있는 학생들의 수 N(1 ≤ N ≤ 1,000,자연수)이 주어진다. 다음 줄에는 승환이 앞에 서있는 모든 학생들의 번호표(1,2,…,N) 순서가 앞에서부터 뒤 순서로 주어진다. 출력승환이가 무사히 간식을 받을 수 있으면 “Nice”(따옴표는 제외)를 출력하고 그렇지 않다면 “Sad”(따옴표는 제외)를 출력한다. 예제 입력 11255 4 1 3 2 예제 출력 11Nice 출처 University &gt; 인하대학교 &gt; 2016 IUPC 인하대학교 프로그래밍 경진대회 L번 문제의 오타를 찾은 사람: 10_J 잘못된 데이터를 찾은 사람: tncks0121 문제를 만든 사람: tndnjs2139 알고리즘 분류 자료 구조 스택 소스코드123456789101112131415161718192021222324252627import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())init_line = deque(map(int, input().split()))wait_line = deque()pos = 1while init_line: if init_line and init_line[0] == pos: init_line.popleft() pos += 1 else: wait_line.append(init_line.popleft()) while wait_line and wait_line[-1] == pos: wait_line.pop() pos += 1if wait_line: print('Sad')else: print(&quot;Nice&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-12789-21-07-13/"},{"title":"[백준] 1292번 쉽게 푸는 문제","text":"출처: [백준] 1292번 쉽게 푸는 문제 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 10628 5891 5197 57.559% 문제동호는 내년에 초등학교를 입학한다. 그래서 동호 어머니는 수학 선행 학습을 위해 쉽게 푸는 문제를 동호에게 주었다. 이 문제는 다음과 같다. 1을 한 번, 2를 두 번, 3을 세 번, 이런 식으로 1 2 2 3 3 3 4 4 4 4 5 .. 이러한 수열을 만들고 어느 일정한 구간을 주면 그 구간의 합을 구하는 것이다. 하지만 동호는 현재 더 어려운 문제를 푸느라 바쁘기에 우리가 동호를 도와주자. 입력첫째 줄에 구간의 시작과 끝을 나타내는 정수 A, B(1 ≤ A ≤ B ≤ 1,000)가 주어진다. 즉, 수열에서 A번째 숫자부터 B번째 숫자까지 합을 구하면 된다. 출력첫 줄에 구간에 속하는 숫자의 합을 출력한다. 예제 입력 113 7 예제 출력 1115 출처 문제를 만든 사람: author6 알고리즘 분류 수학 구현 소스코드123456789101112131415161718import sysinput = sys.stdin.readlineA, B = map(int, input().split())cur_value = 1position = 1result = 0for i in range(A, B + 1): while position &lt; i: cur_value += 1 position += cur_value result += cur_valueprint(result)","link":"/categories/Algorithm/Python/BAEKJOON-1292-21-06-17/"},{"title":"[백준] 13414번 수강신청","text":"출처: [백준] 13414번 수강신청 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 6098 1293 852 20.363% 문제국민대학교에서는 매 학기 시작 전 종합정보시스템에서 수강신청을 한다. 매 수강신청마다 아주 많은 학생들이 몰려 서버에 많은 부하가 가기 때문에, 국민대학교에서는 수강신청 부하 관리 시스템을 도입하기로 결정하였다. 새로운 관리 시스템은 다음과 같은 방식으로 동작한다. 수강신청 버튼이 활성화 된 후, 수강신청 버튼을 조금이라도 빨리 누른 학생이 대기목록에 먼저 들어간다. 이미 대기열에 들어가 있는 상태에서 다시 수강신청 버튼을 누를 경우 대기목록의 맨 뒤로 밀려난다. 잠시 후 수강신청 버튼이 비활성화 되면, 대기목록에서 가장 앞에 있는 학생부터 자동으로 수강신청이 완료되며, 수강 가능 인원이 꽉 찰 경우 나머지 대기목록은 무시하고 수강신청을 종료한다. 위의 표는 최대 수강 가능 인원이 3명인 알고리즘 수업에 대해 6명의 학생이 수강신청을 진행한 모습이다. 버튼이 비활성화 된 후, 먼저 규칙 1을 적용하여 클릭을 2번 이상 한 학생의 중복된 대기목록을 삭제한다. 중복된 목록을 제거한 후, 맨 앞에서부터 최대 수강 가능 인원인 3명을 선정한다. 표의 맨 오른쪽에는 그 최종결과를 나타낸 모습이다. 이와 같은 방법을 이용하여 최종적으로 수강신청에 성공한 인원을 출력하는 프로그램을 작성하시오. 입력입력 데이터는 표준 입력을 사용한다. 입력은 1개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 과목의 수강 가능 인원 K(1 ≤ K ≤ 100,000)와 학생들이 버튼을 클릭한 순서를 기록한 대기목록의 길이 L(1 ≤ L ≤ 500,000)이 주어진다. 두 번째 줄부터 L개의 줄에는 수강신청을 버튼을 클릭한 학생의 학번이 클릭 순서대로 주어진다. 학번은 8자리의 숫자로 이루어져 있다. 출력출력은 표준 출력을 사용한다. 입력받은 데이터에 대해, 수강신청 관리 시스템의 규칙을 적용한 후 수강신청에 성공한 인원의 학번을 한 줄에 1개씩 출력한다. 예제 입력 11234567893 82010332420133221201332212009377820140101012345672009377820103325 예제 출력 1123201033242013322120140101 출처 University &gt; 국민대학교 &gt; 2016 국민대학교 교내 경시대회 B번 문제의 오타를 찾은 사람: jh05013 데이터를 추가한 사람: kimsy96 문제를 만든 사람: kookmin20103324 알고리즘 분류 자료 구조 해시를 사용한 집합과 맵 소스코드12345678910111213141516171819import sysinput = sys.stdin.readlineK, L = map(int, input().split())queue_list = {}for i in range(L): studentId = input().rstrip() queue_list[studentId] = icnt = 0for x in sorted(queue_list.items(), key=lambda x: x[1]): cnt += 1 if cnt &gt; K: break print(x[0])","link":"/categories/Algorithm/Python/BAEKJOON-13414-21-07-01/"},{"title":"[백준] 1302번 베스트셀러","text":"출처: [백준] 1302번 베스트셀러 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 8128 3653 2999 45.433% 문제김형택은 탑문고의 직원이다. 김형택은 계산대에서 계산을 하는 직원이다. 김형택은 그날 근무가 끝난 후에, 오늘 판매한 책의 제목을 보면서 가장 많이 팔린 책의 제목을 칠판에 써놓는 일도 같이 하고 있다. 오늘 하루 동안 팔린 책의 제목이 입력으로 들어왔을 때, 가장 많이 팔린 책의 제목을 출력하는 프로그램을 작성하시오. 입력첫째 줄에 오늘 하루 동안 팔린 책의 개수 N이 주어진다. 이 값은 1,000보다 작거나 같은 자연수이다. 둘째부터 N개의 줄에 책의 제목이 입력으로 들어온다. 책의 제목의 길이는 50보다 작거나 같고, 알파벳 소문자로만 이루어져 있다. 출력첫째 줄에 가장 많이 팔린 책의 제목을 출력한다. 만약 가장 많이 팔린 책이 여러 개일 경우에는 사전 순으로 가장 앞서는 제목을 출력한다. 예제 입력 11234565toptoptoptopkimtop 예제 출력 11top 출처 문제를 번역한 사람: baekjoon 데이터를 추가한 사람: sukwoo0711 알고리즘 분류 자료 구조 문자열 정렬 해시를 사용한 집합과 맵소스코드 123456789101112131415161718192021222324import sysinput = sys.stdin.readlineN = int(input())sell_items = {}for _ in range(N): book_name = input().rstrip() if book_name in sell_items: sell_items[book_name] += 1 else: sell_items[book_name] = 1max_sell = max(sell_items.values())best_seller = []for book, count in sell_items.items(): if count == max_sell: best_seller.append(book)print(sorted(best_seller)[0])","link":"/categories/Algorithm/Python/BAEKJOON-1302-21-07-03/"},{"title":"[백준] 1406번 에디터","text":"출처: [백준] 1406번 에디터 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 0.3 초 (하단 참고) 512 MB 48952 13490 8865 26.934% 문제한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다. 이 편집기에는 ‘커서’라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다. 이 편집기가 지원하는 명령어는 다음과 같다. L 커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨) D 커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨) B 커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨) 삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 실제로 커서의 오른쪽에 있던 문자는 그대로임 P $ $라는 문자를 커서 왼쪽에 추가함 초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다. 입력첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M ≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다. 출력첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다. 예제 입력 112345abcd3P xLP y 예제 출력 11abcdyx 예제 입력 21234567891011abc9LLLLLP xLBP y 예제 출력 21yxabc 예제 입력 312345678910111213dmih11BBP xLBBBP yDDP z 예제 출력 31yxz 출처 Olympiad &gt; Croatian Highschool Competitions in Informatics &gt; 2004 &gt; National Competition #1 - Juniors 2번 문제를 번역한 사람: author5 데이터를 추가한 사람: djm03178 메모리 제한을 수정한 사람: djm03178 시간 제한을 수정한 사람: jh05013 어색한 표현을 찾은 사람: naong606 문제의 오타를 찾은 사람: wkd48632 알고리즘 분류 자료 구조 스택 연결 리스트 소스코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import sysinput = sys.stdin.readlineinit_string = list(input().rstrip())N = int(input())string2 = []for _ in range(N): comm = list(input().split()) if comm[0] == 'P': init_string.append(comm[1]) elif comm[0] == 'L': if init_string: string2.append(init_string.pop()) elif comm[0] == 'D': if string2: init_string.append(string2.pop()) elif comm[0] == 'B': if init_string: init_string.pop() print(''.join(init_string + list(reversed(string2))))----------시간초과1---------------------import sysinput = sys.stdin.readlineinit_string = input().rstrip()N = int(input())cursor = len(init_string)for _ in range(N): comm = list(input().split()) if comm[0] == 'P': init_string = init_string[0:cursor] + comm[1] + init_string[cursor:] cursor += 1 elif comm[0] == 'L': if not cursor == 0: cursor -= 1 else: continue elif comm[0] == 'D': if not cursor == len(init_string): cursor += 1 else: continue elif comm[0] == 'B': if cursor == 0: continue else: init_string = init_string[0:cursor - 1] + init_string[cursor:] cursor -= 1print(''.join(init_string))-----------시간초과2---------------import sysinput = sys.stdin.readlineinit_string = list(input().rstrip())N = int(input())cursor = len(init_string)for _ in range(N): comm = list(input().split()) if comm[0] == 'P': init_string.insert(cursor, comm[1]) cursor += 1 elif comm[0] == 'L': cursor -= 1 if cursor &lt; 0: cursor = 0 elif comm[0] == 'D': cursor += 1 elif comm[0] == 'B': if cursor == 0: continue else: cursor -= 1 init_string.pop(cursor)print(''.join(init_string))","link":"/categories/Algorithm/Python/BAEKJOON-1406-21-07-07/"},{"title":"[백준] 13417번 카드 문자열","text":"출처: [백준] 13417번 카드 문자열 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 1290 798 696 65.108% 문제N장의 카드가 일렬로 놓여있다. 각 카드에는 알파벳이 하나씩 적혀있다. 태욱이는 가장 왼쪽에 있는 카드부터 차례대로 한 장씩 가져올 수 있다. 가장 처음에 가져온 카드는 자신의 앞에 놓는다. 그다음부터는 가져온 카드를 자신의 앞에 놓인 카드들의 가장 왼쪽, 또는 가장 오른쪽에 놓는다. 태욱이는 모든 카드를 다 가져온 후에 자신의 앞에 놓인 카드를 순서대로 이어 붙여 카드 문자열을 만들려고 한다. 예를 들어 3장의 카드가 [M, K, U] 순으로 놓여있다고 하자. 태욱이는 먼저 가장 왼쪽에 있는 “M”이 적힌 카드를 가져와서 자신의 앞에 놓는다. 다음으로 남은 카드 중 가장 왼쪽에 있는 “K”가 적힌 카드를 가져와서 가장 왼쪽에 두고, 이어서 “U”가 적힌 카드를 가져와서 다시 가장 왼쪽에 두면 “UKM”이라는 문자열을 만들 수 있다. 만약 “K”가 적힌 카드를 가져와서 가장 왼쪽에 두고, 이어서 “U”가 적힌 카드를 가져와서 가장 오른쪽에 두면 “KMU”라는 문자열을 만들 수 있다. 이때, 태욱이가 만들 수 있는 문자열 중 사전 순으로 가장 빠른 문자열은 “KMU”이다. N장의 카드에 적혀있는 알파벳의 처음 순서가 주어질 때, 태욱이가 만들 수 있는 카드 문자열 중 사전 순으로 가장 빠른 문자열을 출력하는 프로그램을 작성하시오. 입력입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫째 줄에 테스트 케이스의 개수를 나타내는 자연수 T가 주어진다. 각각의 테스트 케이스의 첫째 줄에 처음에 놓여있는 카드의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 두 번째 줄에는 N장의 카드에 적힌 알파벳의 초기 순서가 주어진다. 가장 왼쪽에 있는 카드에 적혀있는 알파벳부터 순서대로 N개가 공백으로 구분되어 주어진다. 모든 카드에는 한 개씩의 알파벳이 적혀있으며, 모두 대문자이다. 출력출력은 표준 출력을 사용한다. 입력받은 데이터에 대해, 한 줄에 1개씩 태욱이가 만들 수 있는 문자열 중에서 사전 순으로 가장 빠른 문자열을 출력한다. 예제 입력 1123456733M K U5A S D F G7B A C A B A C 예제 출력 1123KMUASDFGAAABCBC 출처 University &gt; 국민대학교 &gt; 2016 국민대학교 교내 경시대회 E번 문제를 만든 사람: game2k 알고리즘 분류 자료 구조 문자열 그리디 알고리즘 덱 소스코드1234567891011121314151617181920import sysfrom collections import dequeinput = sys.stdin.readlineT = int(input())for _ in range(T): N = int(input()) card_list = deque(input().rstrip().split()) new_list = deque(card_list.popleft()) while card_list: temp = card_list.popleft() if temp &gt; new_list[0]: new_list.append(temp) else: new_list.appendleft(temp) print(''.join(new_list))","link":"/categories/Algorithm/Python/BAEKJOON-13417-21-07-26/"},{"title":"[백준] 1436번 영화감독 숌","text":"출처: [백준] 1436번 영화감독 숌 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 31210 13703 11247 44.456% 문제666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다. 하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다. 종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, …. 과 같다. 따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다. 숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다. 입력첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다. 출력첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다. 예제 입력 112 예제 출력 111666 힌트 출처 문제를 번역한 사람: baekjoon 어색한 표현을 찾은 사람: mwy3055 알고리즘 분류 브루트포스 알고리즘 시간 제한 풀이 666,1666,2666,3666,4666,5666,6660,6661……. 소스코드12345678910111213141516import sysinput = sys.stdin.readlineN = int(input())title = 666cnt = 0while True: if '666' in str(title): cnt += 1 if cnt == N: print(title) break title += 1","link":"/categories/Algorithm/Python/BAEKJOON-1436-21-04-14/"},{"title":"[백준] 1449번 수리공 항승","text":"출처: [백준] 1449번 수리공 항승 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 9710 3852 3261 39.619% 문제항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다. 파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다. 항승이는 길이가 L인 테이프를 무한개 가지고 있다. 항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다. 물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다. 입력첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다. 출력첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다. 예제 입력 1124 21 2 100 101 예제 출력 112 출처 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: rainshot 잘못된 데이터를 찾은 사람: tncks0121 알고리즘 분류 그리디 알고리즘 정렬 소스코드123456789101112131415161718import sysinput = sys.stdin.readlineN, L = map(int, input().split())leak_list = sorted(list(map(int, input().split())))distance = leak_list[0] + L - 0.5count = 1for i in range(N): if distance &gt;= leak_list[i]: continue else: count += 1 distance = leak_list[i] + L - 0.5print(count)","link":"/categories/Algorithm/Python/BAEKJOON-1449-21-08-15/"},{"title":"[백준] 14713번 앵무새","text":"출처: [백준] 14713번 앵무새 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 512 MB 807 173 141 26.454% 문제자가용 비행기를 타고 세계 일주를 하던 pps789와 cseteram은 어느 날 엔진 고장으로 인해 이름 모를 섬에 불시착하게 된다. 그들은 이 섬을 탐험하는 도중 아주 신기한 사실을 알게 되었는데, 바로 이 섬에 사는 앵무새들은 놀라울 정도로 인간의 말을 흉내 내는 데 뛰어나다는 것이다. 그들은 서로 떨어져 섬을 탐험하기로 하였으며, 필요하다면 앵무새를 이용해 서로에게 연락하기로 약속하였다. 1개월 후, pps789는 섬의 비밀을 밝힐 결정적인 증거를 찾게 된다. 그는 이 세기의 대발견을 cseteram에게 공유하고자 하였으나, 그의 발견은 방대하여 앵무새 한 마리가 기억하기에는 너무 많은 양이었다. 그렇기 에 pps789는 앵무새 한 마리 대신 앵무새 N마리를 이용하여 자신의 발견을 기록하였으며, 이 앵무새들을 cseteram을 향해 날렸다. 한편 섬의 반대편에서 탐험을 계속하던 cseteram은 앵무새 N마리가 자신에게 날아와 각자 할 말을 하는 것을 보고 당황하였다. pps789가 긴 글을 전달하고 싶었던 것은 알아차렸지만, 각각의 앵무새들이 말하는 것을 차례대로 기록하다 보니 원문이 무엇인지 알 수 없을 정도로 단어의 순서가 엉켜버린 것이다. 대신 그는 관찰을 통해 몇 가지 규칙을 발견할 수 있었다. 한 앵무새는 한 문장을 기억하고 있다. 문장은 여러 단어로 이루어져 있는데, 앵무새는 이 단어들을 순서대로 말한다. 한 앵무새가 단어를 말하고 그다음 단어를 말하기 전에는 약간의 간격이 있는데, 이때 다른 앵무새가 말을 가로채고 자신의 문장을 말할 수 있다. 한 앵무새가 단어를 말하는 도중에는, 다른 앵무새가 말을 가로채지 않는다. 어떤 단어도 앵무새가 말하는 모든 문장을 통틀어 2번 이상 등장하지 않는다. 앵무새는 자신이 기억하고 있는 문장을 끝까지 말한 다음 pps789에게 돌아가며, cseteram은 모든 앵무새가 돌아갈 때 까지 단어를 받아적는다. pps789가 각각의 앵무새들에게 전달한 문장 Si와, cseteram이 받아 적은 문장 L이 주어진다. 이때 문장 L이 위 규칙들을 이용하여 나올 수 있는 문장인지 판별하시오. 입력첫 번째 줄에 앵무새의 수 N (1 ≤ N ≤ 100) 이 주어진다. 두 번째 줄부터 N개의 줄에 걸쳐 각 앵무새가 말한 문장 Si (1 ≤ i ≤ N) 가 주어지는데, 각 문장을 이루는 단어는 스페이스 한 칸을 구분으로 하여 주어진다. 문장 Si를 이루는 단어의 수는 1개 이상 100개 이하이며, 각 단어는 1개 이상 32개 이하의 영문 소문자로 구성되어있다. N + 2 번째 줄에는 cseteram이 받아 적은 문장 L이 주어진다. 문장 L을 이루는 단어의 수는 1개 이상 10000개 이하이며, 각 단어는 1개 이상 32개 이하의 영문 소문자로 구성된다. 출력문장 L이 가능한 문장이라면 Possible을, 불가능한 문장이라면 Impossible을 출력한다. 예제 입력 1123453i want to see younext weekgood lucki want next good luck week to see you 예제 출력 11Possible 예제 입력 212342i foundan interesting cavei found an cave interesting 예제 출력 21Impossible 예제 입력 312342pleasebe carefulpen pineapple apple pen 예제 출력 31Impossible 출처 University &gt; 서울대학교 &gt; 2017 서울대학교 프로그래밍 경시대회 - Division 2 F번 문제를 만든 사람: cseteram 알고리즘 분류 구현 자료 구조 문자열 스택 큐 소스코드1234567891011121314151617181920212223242526import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())parrot = [deque(input().rstrip().split()) for _ in range(N)]L = input().rstrip().split()Removed = []for word in L: for i in range(N): if parrot[i] and word == parrot[i][0]: parrot[i].popleft() Removed.append(word) breakfor i in range(N): if parrot[i]: print(&quot;Impossible&quot;) exit()if L != Removed: print(&quot;Impossible&quot;)else: print(&quot;Possible&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-14713-21-07-19/"},{"title":"[백준] 14659번 한조서열정리하고옴ㅋㅋ","text":"출처: [백준] 14659번 한조서열정리하고옴ㅋㅋ 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 256 MB 4488 1959 1548 43.180% 문제“반갑다. 내 이름은 반고흐#31555! 조선 최고의 활잡이지. 오늘도 난 금강산 위에서 적들을 노리고 있지. 내 앞에 있는 적들이라면 누구도 놓치지 않아! 좋아, 이제 곧 월식이 시작되는군. 월식이 시작되면 용이 적들을 집어삼킬 것이다. 잘 봐두어라! 마장동 활잡이 반고흐#31555님의 실력을-!” 반고흐#31555는 자기 뒤쪽 봉우리에 덩기#3958이 있음을 전혀 모르고 있었다. 덩기#3958도 반고흐#31555와 마찬가지로 월식이 시작되면 용을 불러내어 눈앞에 있는 다른 활잡이들을 모두 처치할 생각이다. 사실, 반고흐#31555와 덩기#3958 뿐만 아니라 금강 산맥의 N개 봉우리에 있는 모든 활잡이들이 같은 생각을 가지고 있다. 반고흐#31555가 있는 금강 산맥에는 총 N개의 봉우리가 있고, 모든 봉우리마다 한 명의 활잡이가 서서 월식이 시작되기만을 기다리고 있다. 다만, 애석하게도, 천계에 맥도날드가 생겨 용들이 살이 찐 탓에 용들은 자신보다 낮은 봉우리에 서있는 적들만 처치할 수 있게 되었다. 또한 용들은 처음 출발한 봉우리보다 높은 봉우리를 만나면 그대로 공격을 포기하고 금강산자락에 드러누워 낮잠을 청한다고 한다. 봉우리의 높이는 모두 다르고 모든 용들은 오른쪽으로만 나아가며, 중간에 방향을 틀거나, 봉우리가 무너지거나 솟아나는 경우는 없다. “달에 마구니가 끼었구나.” 드디어 월식이 시작됐다! 과연 이들 활잡이 중 최고의 활잡이는 누구일까? 최고의 활잡이가 최대 몇 명의 적을 처치할 수 있는지 알아보자. 입력첫째 줄에 봉우리의 수 겸 활잡이의 수 N이 주어진다. (1 ≤ N ≤ 30,000) 둘째 줄에 N개 봉우리의 높이가 왼쪽 봉우리부터 순서대로 주어진다. (1 ≤ 높이 ≤ 100,000) 각각 봉우리의 높이는 중복 없이 유일하다. 출력최고의 활잡이가 처치할 수 있는 적의 최대 숫자를 출력한다. 예제 입력 11276 4 10 2 5 7 11 예제 출력 113 힌트높이 10 봉우리에 있는 활잡이가 높이 2, 5, 7 봉우리에 있는 활잡이들을 처치할 수 있다. 출처 High School &gt; 선린인터넷고등학교 &gt; 제1회 천하제일 코딩대회 본선 J번 데이터를 추가한 사람: YunGoon 알고리즘 분류 그리디 알고리즘 소스코드 (최초)12345678910111213141516import sysinput = sys.stdin.readlineN = int(input())archer = list(map(int, input().split()))scores = [0] * Nfor i in range(N): for j in range(i + 1, N): if archer[i] &lt; archer[j]: break else: scores[i] += 1print(max(scores)) 소스코드 (수정)1234567891011121314151617181920import sysinput = sys.stdin.readlineN = int(input())heights = list(map(int, input().split()))maxHeight = 0score = 0result = 0for height in heights: if height &gt; maxHeight: maxHeight = height score = 0 else: score += 1 result = max(result, score)print(result)","link":"/categories/Algorithm/Python/BAEKJOON-14659-21-08-11/"},{"title":"[백준] 1476번 날짜 계산","text":"출처: [백준] 1476번 날짜 계산 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 4 MB 19918 13053 10539 67.295% 문제준규가 사는 나라는 우리가 사용하는 연도와 다른 방식을 이용한다. 준규가 사는 나라에서는 수 3개를 이용해서 연도를 나타낸다. 각각의 수는 지구, 태양, 그리고 달을 나타낸다. 지구를 나타내는 수를 E, 태양을 나타내는 수를 S, 달을 나타내는 수를 M이라고 했을 때, 이 세 수는 서로 다른 범위를 가진다. (1 ≤ E ≤ 15, 1 ≤ S ≤ 28, 1 ≤ M ≤ 19) 우리가 알고있는 1년은 준규가 살고있는 나라에서는 1 1 1로 나타낼 수 있다. 1년이 지날 때마다, 세 수는 모두 1씩 증가한다. 만약, 어떤 수가 범위를 넘어가는 경우에는 1이 된다. 예를 들어, 15년은 15 15 15로 나타낼 수 있다. 하지만, 1년이 지나서 16년이 되면 16 16 16이 아니라 1 16 16이 된다. 이유는 1 ≤ E ≤ 15 라서 범위를 넘어가기 때문이다. E, S, M이 주어졌고, 1년이 준규가 사는 나라에서 1 1 1일때, 준규가 사는 나라에서 E S M이 우리가 알고 있는 연도로 몇 년인지 구하는 프로그램을 작성하시오. 입력첫째 줄에 세 수 E, S, M이 주어진다. 문제에 나와있는 범위를 지키는 입력만 주어진다. 출력첫째 줄에 E S M으로 표시되는 가장 빠른 연도를 출력한다. 1 1 1은 항상 1이기 때문에, 정답이 음수가 나오는 경우는 없다. 예제 입력 111 16 16 예제 출력 1116 예제 입력 211 1 1 예제 출력 211 예제 입력 311 2 3 예제 출력 315266 예제 입력 4115 28 19 예제 출력 417980 힌트 출처 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: imgosari, yehyuns://www.acmicpc.net/user/surung9898) 알고리즘 분류 수학 구현 정수론 중국인의 나머지 정리 시간 제한 풀이 소스코드1234567891011121314import sysinput = sys.stdin.readlineE, S, M = map(int, input().split())year = 1while True: if (year - E) % 15 == 0 and (year - S) % 28 == 0 and (year - M) % 19 == 0: print(year) break year += 1","link":"/categories/Algorithm/Python/BAEKJOON-1476-21-04-19/"},{"title":"[백준] 1543번 문서 검색","text":"출처: [백준] 1543번 문서 검색 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 10226 3896 3092 37.671% 문제세준이는 영어로만 이루어진 어떤 문서를 검색하는 함수를 만들려고 한다. 이 함수는 어떤 단어가 총 몇 번 등장하는지 세려고 한다. 그러나, 세준이의 함수는 중복되어 세는 것은 빼고 세야 한다. 예를 들어, 문서가 abababa이고, 그리고 찾으려는 단어가 ababa라면, 세준이의 이 함수는 이 단어를 0번부터 찾을 수 있고, 2번부터도 찾을 수 있다. 그러나 동시에 셀 수는 없다. 세준이는 문서와 검색하려는 단어가 주어졌을 때, 그 단어가 최대 몇 번 중복되지 않게 등장하는지 구하는 프로그램을 작성하시오. 입력첫 번째 줄에 알파벳 대소문자, 공백으로 구성된 문자열이 주어진다. 문자열의 길이는 최대 1,000자이다. 문자열첫째 줄에 문서가 주어진다. 문서의 길이는 최대 2500이다. 둘째 줄에 검색하고 싶은 단어가 주어진다. 이 길이는 최대 50이다. 문서와 단어는 알파벳 소문자와 공백으로 이루어져 있다. 출력첫째 줄에 중복되지 않게 최대 몇 번 등장하는지 출력한다. 예제 입력 112ababababaaba 예제 출력 112 예제 입력 212a a a a aa a 예제 출력 212 출처 문제를 번역한 사람: baekjoon 데이터를 추가한 사람: chan120317, jaehoo1 문제의 오타를 찾은 사람: hist0613 알고리즘 분류 문자열 그리디 알고리즘 브루트포스 알고리즘 소스코드11234567891011121314import sysfrom collections import Counterinput = sys.stdin.readlinedoc = input().rstrip()word = input().rstrip()doc = doc.replace(word, &quot;?&quot;)temp = dict(Counter(list(doc)))if '?' in temp: print(temp['?'])else: print(0) 소스코드2123456789101112131415161718import sysinput = sys.stdin.readlinedoc = input().rstrip()word = input().rstrip()count = 0idx = 0while idx &lt;= len(doc) - len(word): if doc[idx:idx + len(word)] == word: count += 1 idx += len(word) else: idx += 1print(count)","link":"/categories/Algorithm/Python/BAEKJOON-1543-21-08-09/"},{"title":"[백준] 15501번 부당한 퍼즐","text":"출처: [백준] 15501번 부당한 퍼즐 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 256 MB 1224 493 313 43.961% 문제현욱은 퍼즐 게임을 굉장히 좋아한다. 어느 날 현욱은 친구로부터 간단한 플래시 퍼즐 게임을 하나 추천 받았는데, 이 퍼즐 게임은 다음과 같은 규칙을 갖고 있다. 플레이어는 1 ~ n 까지 숫자가 한 번씩만 나타나는 수열을 하나 가지고 시작한다. 또 다른 1 ~ n 까지 숫자가 한 번씩만 나타나는 수열이 주어졌을 때, 처음 수열을 적절히 변형해서 처음 받은 수열을 이 수열과 동일한 수열로 만들어야 한다. 이때, 플레이어가 수열에 대해서 할 수 있는 동작은 다음 두 가지가 있다. 동작은 몇 번이라도 수행할 수 있다. 뒤집기 : 현재 수열을 거꾸로 뒤집는다. ex) 1 2 3 4 5 -&gt; 5 4 3 2 1 밀기 : 현재 수열을 왼쪽 혹은 오른쪽으로 한 칸 민다. ex) 1 2 3 4 5 -&gt; 5 1 2 3 4 퍼즐을 풀던 현욱은 분명히 엄청 쉬운 규칙인데도 불구하고 문제가 안 풀려서, 한참을 고민하다가 다시 잘 비교해보니 정답 수열을 주어진 동작만으로는 절대 만들 수가 없는 문제였다! 화가 난 현욱은 퍼즐 제작자에게 따지기 위해 주어진 문제가 올바른 문제인지 아닌지 확인하는 프로그램을 만들기로 결심했다. 현욱을 도와 괘씸한 퍼즐 제작자를 응징해주자. 입력첫째 줄에 n이 주어진다(1 ≤ n ≤ 1,000,000). 둘째 줄에 1에서 n까지의 수가 한 번만 나타나는 수열이 순서대로 주어진다. 셋째 줄에 주어진 두 연산을 수행해서 구성할 수 있는지 확인할 1에서 n까지 수가 한 번만 나타나는 수열이 순서대로 주어진다. 출력주어진 두 가지 연산만을 가지고 처음 수열을 결과 수열로 만들 수 있다면 good puzzle, 아니면 bad puzzle을 출력한다. 예제 입력 112351 2 3 4 54 3 2 1 5 예제 출력 11good puzzle 예제 입력 212351 2 3 4 51 2 4 3 5 예제 출력 21bad puzzle 출처 Contest &gt; 소프트콘 &gt; 제1회 소프트콘 A번 문제를 만든 사람: jwvg0425 잘못된 데이터를 찾은 사람: tncks0121 알고리즘 분류 구현 자료 구조 덱 소스코드1234567891011121314151617181920212223import sysinput = sys.stdin.readlineN = int(input())sequence = list(map(int, input().split()))compare = list(map(int, input().split()))# 순방향first_idx = compare.index(sequence[0]) # 기준점new_list1 = compare[first_idx:] + compare[:first_idx]# 역방향compare = compare[::-1]first_idx = compare.index(sequence[0]) # 기준점new_list2 = compare[first_idx:] + compare[:first_idx]# 둘 중 하나 맞으면 good puzzleif sequence == new_list1 or sequence == new_list2: print(&quot;good puzzle&quot;)else: print(&quot;bad puzzle&quot;) 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import sysinput = sys.stdin.readlineN = int(input())sequence = list(map(int, input().split()))compare = list(map(int, input().split()))new_list1 = []new_list2 = []first_idx = compare.index(sequence[0]) # 기준점# 순방향인 경우start = first_idx - Nend = first_idxfor i in range(start, end): new_list1.append(compare[i])# 역방향인 경우start = first_idxend = first_idx - Nfor i in range(start, end, -1): new_list2.append(compare[i])# 둘 중 하나 맞으면 good puzzleif sequence == new_list1 or sequence == new_list2: print(&quot;good puzzle&quot;)else: print(&quot;bad puzzle&quot;)'''51 2 3 4 53 4 5 1 261 2 3 4 5 63 2 1 6 5 44 5 6 1 2 31111 10 9 8 7 6 5 4 3 2 11 2 3 4 5 6 7 8 9 10 11'''","link":"/categories/Algorithm/Python/BAEKJOON-15501-21-07-24/"},{"title":"[백준] 15652번 N과 M (4)","text":"출처: [백준] 15652번 N과 M (4) 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 512 MB 16829 13474 10961 80.224% 문제자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다. 길이가 K인 수열 A가 A1 ≤ A2 ≤ … ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다. 입력첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8) 출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다. 예제 입력 113 1 예제 출력 1123123 예제 입력 214 2 예제 출력 2123456789101 11 21 31 42 22 32 43 33 44 4 예제 입력 313 3 예제 출력 3123456789101 1 11 1 21 1 31 2 21 2 31 3 32 2 22 2 32 3 33 3 3 출처 문제를 만든 사람: baekjoon 알고리즘 분류 백트래킹 소스코드1234567891011121314151617181920import sysinput = sys.stdin.readlineN, M = map(int, input().split())result = []def dfs(idx, depth): if depth == M: print(*result) return for i in range(idx, N): result.append(i + 1) dfs(i, depth + 1) result.pop()dfs(0, 0)","link":"/categories/Algorithm/Python/BAEKJOON-15652-21-05-21/"},{"title":"[백준] 15815번 천재 수학자 성필","text":"출처: [백준] 15815번 천재 수학자 성필 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 1133 399 343 37.692% 문제평행 세계의 성필은 숫자와 연산자를 만든 당대 최고의 수학자이다. 그리고 놀랍게도 이 숫자와 연산자는 현재 우리가 사용하는 것과 같다. 하지만 수식은 연산자가 피연산자 가운데 위치하는 우리와는 다르게 연산자가 피연산자 뒤에 위치한다고 한다. 우리 세계의 식을 성필의 식으로 바꾸는 방법을 간단히 설명하자면 이렇다. 우선 주어진 식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다. 예를 들어 a+bc는 (a+(bc))의 식과 같게 된다. 그다음에 안에 있는 괄호의 연산자 를 괄호 밖으로 꺼내게 되면 a+bc가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다. 천재 수학자 성필은 자신이 만든 이런 간단한 식조차 1초 안에 계산하지 못하는 사람들을 위하여 답을 구해주는 프로그램을 개발하려고 했지만 아쉽게도 성필의 세계에는 프로그래밍 언어가 없다. 프로그래밍을 할 수 있는 우리가 성필을 위해 평행세계의 식을 계산하는 프로그램을 만들어주자. 입력길이가 100이 넘지 않는 수식이 예제 입력과 같이 공백 없이 입력된다. 수식은 0부터 9까지의 숫자와 연산자 ‘+’, ‘-‘, ‘*’, ‘/‘ 로만 이루어져 있다. 또한, 수식의 계산 중간 과정의 모든 결과는 항상 2,147,483,647을 넘지 않는 정수이고 0으로 나누는 경우는 없습니다. 잘못된 수식이 입력되는 경우도 없습니다. 출력입력으로 주어진 성필의 수식의 답을 첫째 줄에 출력한다. 예제 입력 11123*+ 예제 출력 117 출처 University &gt; 전북대학교 &gt; 2018 전북대학교 프로그래밍 경진대회 G번 문제의 오타를 찾은 사람: eric00513 잘못된 데이터를 찾은 사람: rory143 문제를 만든 사람: zxcv859500 알고리즘 분류 자료 구조 스택 소스코드123456789101112131415161718192021222324import sysinput = sys.stdin.readlineinput_string = input().rstrip()stack = []for x in input_string: if x.isdigit(): stack.append(int(x)) else: num2, num1 = stack.pop(), stack.pop() if x == '+': stack.append(num1 + num2) elif x == '-': stack.append(num1 - num2) elif x == '/': stack.append(num1 // num2) # 정수형임으로 // elif x == '*': stack.append(num1 * num2)print(stack[0])","link":"/categories/Algorithm/Python/BAEKJOON-15815-21-07-15/"},{"title":"[백준] 15828번 Router","text":"출처: [백준] 17952번 과제는 끝나지 않아! 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 512 MB 746 440 375 61.275% 문제인터넷을 사용하기 위해서는 컴퓨터에 인터넷 회선을 연결하거나 Wi-Fi를 연결해야 한다. 이렇게 연결된 네트워크를 통해 컴퓨터에는 통신이 가능하다. 마음에 드는 노래나 동영상이 있는 곳에 파일을 전송해달라는 요청을 보내고 파일을 받는 식으로 말이다. 우리가 보낸 요청은 어떻게 목적지까지 도달하는 것일까? 컴퓨터에서는 패킷이라고 하는 형태로 정보를 주고 받는다. 네트워크의 유저들은 1:1로 연결되어 있지 않으므로, 일반적으로 패킷은 라우터라는 장비를 여러 번 거친다. 그러면 라우터에서는 패킷을 다른 라우터로 보내거나, 만약 목적지와 직접적으로 연결되어 있다면 그곳으로 보낼 수도 있다. 즉, 택배 회사의 물류 센터와 비슷한 역할을 한다고 보면 된다. 그림1. 네트워크에 존재하는 라우터들의 구성 예시 라우터 내부를 들여다보면 처리해야 할 패킷을 임시적으로 보관하기 위한 버퍼가 존재한다. 이 버퍼에는 라우터에 입력으로 들어온 패킷들이 순서대로 위치하고, 라우터에서는 먼저 온 패킷부터 하나씩 처리한 후 버퍼에서 제거한다. 만약 라우터가 패킷을 처리하는 속도보다 패킷이 들어오는 속도가 더 빠를경우 버퍼가 꽉 차거나 넘쳐버릴 것이다. 그렇게 되면 버퍼에 공간이 생길 때까지 입력받는 패킷은 모두 버려진다. 통신의 원리를 배웠으니까 간단하게 라우터의 작동 원리를 구현해보자. 물론 하나의 라우터만 존재한다고 가정하며, 우리가 다룰 부분은 라우터의 입출력이 주어졌을 때 버퍼의 상태가 어떻게 변하는가이다. 그러니까 라우터가 패킷을 구체적으로 어떤 방식으로 처리하고, 어디로 보내고 이런 것들은 생각하지 말자. 입력첫 줄에는 라우터 내부에 존재하는 버퍼의 크기를 나타내는 자연수 N이 주어진다. 둘째 줄부터 한 줄에 하나씩 라우터가 처리해야 할 정보가 주어진다. 모든 정보는 발생한 시간순으로 주어졌다고 가정한다. 양의 정수는 해당하는 번호의 패킷이 입력으로 들어왔다는 것을 의미하고, 0은 라우터가 패킷 하나를 처리했다는 것을 의미한다. 이때, 버퍼가 비어있을때는 0이 입력으로 들어오지 않는다. -1은 입력의 끝을 나타낸다. 출력라우터에 남아있는 패킷을 앞에서부터 순서대로 공백으로 구분해서 출력하면 된다. 만약 비어있을 경우 empty라고 출력한다. Small (50점) 1 ≤ N ≤ 100,000 라우터가 처리해야 할 정보의 수는 N보다 작거나 같다. Large(50점) 1 ≤ N ≤ 100,000 1 ≤ N ≤ 100,000 예제 입력 112345678910111251203405600-1 예제 출력 115 6 예제 입력 212345678911234567-1 예제 출력 211 예제 입력 312345678910111213112034056070-1 예제 출력 31empty 출처 University &gt; 아주대학교 &gt; 2018 Ajou Programming Contest: Division 2 B번 문제를 만든 사람: luke0201 알고리즘 분류 자료 구조 큐 소스코드12345678910111213141516171819202122232425262728import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())buffer = deque()full = 0while True: packet = int(input()) if packet == -1: break elif packet == 0: buffer.popleft() full -= 1 else: if full &gt;= N: continue else: buffer.append(packet) full += 1if buffer: print(*buffer)else: print(&quot;empty&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-15828-21-07-20/"},{"title":"[백준] 15904번 UCPC는 무엇의 약자일까?","text":"출처: [백준] 15904번 UCPC는 무엇의 약자일까? 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 (추가 시간 없음) 512 MB 5119 2068 1745 41.776% 문제UCPC는 ‘전국 대학생 프로그래밍 대회 동아리 연합 여름 대회’의 줄임말로 알려져있다. 하지만 이 줄임말이 정확히 어떻게 구성되었는지는 아무도 모른다. UCPC 2018을 준비하던 ntopia는 여러 사람들에게 UCPC가 정확히 무엇의 줄임말인지 물어보았지만, 아무도 정확한 답을 제시해주지 못했다. ntopia가 들은 몇 가지 답을 아래에 적어보았다. Union of Computer Programming Contest club contest Union of Computer Programming contest Club contest Union of Computer Programming contest club Contest Union of Collegiate Programming Contest club contest Union of Collegiate Programming contest Club contest Union of Collegiate Programming contest club Contest University Computer Programming Contest University Computer Programming Club contest University Computer Programming club Contest University Collegiate Programming Contest University CPC … ntopia는 이렇게 다양한 답을 듣고는 UCPC가 무엇의 약자인지는 아무도 모른다고 결론내렸다. 적당히 슥삭해서 UCPC를 남길 수 있으면 모두 UCPC의 약자인 것이다! 문자열이 주어지면 이 문자열을 적절히 축약해서 “UCPC”로 만들 수 있는지 확인하는 프로그램을 만들어보자. 축약이라는 것은 문자열에서 임의의 문자들을 제거하는 행동을 뜻한다. 예를 들면, “apple”에서 a와 e를 지워 “ppl”로 만들 수 있고, “University Computer Programming Contest”에서 공백과 소문자를 모두 지워 “UCPC”로 만들 수 있다. 문자열을 비교할 때는 대소문자를 구분해 정확히 비교한다. 예를 들어 “UCPC”와 “UCpC”는 다른 문자열이다. 따라서 “University Computer programming Contest”를 “UCPC”로 축약할 수 있는 방법은 없다. 그나저나 UCPC는 정말 무엇의 약자였을까? 정확히 아시는 분은 제보 부탁드립니다. 입력첫 번째 줄에 알파벳 대소문자, 공백으로 구성된 문자열이 주어진다. 문자열의 길이는 최대 1,000자이다. 문자열의 맨 앞과 맨 끝에 공백이 있는 경우는 없고, 공백이 연속해서 2번 이상 주어지는 경우도 없다. 출력첫 번째 줄에 입력으로 주어진 문자열을 적절히 축약해 “UCPC”로 만들 수 있으면 “I love UCPC“를 출력하고, 만들 수 없으면 “I hate UCPC“를 출력한다. 예제 입력 11Union of Computer Programming Contest club contest 예제 출력 11I love UCPC 예제 입력 21University Computer Programming 예제 출력 21I hate UCPC 출처 University &gt; 전국 대학생 프로그래밍 대회 동아리 연합 여름 대회 &gt; UCPC 2018 예선 G번 문제를 만든 사람: ntopia 잘못된 데이터를 찾은 사람: skdty87 알고리즘 분류 문자열 그리디 알고리즘 소스코드123456789101112131415161718import sysinput = sys.stdin.readlinestring = input().rstrip()check_alpha = ['U', 'C', 'P', 'C']flag = Truefor alpha in check_alpha: if alpha in string: string = string[string.index(alpha) + 1:] else: flag = False breakprint(&quot;I love UCPC&quot;) if flag else print(&quot;I hate UCPC&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-15904-21-08-10/"},{"title":"[백준] 16165번 걸그룹 마스터 준석이","text":"출처: [백준] 16165번 걸그룹 마스터 준석이 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 (추가 시간 없음) 128 MB 1680 1055 788 63.446% 문제정우는 소문난 걸그룹 덕후이다. 정우의 친구 준석이도 걸그룹을 좋아하지만 이름을 잘 외우지 못한다는 문제가 있었다. 정우는 친구를 위해 걸그룹 개인과 팀의 이름을 검색하여 외우게 하는 퀴즈 프로그램을 만들고자 한다. 입력첫 번째 줄에는 총 입력 받을 걸그룹의 수 N(0 &lt; N &lt; 100)과 맞혀야 할 문제의 수 M(0 &lt; M &lt; 100)을 입력받는다. 두 번째 줄부터는 각 걸그룹마다 팀의 이름, 걸그룹의 인원 수, 멤버의 이름을 한 줄씩 차례대로 입력받는다. 팀과 멤버의 이름은 최대 100글자이며, 모든 글자는 알파벳 소문자이다. 하나의 걸그룹이나 서로 다른 두 걸그룹에 이름이 같은 두 멤버가 있는 경우는 없다. 그 다음 줄부터는 M개의 퀴즈를 입력받는다. 각각의 퀴즈는 두 줄로 이루어져 있으며, 팀의 이름이나 멤버의 이름이 첫 줄에 주어지고 퀴즈의 종류를 나타내는 0 또는 1이 두 번째 줄에 주어진다. 퀴즈의 종류가 0일 경우 팀의 이름이 주어지며, 1일 경우 멤버의 이름이 주어진다. 출력첫 번째 줄부터 차례대로 퀴즈에 대한 답을 출력한다. 퀴즈의 종류가 0일 경우 해당 팀에 속한 멤버의 이름을 사전순으로 한 줄에 한 명씩 출력한다. 퀴즈의 종류가 1일 경우 해당 멤버가 속한 팀의 이름을 출력한다. 예제 입력 11234567891011121314151617181920212223242526272829303132333 4twice9jihyodahyeonminamomochaeyoungjeongyeontzuyusananayeonblackpink4jisulisarosejennyredvelvet5wendyireneseulgiyerijoysana1wendy1twice0rose1 예제 출력 1123456789101112twiceredvelvetchaeyoungdahyeonjeongyeonjihyominamomonayeonsanatzuyublackpink 출처 University &gt; 숭실대학교 &gt; 2018 SCAL-MOOKJA A번 잘못된 데이터를 찾은 사람: gsj0617 문제를 만든 사람: wjddn0728 알고리즘 분류 자료 구조 해시를 사용한 집합과 맵 소스코드123456789101112131415161718192021222324import sysinput = sys.stdin.readlineN, M = map(int, input().split())Team = {}for _ in range(N): team_name = input().rstrip() Team[team_name] = [] members = int(input()) for _ in range(members): Team[team_name].append(input().rstrip())for _ in range(M): name = input().rstrip() flag = int(input()) if flag: # 팀 이름만 출력 for team, member in Team.items(): if name in member: print(team) else: # 멤버 전체 사전순 출력 print('\\n'.join(sorted(Team[name])))","link":"/categories/Algorithm/Python/BAEKJOON-16165-21-07-02/"},{"title":"[백준] 1620번 나는야 포켓몬 마스터 이다솜","text":"출처: [백준] 1620번 나는야 포켓몬 마스터 이다솜 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 256 MB 23782 7584 5382 31.946% 문제 안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어. (뚜벅 뚜벅) 얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~ (펑!) 헐랭… 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가…ㅜㅠ (터벅터벅) 어? 누구지? 오박사 : 나는 태초마을의 포켓몬 박사 오민식 박사라네. 다솜아, 포켓몬을 잡을 때는, 일단 상대 포켓몬의 체력을 적당히 바닥으로 만들어놓고 몬스터 볼을 던져야 한단다. 자, 내 포켓몬 이상해꽃으로 한번 잡아보렴. 포켓몬의 기술을 쓰는 것을 보고 포켓몬을 줄지 안줄지 결정을 하겠네. 자 한번 해보아라. 다솜아. 이다솜 : 이상해꽃이라…음.. 꽃이니깐 왠지 햇빛을 받아서 공격을 할 것 같은데… 음… 이상해꽃! 햇빛공격!!! (꼬렛이 이상해꽃에게 공격을 받아 체력이 25 감소했다.) 가라! 몬스터 볼!!! (꼬렛을 잡았습니다.) 야호! 신난다. 꼬렛을 잡았다. 오박사 : 오우!! 방금 쓴 공격은 솔라빔이라고 하네.. 어떻게 공격을 한 건가? 솔라빔이란 공격에 대해서 공부를 한 건가? 이다솜 : 꽃이니깐 왠지 햇빛을 제대로 받으면 광합성을 해서 음.. 그냥 그럴 것 같아서요 ☞☜ 오박사 : 다른 아이들은 넝쿨채찍이나, 나뭇잎 공격을 하는데, 다솜이는 역시 뭔가 다르구나. 그럼 나와 함께 연구소로 가자꾸나. 내가 포켓몬을 한 마리 줄 테니, 너의 꿈을 펼쳐보아라. 꿈은 이루어진단다. 이다솜 : 네! 오박사님, 고마워요.ㅜㅜ 오박사 : 가자. 나의 연구소는 너의 옆집의 아랫집이란다. 같이 가도록하자. 지금 포켓몬을 주마. 이다솜 : 네. 야호!! ‘ 오영식 : 어? 오박사님 얘는 누구인가요? 오박사 : 얘는 너의 라이벌이 될 친구 이다솜이라고 하네. 자, 포켓몬을 한 마리 골라보도록 해봐라 다솜아. 레이디퍼스트 네가 먼저 골라봐라. 이다솜 : 저는 생각해둔 포켓몬이 있어요. 피카츄 골라도 될까요? 오박사 : 그래 여기 피카츄가 한 마리 있단다. 피카츄를 가져가거라. 오영식 : 그럼 저는 이브이를 가져가겠어요. 그럼 나중에 보자 이다솜. 이다솜 : 그럼 꼬렛을 다시 잡으러 가야겠다. 영식아, 그리고 민식박사님 빠잉! 이다솜 : 피카츄 공격! 가라 몬스터 볼! 이다솜 : 야호! 신난다. 꼬렛을 잡았다!!!!! 이다솜 : 그럼! 일단 사천왕을 이기고 오겠어! 이다솜 : 여기가 사천왕과 대결하려면 가야하는 곳인가.. 경비원 : 사천왕과 대결을 하려면, 마을의 체육관 리더를 이겨서 배지를 8개를 모아야 한다네… 배지를 모아서 오도록 하게 이다솜 : 잉ㅠㅜ… 그럼 배지부터 모아야 하는구나ㅠㅜㅠㅜ 나쁘당 그냥 좀 봐주지.. &lt;1 년 후&gt; 그동안의 줄거리 : 이다솜은 일단 상록 숲의 체육관 리더에게 도전을 했다. 하지만 상록숲 체육관의 리더는 실종된 상태. 따라서 회색마을부터 도전하기로 했다. 체육관의 리더를 이기면서, 로켓단을 해체시키기도 하고, 여러 가지 사건도 있었다. 결국 전설의 포켓몬도 잡고, 이제 사천왕을 이기려고 도전하기로 했다. 사천왕은 모두 가볍게 이기고, 이제 마지막 라이벌 오!영!식! 이다. 오영식 : 훗. 1년 전의 그 이다솜이 사천왕을 이기고 현재 포켓몬 마스터인 나에게 덤벼? 어디 한번 덤벼보시지. 이다솜 : 헐랭… 나를 우습게보네…. 한번 두고 보시지! 그럼 대결이닷! 이다솜 : 휴… 이겼다. 오영식 : 내가 지다니 분하다. ㅜㅜ 오박사 : 그럼 다솜아 이제 진정한 포켓몬 마스터가 되기 위해 도감을 완성시키도록 하여라. 일단 네가 현재 가지고 있는 포켓몬 도감에서 포켓몬의 이름을 보면 포켓몬의 번호를 말하거나, 포켓몬의 번호를 보면 포켓몬의 이름을 말하는 연습을 하도록 하여라. 나의 시험을 통과하면, 내가 새로 만든 도감을 주도록 하겠네. 입력첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어. 둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음… 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 포켓몬 이름의 최대 길이는 20이야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!! 출력첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~ 이게 오박사님이 나에게 새로 주시려고 하는 도감이야. 너무 가지고 싶다ㅠㅜ. 꼭 만점을 받아줬으면 좋겠어!! 파이팅!!! 예제 입력 1123456789101112131415161718192021222324252627282930313226 5BulbasaurIvysaurVenusaurCharmanderCharmeleonCharizardSquirtleWartortleBlastoiseCaterpieMetapodButterfreeWeedleKakunaBeedrillPidgeyPidgeottoPidgeotRattataRaticateSpearowFearowEkansArbokPikachuRaichu25Raichu3PidgeyKakuna 예제 출력 112345Pikachu26Venusaur1614 출처 문제를 만든 사람: baekjoon 문제의 오타를 찾은 사람: frogyou2330 알고리즘 분류 자료 구조 해시를 사용한 집합과 맵 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243import sysinput = sys.stdin.readlineN, M = map(int, input().split())pocket_dict = {}pocket_dict2 = {}for i in range(N): pocketmon_name = input().rstrip() pocket_dict[i + 1] = pocketmon_name pocket_dict2[pocketmon_name] = i + 1for i in range(M): quiz = input().rstrip() if quiz.isdigit(): # 숫자일 경우 print(pocket_dict[int(quiz)]) else: # 영어일 경우 print(pocket_dict2[quiz]) -------------시간초과-------------import sysinput = sys.stdin.readlineN, M = map(int, input().split())pocket_dict = {}for i in range(N): pocketmon_name = input().rstrip() pocket_dict[i + 1] = pocketmon_namefor i in range(M): quiz = input().rstrip() if quiz.isdigit(): # 숫자일 경우 print(pocket_dict[int(quiz)]) else: # 영어일 경우 [print(number) for number, name in pocket_dict.items() if name == quiz]","link":"/categories/Algorithm/Python/BAEKJOON-1620-21-06-28/"},{"title":"[백준] 15903번 카드 합체 놀이","text":"출처: [백준] 15903번 카드 합체 놀이 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 (추가 시간 없음) 512 MB 4761 1895 1599 41.706% 문제석환이는 아기다. 아기 석환이는 자연수가 쓰여져있는 카드를 갖고 다양한 놀이를 하며 노는 것을 좋아한다. 오늘 아기 석환이는 무슨 놀이를 하고 있을까? 바로 카드 합체 놀이이다! 아기 석환이는 자연수가 쓰여진 카드를 n장 갖고 있다. 처음에 i번 카드엔 ai가 쓰여있다. 카드 합체 놀이는 이 카드들을 합체하며 노는 놀이이다. 카드 합체는 다음과 같은 과정으로 이루어진다. x번 카드와 y번 카드를 골라 그 두 장에 쓰여진 수를 더한 값을 계산한다. (x ≠ y) 계산한 값을 x번 카드와 y번 카드 두 장 모두에 덮어 쓴다. 이 카드 합체를 총 m번 하면 놀이가 끝난다. m번의 합체를 모두 끝낸 뒤, n장의 카드에 쓰여있는 수를 모두 더한 값이 이 놀이의 점수가 된다. 이 점수를 가장 작게 만드는 것이 놀이의 목표이다. 아기 석환이는 수학을 좋아하긴 하지만, 아직 아기이기 때문에 점수를 얼마나 작게 만들 수 있는지를 알 수는 없었다(어른 석환이는 당연히 쉽게 알 수 있다). 그래서 문제 해결 능력이 뛰어난 여러분에게 도움을 요청했다. 만들 수 있는 가장 작은 점수를 계산하는 프로그램을 만들어보자. 입력첫 번째 줄에 카드의 개수를 나타내는 수 n(2 ≤ n ≤ 1,000)과 카드 합체를 몇 번 하는지를 나타내는 수 m(0 ≤ m ≤ 15×n)이 주어진다. 두 번째 줄에 맨 처음 카드의 상태를 나타내는 n개의 자연수 a1, a2, …, an이 공백으로 구분되어 주어진다. (1 ≤ ai ≤ 1,000,000) 출력첫 번째 줄에 만들 수 있는 가장 작은 점수를 출력한다. 예제 입력 1123 13 2 6 예제 출력 1116 예제 입력 2124 24 2 3 1 예제 출력 2119 출처 University &gt; 전국 대학생 프로그래밍 대회 동아리 연합 여름 대회 &gt; UCPC 2018 예선 B번 문제를 만든 사람: haden 알고리즘 분류 자료 구조 그리디 알고리즘 우선순위 큐 소스코드123456789101112131415161718import sysimport heapqinput = sys.stdin.readlineN, M = map(int, input().split())card_list = list(map(int, input().split()))heapq.heapify(card_list) # card_list를 heap으로 변환for _ in range(M): x, y = heapq.heappop(card_list), heapq.heappop(card_list) for _ in range(2): heapq.heappush(card_list, x + y)print(sum(card_list))","link":"/categories/Algorithm/Python/BAEKJOON-15903-21-05-06/"},{"title":"[백준] 1629번 곱셈","text":"출처: [백준] 1629번 곱셈 문제자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오. 입력첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다. 출력첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다. 예제 입력 1110 11 12 예제 출력 114 힌트 출처 문제를 만든 사람: author5 알고리즘 분류 수학 분할 정복을 이용한 거듭제곱 시간 제한 풀이 소스코드 1123456789101112131415161718import sysinput = sys.stdin.readlinedef power(a, b): if b == 1: return a % C else: if b % 2 == 0: # B가 짝수일 때 return power(a, b // 2) ** 2 % C else: return power(a, b // 2) ** 2 * a % CA, B, C = map(int, input().split())print(power(A, B)) 소스코드 21234567import sysinput = sys.stdin.readlineA, B, C = map(int, input().split())print(pow(A, B, C))","link":"/categories/Algorithm/Python/BAEKJOON-1629-21-04-02/"},{"title":"[백준] 17219번 비밀번호 찾기","text":"출처: [백준] 17219번 비밀번호 찾기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 5 초 256 MB 3192 2207 1783 70.782% 문제2019 HEPC - MAVEN League의 “비밀번호 만들기“와 같은 방식으로 비밀번호를 만든 경민이는 한 가지 문제점을 발견하였다. 비밀번호가 랜덤으로 만들어져서 기억을 못 한다는 것이었다! 그래서 경민이는 메모장에 사이트의 주소와 비밀번호를 저장해두기로 했다. 하지만 컴맹인 경민이는 메모장에서 찾기 기능을 활용하지 못하고 직접 눈으로 사이트의 주소와 비밀번호를 찾았다. 메모장에 저장된 사이트의 수가 늘어나면서 경민이는 비밀번호를 찾는 일에 시간을 너무 많이 쓰게 되었다. 이를 딱하게 여긴 문석이는 경민이를 위해 메모장에서 비밀번호를 찾는 프로그램을 만들기로 결심하였다! 문석이를 도와 경민이의 메모장에서 비밀번호를 찾아주는 프로그램을 만들어보자. 입력첫째 줄에 저장된 사이트 주소의 수 N(1 ≤ N ≤ 100,000)과 비밀번호를 찾으려는 사이트 주소의 수 M(1 ≤ M ≤ 100,000)이 주어진다. 두번째 줄부터 N개의 줄에 걸쳐 각 줄에 사이트 주소와 비밀번호가 공백으로 구분되어 주어진다. 사이트 주소는 알파벳 소문자, 알파벳 대문자, 대시(‘-‘), 마침표(‘.’)로 이루어져 있고, 중복되지 않는다. 비밀번호는 알파벳 대문자로만 이루어져 있다. 모두 길이는 최대 20자이다. N+2번째 줄부터 M개의 줄에 걸쳐 비밀번호를 찾으려는 사이트 주소가 한줄에 하나씩 입력된다. 이때, 반드시 이미 저장된 사이트 주소가 입력된다. 출력첫 번째 줄부터 M개의 줄에 걸쳐 비밀번호를 찾으려는 사이트 주소의 비밀번호를 차례대로 각 줄에 하나씩 출력한다. 예제 입력 112345678910111213141516171819202116 4noj.am IUacmicpc.net UAENAstartlink.io THEKINGODgoogle.com ZEZEnate.com VOICEMAILnaver.com REDQUEENdaum.net MODERNTIMESutube.com BLACKOUTzum.com LASTFANTASYdreamwiz.com RAINDROPhanyang.ac.kr SOMEDAYdhlottery.co.kr BOOduksoo.hs.kr HAVANAhanyang-u.ms.kr OBLIVIATEyd.es.kr LOVEATTACKmcc.hanyang.ac.kr ADREAMERstartlink.ioacmicpc.netnoj.ammcc.hanyang.ac.kr 예제 출력 11234THEKINGODUAENAIUADREAMER 노트입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다. C++을 사용하고 있고 cin/cout을 사용하고자 한다면, main함수 안에 cin.tie(NULL)과 ios::sync_with_stdio(false)함수를 둘 다 호출해 주고, endl 대신 개행문자(\\n)를 쓰자. 단, 이렇게 하면 더 이상 scanf/printf/puts/getchar/putchar 등 C의 입출력 방식을 사용하면 안 된다. Java를 사용하고 있다면, Scanner와 System.out.println 대신 BufferedReader와 BufferedWriter를 사용할 수 있다. BufferedWriter.flush는 맨 마지막에 한 번만 하면 된다. 출처 University &gt; 한양대 ERICA &gt; 2019 HEPC - MAVEN League F번 문제를 만든 사람: TheKinGoD 알고리즘 분류 자료 구조 해시를 사용한 집합과 맵 소스코드12345678910111213141516import sysinput = sys.stdin.readlineN, M = map(int, input().split())password = {}for _ in range(N): url, pwd = input().split() password[url] = pwdfor _ in range(M): url = input().rstrip() print(password[url])","link":"/categories/Algorithm/Python/BAEKJOON-17219-21-06-30/"},{"title":"[백준] 2720번 세탁소 사장 동혁","text":"출처: [백준] 2720번 세탁소 사장 동혁 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 3397 2618 2390 78.361% 문제미국으로 유학간 동혁이는 세탁소를 운영하고 있다. 동혁이는 최근에 아르바이트로 고등학생 리암을 채용했다. 동혁이는 리암에게 실망했다. 리암은 거스름돈을 주는 것을 자꾸 실수한다. 심지어 $0.5달러를 줘야하는 경우에 거스름돈으로 $5달러를 주는것이다! 어쩔수 없이 뛰어난 코딩 실력을 발휘해 리암을 도와주는 프로그램을 작성하려고 하지만, 디아블로를 하느라 코딩할 시간이 없어서 이 문제를 읽고 있는 여러분이 대신 해주어야 한다. 거스름돈의 액수가 주어지면 리암이 줘야할 쿼터(Quarter, $0.25)의 개수, 다임(Dime, $0.10)의 개수, 니켈(Nickel, $0.05)의 개수, 페니(Penny, $0.01)의 개수를 구하는 프로그램을 작성하시오. 거스름돈은 항상 $5.00 이하이고, 손님이 받는 동전의 개수를 최소로 하려고 한다. 예를 들어, $1.24를 거슬러 주어야 한다면, 손님은 4쿼터, 2다임, 0니켈, 4페니를 받게 된다. 입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. (1달러 = 100센트) (1&lt;=C&lt;=500) 출력각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다. 예제 입력 11234312425194 예제 출력 11234 2 0 41 0 0 07 1 1 4 출처 ICPC &gt; Regionals &gt; North America &gt; Greater New York Region &gt; 2006 Greater New York Programming Contest A번 문제를 번역한 사람: baekjoon 알고리즘 분류 수학 그리디 알고리즘 사칙연산 소스코드12345678910111213141516171819202122232425262728import sysinput = sys.stdin.readlineT = int(input())# quarter = 25# Dime = 10# Nickel = 5# Penny = 1for _ in range(T): quarter, dime, nickel, penny = 0, 0, 0, 0 # 각 동전 개수 C = int(input()) while C &gt; 0: if C &gt;= 25: # Quarter quarter += C // 25 C %= 25 elif C &gt;= 10: # Dime dime += C // 10 C %= 10 elif C &gt;= 5: # Nickel nickel += C // 5 C %= 5 elif C &gt;= 1: # Penny penny += C // 1 C -= penny print(quarter, dime, nickel, penny)","link":"/categories/Algorithm/Python/BAEKJOON-1720-21-08-04/"},{"title":"[백준] 17225번 세훈이의 선물가게","text":"출처: [백준] 17225번 세훈이의 선물가게 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 512 MB 1120 261 197 29.315% 문제세훈이는 선물가게를 운영한다. 세훈이의 선물가게는 특이하게도 손님이 어떤 선물을 구매할지 선택할 수가 없다. 대신 세훈이의 취향으로 랜덤하게 준비된 선물 중 몇 개를 구매할 것인지, 파란색과 빨간색 중 어떤 색으로 포장 받을 것인지만 결정해 주문할 수 있다. 상민이와 지수는 세훈이의 가게에서 선물 포장을 맡은 아르바이트생이다. 손님들은 파란색 포장지를 원하면 상민이에게, 빨간색 포장지를 원하면 지수에게 주문을 한다. 두 사람은 각자 주문을 받으면 그때부터 포장을 시작하는데, 현재 남아있는 선물 중 가장 앞에 있는 선물을 가져와 포장하고 주문을 받은 개수만큼 이를 반복하는 형태다. 이때 선물 하나를 포장하는 데 상민이는 A초, 지수는 B초가 걸린다. 두 사람 모두 받거나 밀린 주문이 없는데 미리 선물을 가져오거나 포장하는 일은 없으며, 두 사람이 동시에 선물을 가져올 때는 알바짬이 조금 더 있는 상민이가 먼저 가져오고, 지수가 그 뒤의 선물을 가져온다. 세훈이는 어제 구매한 선물이 망가져 있다는 항의 전화를 받았다. 자신이 준비한 선물에는 문제가 없었기에 손님에게 포장지의 색을 물었지만, 손님은 자신이 받은 선물이 무엇인지만 말하며 화를 낼 뿐이었다. 어쩔 수 없이 세훈이는 어제 가게를 방문한 손님들의 주문 내역을 보고 그 선물을 누가 포장했는지 파악하려 한다. 방문한 손님의 수와 각 손님이 주문한 시각, 선택한 포장지, 포장 받을 선물의 개수가 주어졌을 때 상민이와 지수가 각자 어떤 선물들을 포장했는지 알아내는 프로그램을 작성해보자. 입력첫 줄에 상민이가 선물 하나를 포장하는 데 걸리는 시간 A, 지수가 선물 하나를 포장하는 데 걸리는 시간 B, 어제 세훈이 가게의 손님 수 N(1 ≤ N ≤ 1,000)이 주어진다. 이후 N개의 줄에 걸쳐 1번부터 N번 손님의 주문 시각 ti(1 ≤ ti ≤ 86,400), 선택한 포장지의 색깔 ci(ci = “B”|”R”), 주문한 선물의 개수 mi(1 ≤ mi ≤ 100)가 주어진다. ti는 가게가 오픈한 지 ti초 후에 손님이 주문했음을 뜻하며 ci는 포장지의 색깔을 의미하는 알파벳으로 “B”는 파란색을, “R”은 빨간색을 의미한다. 주어지는 입력은 시간의 흐름에 맞게 ti의 오름차순으로 주어지며, 서로 같은 시간에 주문한 손님은 없다. 출력첫 번째 줄에 상민이가 포장한 선물의 개수를 출력한다. 이후 두 번째 줄에 상민이가 포장한 선물들의 번호를 오름차순으로 공백으로 구분하여 출력한다. 세 번째 줄에 지수가 포장한 선물의 개수를 출력한다. 이후 네 번째 줄에 지수가 포장한 선물들의 번호를 오름차순으로 공백으로 구분하여 출력한다. 서브태스크 1 (100점) A = B = 0 A, B가 0이라는 것은 해당 아르바이트생의 포장 속도가 너무 빨라서, 주문과 동시에 해당 주문의 모든 선물 포장이 끝난다는 의미이다. 서브태스크 2 (40점) 0 ≤ A, B ≤ 300 예제 입력 112340 0 31 B 34 R 27 R 2 예제 출력 1123431 2 344 5 6 7 예제 입력 2123452 3 41 B 34 R 26 B 212 R 1 예제 출력 2123451 2 4 5 733 6 8 출처 University &gt; 아주대학교 &gt; 2019 아주대학교 프로그래밍 경시대회 APC - Div.1 B번 University &gt; 아주대학교 &gt; 2019 아주대학교 프로그래밍 경시대회 APC - Div.2 B번 문제를 만든 사람: Acka, spectaclehong 알고리즘 분류 구현 자료 구조 우선순위 큐 큐 소스코드 (Heap 이용)12345678910111213141516171819202122232425262728293031323334353637383940414243444546import sysimport heapqinput = sys.stdin.readlines_time, j_time, customer_count = map(int, input().split()) # 상민 포장시간, 지수 포장시간, 손님수pacakage_list = [] # 포장시작 시간 리스트s_end, j_end = 0, 0 # 상민, 지수 포장 끝난 시간for _ in range(customer_count): start_time, color, present_count = input().rstrip().split() # 주문시각, 색깔, 개수 start_time = int(start_time) if color == 'B': # 상민 # 상민 포장 주문시각이 포장끝난 시각보다 먼저일 경우 # 주문시각(포장시작시각)을 포장끝난 시점으로 변경해준다. start_time = max(start_time, s_end) for i in range(int(present_count)): # 주문 개수만큼 반복 heapq.heappush(pacakage_list, [start_time, 'B']) # 상민 포장시작 시간 리스트에 저장 start_time += s_time # 기존 포장시작시간에 포장에 걸리는 시간 더하기 s_end = start_time # 포장끝난 시간은 포장시작시간+포장에 걸리는 시간 elif color == 'R': # 지수 start_time = max(start_time, j_end) for i in range(int(present_count)): heapq.heappush(pacakage_list, [start_time, 'R']) start_time += j_time j_end = start_times_present, j_present = [], [] # 상민, 지수가 포장한 선물리스트for i in range(1, len(pacakage_list) + 1): present = heapq.heappop(pacakage_list) if present[1] == 'B': s_present.append(i) else: j_present.append(i)print(len(s_present))print(*s_present)print(len(j_present))print(*j_present) 소스코드 (Queue 이용)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import sysfrom collections import dequeinput = sys.stdin.readlines_time, j_time, customer_count = map(int, input().split()) # 상민 포장시간, 지수 포장시간, 손님수sangmin = deque() # 상민 포장시작 시간 리스트jisu = deque() # 지수 포장시작 시간 시간 리스트s_end, j_end = 0, 0 # 상민, 지수 포장 끝난 시간for _ in range(customer_count): start_time, color, present_count = input().rstrip().split() # 주문시각, 색깔, 개수 start_time = int(start_time) if color == 'B': # 상민 start_time = max(start_time, s_end) # if start_time &lt; s_end: # 상민 포장 주문시각이 포장끝난 시각보다 먼저일 경우 # start_time = s_end # 주문시각(포장시작시각)을 포장끝난 시점으로 변경해준다. for i in range(int(present_count)): # 주문 개수만큼 반복 sangmin.append([start_time, 'B']) # 상민 포장시작 시간 리스트에 저장 start_time += s_time # 기존 포장시작시간에 포장에 걸리는 시간 더하기 s_end = start_time # 포장끝난 시간은 포장시작시간+포장에 걸리는 시간 elif color == 'R': # 지수 start_time = max(start_time, j_end) # if start_time &lt; j_end: # start_time = j_end for i in range(int(present_count)): jisu.append([start_time, 'R']) start_time += j_time j_end = start_timetotal_list = sangmin + jisutotal_list = sorted(total_list, key=lambda x: [x[0], x[1]])s_present, j_present = [], [] # 상민, 지수가 포장한 선물리스트for idx, present in enumerate(total_list): if present[1] == 'B': s_present.append(idx + 1) else: j_present.append(idx + 1)print(len(s_present))print(*s_present)print(len(j_present))print(*j_present)","link":"/categories/Algorithm/Python/BAEKJOON-17225-21-07-20/"},{"title":"[백준] 17264번 I AM IRONMAN","text":"출처: [백준] 17264번 I AM IRONMAN 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 788 388 358 50.210% 문제다들 문제 제목을 보고 요즘 가장 핫한 영화를 생각했겠지만 이 이야기는 LUL(League Us Legends) 게임에서 아이언(Iron) 티어에 있는 형동이의 슬픈 이야기이다. LUL에서 티어는 게임 실력을 판가름할 수 있는 지표이다. 그중 아이언 티어는 가장 낮은 단계에 위치해 있다. 친구인 강엽이와 건홍이에게 “Ironman”이라며 게임을 못한다고 놀림당하던 형동이는 꼭 아이언 티어에서 벗어나겠다고 결심했다. 하지만 형동이는 자신의 실력으로 절대 아이언(Iron) 티어에서 벗어나지 못하는 것을 알고 있다. LUL은 두 명의 플레이어가 같이 팀이 되어 하는 게임이기 때문에 자신이 못해도 게임에서 이길 수 있고 자신이 잘해도 게임은 질 수 있다. 형동이는 게임은 못하지만 머리가 매우 똑똑하여 LUL 게임을 해킹하여서 몇몇 플레이어와 같이 게임을 하게 되면 게임의 승패가 어떻게 되는지 알게 되었다. 하지만 해킹을 통하여 알아내지 못한 플레이어와 같이 게임을 하는 경우 형동이가 매우 못하기 때문에 같은 팀원이 아무리 잘해도 반드시 진다. 위와 같은 경우에서 “JIHOON”과 같이 게임을 하는 경우 20점(W = 20)을 획득하는 반면에 “GANGYEOP”이나 “MINSUNG”과 같이 게임 하는 경우 경우 15점(L = 15)을 잃게 된다. 뿐만 아니라, 해킹을 통해 알지 내지 못한 플레이어를 만나게 되는 경우 형동이가 매우 못하여 지기 때문에 15점을 잃게 된다. (단, 계속 지더라도 점수는 0점 밑으로 떨어지지 않는다.) 형동이가 N번에 게임을 통해서 아이언 티어에서 탈출한 경우 형동이는 “I AM NOT IRONMAN”이라고 외치지만 탈출하지 못한 경우 “I AM IRONMAN”이라고 외친다. 여기서 아이언 티어를 탈출하기 위해서 100점 (G = 100) 이상이 되어야 했다면 9번째 게임(주황색 사각형)을 하고 아이언 티어를 탈출하였기 때문에 형동이는 “I AM NOT IRONMAN”이라고 외친다. 아이언 티어에서 탈출한 경우 그 이후에 게임은 신경쓰지 않는다. 하지만 만약 탈출하기 위해서 200점(G = 200) 이상이 되어야 한다고 했을 경우 형동이는 아이언 티어를 탈출하지 못했기 때문에 “I AM IRONMAN”이라고 외치게 된다. 과연 형동이는 게임이 끝난 후 어떤 대사를 할 지 우리가 맞춰보자. 입력첫 번째 줄에는 총 게임 횟수 N과 해킹을 통해 얻은 플레이어 정보의 수 P가 주어진다. (N과 P는 1,000이하의 자연수) 그리고 두 번째 줄에는 이긴 경우 획득 점수 W와 졌을 때 떨어지는 점수 L, 그리고 IRON 티어에서 벗어나기 위한 점수 G가 주어진다. (0 ≤ W, L ≤ 100, 1 ≤ G ≤ 100,000, 이 때, W, L, G는 정수) 그리고 다음 P개의 줄에는 플레이어의 이름과 무조건 이길 수 있는 경우 W, 무조건 지는 경우 L이라는 단어가 플레이어 이름과 쌍으로 나온다. 그리고 그 다음 N개의 줄에는 같이 게임을 하는 플레이어의 이름이 나온다. 플레이어 이름은 반드시 대문자로 나오며 길이는 20이 넘지 않는다. 출력0점부터 시작하였을 때 형동이가 아이언 티어에서 벗어나지 못한 경우 &quot;I AM IRONMAN!!&quot;, 아이언 티어에서 벗어난 경우 “I AM NOT IRONMAN!!”을 출력한다. 예제 입력 112345678910111213141510 320 15 100JIHOON WGANGYEOP LMINSUNG LJIHOONMYEONGKIGANGYEOPMINSUNGJIHOONJIHOONJIHOONJIHOONJIHOONMINSUNG 예제 출력 11I AM NOT IRONMAN!! 예제 입력 212345678910111213141510 320 15 100JIHOON WGANGYEOP LMINSUNG LJIHOONGANGYEOPJISUPMINSUNGJIHOONJIHOONMOJIKYUNGMINSOOHOSEOKGYE 예제 출력 21I AM IRONMAN!! 출처 University &gt; 인하대학교 &gt; 2019 인하대학교 프로그래밍 경진대회(IUPC) B번 문제를 만든 사람: hahawjstk 알고리즘 분류 구현 자료 구조 해시를 사용한 집합과 맵 소스코드1234567891011121314151617181920212223242526272829303132import sysinput = sys.stdin.readlineN, P = map(int, input().split())W, L, G = map(int, input().split())hacking = {}for _ in range(P): name, WL = input().rstrip().split() hacking[name] = WLscore = 0for _ in range(N): name = input().rstrip() if name in hacking.keys(): if hacking[name] == 'W': score += W else: score -= L else: score -= L if score &lt; 0: score = 0 elif score &gt;= G: print('I AM NOT IRONMAN!!') exit(0)print('I AM IRONMAN!!')","link":"/categories/Algorithm/Python/BAEKJOON-17264-21-07-04/"},{"title":"[백준] 17298번 오큰수","text":"출처: [백준] 17298번 오큰수 문제크기가 N인 수열 A = A1, A2, …, AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다. 예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다. 입력첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A1, A2, …, AN (1 ≤ Ai ≤ 1,000,000)이 주어진다. 출력총 N개의 수 NGE(1), NGE(2), …, NGE(N)을 공백으로 구분해 출력한다. 예제 입력 11243 5 2 7 예제 출력 115 7 7 -1 예제 입력 21249 5 4 8 예제 출력 21-1 8 8 -1 힌트 출처 문제를 만든 사람: baekjoon 데이터를 추가한 사람: rhdqor213https://www.acmicpc.net/user/occidere) 알고리즘 분류 자료 구조 스택 시간 제한 풀이 소스코드123456789101112131415161718192021222324import sysinput = sys.stdin.readlineN = int(input())num_list = list(map(int, input().split()))index_stack = []result = [-1 for _ in range(N)] # 각 인덱스에 오큰수를 찾지 못하면 -1index_stack.append(0)i = 1while index_stack and i &lt; N: # 스택에 값이 존재하며, i가 N보다 작을 때만 while index_stack and num_list[index_stack[-1]] &lt; num_list[i]: result[index_stack[-1]] = num_list[i] index_stack.pop() index_stack.append(i) i += 1for num in result: print(num, end=&quot; &quot;)","link":"/categories/Algorithm/Python/BAEKJOON-17298-21-03-31/"},{"title":"[백준] 17413번 단어 뒤집기 2","text":"출처: [백준] 17413번 단어 뒤집기 2 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 512 MB 7264 3947 3069 55.317% 문제문자열 S가 주어졌을 때, 이 문자열에서 단어만 뒤집으려고 한다. 먼저, 문자열 S는 아래와과 같은 규칙을 지킨다. 알파벳 소문자(‘a‘-‘z‘), 숫자(‘0‘-‘9‘), 공백(‘ ‘), 특수 문자(‘&lt;‘, ‘&gt;‘)로만 이루어져 있다. 문자열의 시작과 끝은 공백이 아니다. ‘&lt;‘와 ‘&gt;‘가 문자열에 있는 경우 번갈아가면서 등장하며, ‘&lt;‘이 먼저 등장한다. 또, 두 문자의 개수는 같다. 태그는 ‘&lt;‘로 시작해서 ‘&gt;‘로 끝나는 길이가 3 이상인 부분 문자열이고, ‘&lt;‘와 ‘&gt;‘ 사이에는 알파벳 소문자와 공백만 있다. 단어는 알파벳 소문자와 숫자로 이루어진 부분 문자열이고, 연속하는 두 단어는 공백 하나로 구분한다. 태그는 단어가 아니며, 태그와 단어 사이에는 공백이 없다. 입력첫째 줄에 문자열 S가 주어진다. S의 길이는 100,000 이하이다. 출력첫째 줄에 문자열 S의 단어를 뒤집어서 출력한다. 예제 입력 11baekjoon online judge 예제 출력 11noojkeab enilno egduj 예제 입력 21&lt;open&gt;tag&lt;close&gt; 예제 출력 21&lt;open&gt;gat&lt;close&gt; 예제 입력 31&lt;ab cd&gt;ef gh&lt;ij kl&gt; 예제 출력 31&lt;ab cd&gt;fe hg&lt;ij kl&gt; 예제 입력 41one1 two2 three3 4fourr 5five 6six 예제 출력 411eno 2owt 3eerht rruof4 evif5 xis6 예제 입력 51&lt;int&gt;&lt;max&gt;2147483647&lt;long long&gt;&lt;max&gt;9223372036854775807 예제 출력 51&lt;int&gt;&lt;max&gt;7463847412&lt;long long&gt;&lt;max&gt;7085774586302733229 예제 입력 61&lt;problem&gt;17413&lt;is hardest&gt;problem ever&lt;end&gt; 예제 출력 61&lt;problem&gt;31471&lt;is hardest&gt;melborp reve&lt;end&gt; 예제 입력 71&lt; space &gt;space space space&lt; spa c e&gt; 예제 출력 71&lt; space &gt;ecaps ecaps ecaps&lt; spa c e&gt; 출처 문제를 만든 사람: baekjoon 알고리즘 분류 구현 문자열 소스코드12345678910111213141516171819202122232425262728293031323334import sysinput = sys.stdin.readlineinput_string = list(input().rstrip())temp_stack = []result = []flag = 0for x in input_string: if x == '&lt;': flag = 1 temp_stack.append(x) elif x == '&gt;': flag = 0 temp_stack.append(x) result += temp_stack temp_stack = [] elif x == ' ': temp_stack.append(x) result += temp_stack temp_stack = [] else: if flag == 0: temp_stack.insert(0, x) elif flag: temp_stack.append(x)result += temp_stackfor x in result: print(x, end='')","link":"/categories/Algorithm/Python/BAEKJOON-17413-21-06-21/"},{"title":"[백준] 1748번 수 이어 쓰기 1","text":"출처: [백준] 1748번 수 이어 쓰기 1 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 0.15 초 128 MB 12262 5639 4743 51.209% 문제1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다. 1234567891011121314151617181920212223… 이렇게 만들어진 새로운 수는 몇 자리 수일까? 이 수의 자릿수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 N(1 ≤ N ≤ 100,000,000)이 주어진다. 출력첫째 줄에 새로운 수의 자릿수를 출력한다. 예제 입력 115 예제 출력 115 예제 입력 2115 예제 출력 2121 예제 입력 31120 예제 출력 31252 출처 Olympiad &gt; Croatian Highschool Competitions in Informatics &gt; 2004 &gt; Regional Competition - Juniors 1번 문제를 번역한 사람: author5 알고리즘 분류 수학 구현 소스코드12345678910111213141516171819N = input()exp = 0result = 0while exp &lt; len(N) - 1: result += 9 * (10 ** exp) * (exp + 1) exp += 1result += (int(N) - (10 ** (len(N) - 1)) + 1) * len(N)print(result)---------------# 시간초과N = int(input())new_num = &quot;&quot;for i in range(1, N + 1): new_num += str(i)print(len(new_num))","link":"/categories/Algorithm/Python/BAEKJOON-1748-21-06-17/"},{"title":"[백준] 17608번 막대기","text":"출처: [백준] 17608번 막대기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 (추가 시간 없음) 512 MB 6130 2829 2254 48.162% 문제아래 그림처럼 높이만 다르고 (같은 높이의 막대기가 있을 수 있음) 모양이 같은 막대기를 일렬로 세운 후, 왼쪽부터 차례로 번호를 붙인다. 각 막대기의 높이는 그림에서 보인 것처럼 순서대로 6, 9, 7, 6, 4, 6 이다. 일렬로 세워진 막대기를 오른쪽에서 보면 보이는 막대기가 있고 보이지 않는 막대기가 있다. 즉, 지금 보이는 막대기보다 뒤에 있고 높이가 높은 것이 보이게 된다. 예를 들어, 그림과 같은 경우엔 3개(6번, 3번, 2번)의 막대기가 보인다. N개의 막대기에 대한 높이 정보가 주어질 때, 오른쪽에서 보아서 몇 개가 보이는지를 알아내는 프로그램을 작성하려고 한다. 입력첫 번째 줄에는 막대기의 개수를 나타내는 정수 N (2 ≤ N ≤ 100,000)이 주어지고 이어지는 N줄 각각에는 막대기의 높이를 나타내는 정수 h(1 ≤ h ≤ 100,000)가 주어진다. 출력오른쪽에서 N개의 막대기를 보았을 때, 보이는 막대기의 개수를 출력한다. 예제 입력 112345676697646 예제 출력 113 예제 입력 2123456554321 예제 출력 215 출처 Olympiad &gt; 한국정보올림피아드 &gt; KOI 2019 1차대회 &gt; 초등부 1번 알고리즘 분류 구현 자료 구조 스택 소스코드123456789101112131415161718import sysinput = sys.stdin.readlineN = int(input())stack = [int(input()) for _ in range(N)]max_height = 0cnt = 0while stack: temp = stack.pop() if temp &gt; max_height: max_height = temp cnt += 1print(cnt)","link":"/categories/Algorithm/Python/BAEKJOON-17608-21-07-08/"},{"title":"[백준] 1789번 수들의 합","text":"출처: [백준] 1789번 수들의 합 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 16089 6719 5652 43.201% 문제서로 다른 N개의 자연수의 합이 S라고 한다. S를 알 때, 자연수 N의 최댓값은 얼마일까? 입력첫째 줄에 자연수 S(1 ≤ S ≤ 4,294,967,295)가 주어진다. 출력첫째 줄에 자연수 N의 최댓값을 출력한다. 예제 입력 11200 예제 출력 1119 출처 문제를 만든 사람: author5 데이터를 추가한 사람: newton08, upple1 알고리즘 분류 수학 그리디 알고리즘 소스코드1234567891011121314151617import sysinput = sys.stdin.readlineS = int(input())N, i = 0, 1while True: N += i if N &gt; S: print(i - 1) break elif N == S: print(i) break i += 1","link":"/categories/Algorithm/Python/BAEKJOON-1789-21-08-03/"},{"title":"[백준] 1780번 종이의 개수","text":"출처: [백준] 1780번 종이의 개수 문제N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1의 세 값 중 하나가 저장되어 있다. 우리는 이 행렬을 적절한 크기로 자르려고 하는데, 이때 다음의 규칙에 따라 자르려고 한다. 만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다. (1)이 아닌 경우에는 종이를 같은 크기의 9개의 종이로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다. 이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.입력 첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다. 두 번째 줄부터는 길이 N의 문자열이 N개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다. 입력첫째 줄에 N(1 ≤ N ≤ 37, N은 3k 꼴)이 주어진다. 다음 N개의 줄에는 N개의 정수로 행렬이 주어진다. 출력첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다. 예제 입력 11234567891090 0 0 1 1 1 -1 -1 -10 0 0 1 1 1 -1 -1 -10 0 0 1 1 1 -1 -1 -11 1 1 0 0 0 0 0 01 1 1 0 0 0 0 0 01 1 1 0 0 0 0 0 00 1 -1 0 1 -1 0 1 -10 -1 1 0 1 -1 0 1 -10 1 -1 1 0 -1 0 1 -1 예제 출력 1123101211 힌트 출처 문제를 만든 사람: author5 데이터를 추가한 사람: djm03178, upsk1 잘못된 데이터를 찾은 사람: tncks0121 알고리즘 분류 분할 정복 재귀 시간 제한 풀이 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546import sysinput = sys.stdin.readlineN = int(input())paper_list = [list(map(int, input().split())) for _ in range(N)]result = []def check_same(x, y, d): paper = paper_list[x][y] for i in range(x, x + d): for j in range(y, y + d): if paper_list[i][j] != paper: return False return Truedef solution(x, y, d): if check_same(x, y, d): if paper_list[x][y] == 1: result.append(1) elif paper_list[x][y] == 0: result.append(0) elif paper_list[x][y] == -1: result.append(-1) else: d //= 3 solution(x, y, d) solution(x + d, y, d) solution(x + 2 * d, y, d) solution(x, y + d, d) solution(x + d, y + d, d) solution(x + 2 * d, y + d, d) solution(x, y + 2 * d, d) solution(x + d, y + 2 * d, d) solution(x + 2 * d, y + 2 * d, d)solution(0, 0, N)print(result.count(-1))print(result.count(0))print(result.count(1))","link":"/categories/Algorithm/Python/BAEKJOON-1780-21-04-01/"},{"title":"[백준] 17952번 과제는 끝나지 않아!","text":"출처: [백준] 17952번 과제는 끝나지 않아! 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 256 MB 1518 645 523 44.854% 문제성애는 이번 학기에 전공을 정말 많이 듣는다. 이로 인해 거의 매일을 과제를 하면서 보내고 있다. 그런데도 과제가 줄어들 기미가 보이지 않는데, 바로 분단위로 과제가 추가되고 있기 때문이다. 다행히 과제 제출 기한은 학기가 끝날 때까지이다. 너무나도 많은 과제를 하다가 미쳐버린 성애는 아래와 같은 규칙으로 과제를 해 나가고 있다. 과제는 가장 최근에 나온 순서대로 한다. 또한 과제를 받으면 바로 시작한다. 과제를 하던 도중 새로운 과제가 나온다면, 하던 과제를 중단하고 새로운 과제를 진행한다. 새로운 과제가 끝났다면, 이전에 하던 과제를 이전에 하던 부분부터 이어서 한다. (성애는 기억력이 좋기 때문에 아무리 긴 시간이 지나도 본인이 하던 부분을 기억할 수 있다.) 성애는 과제를 받자마자 이 과제가 몇 분이 걸릴지 정확하게 알 수 있고, 성애가 제출한 과제는 무조건 만점을 받는다. 성애는 이번 학기에 자기가 받을 과제 점수를 예상해보고 싶다. 하지만 과제 점수를 예상하는 지금도 과제가 추가되고 있기에 여유를 부릴 수가 없다. 여러분이 성애가 받을 과제 점수를 구해주자! 입력첫째 줄에 이번 학기가 몇 분인지를 나타내는 정수 N이 주어진다. (1 ≤ N ≤ 1,000,000) 두번째 줄부터 N줄 동안은 학기가 시작하고 N분째에 주어진 과제의 정보가 아래의 두 경우 중 하나로 주어진다. 1 A T: 과제의 만점은 A점이고, 성애가 이 과제를 해결하는데 T분이 걸린다. A와 T는 모두 정수이다. (1 ≤ A ≤ 100, 1 ≤ T ≤ 1,000,000) 0: 해당 시점에는 과제가 주어지지 않았다. 출력성애가 받을 과제 점수를 출력한다. 예제 입력 1123431 100 300 예제 출력 11100 1분째: 100점짜리 과제 1이 주어지고 이 과제를 하는데 3분이 걸린다. 과제를 받자마자 시작했으므로 과제 1이 끝나는데는 이제 2분 남았다. 2분째: 새로운 과제가 주어지지 않았으므로 과제 1을 이어서 한다. 3분째: 새로운 과제가 주어지지 않았으므로 과제 1을 이어서 한다. 이 시점에 과제 1이 끝나서 100점을 획득한다. 예제 입력 212345651 10 301 100 21 20 10 예제 출력 21120 1분째 : 과제 1이 나왔고, 받자마자 바로 시작했으므로 과제 1이 끝나기까지 2분 남았다. 2분째 : 새로운 과제가 나오지 않았으므로 과제 1을 이어서 한다. 3분째 : 과제 2가 나왔고, 받자마자 바로 시작했으므로, 과제 2가 끝나기까지 1분 남았다. 4분째 : 과제 3이 나왔고, 받자마자 바로 시작했으므로, 과제 3을 끝내서 20점을 얻는다. 5분째 : 새로운 과제가 나오지 않았으므로 이전에 하던 과제 2를 이어서 하고, 과제 2를 끝내서 100점을 얻는다. 출처 University &gt; 한양대학교 &gt; 제6회 한양대학교 프로그래밍 경시대회 Beginner Division A번 University &gt; 한양대학교 &gt; 제6회 한양대학교 프로그래밍 경시대회 Advanced Division A번 데이터를 추가한 사람: hayman42 문제를 만든 사람: pch6828 알고리즘 분류 구현 자료 구조 스택 소스코드1234567891011121314151617181920212223242526import sysinput = sys.stdin.readlineN = int(input())# 1 A T: 과제O, 점수, 걸린 시간work_list = []score = 0for _ in range(N): info = list(map(int, input().split())) if info[0] == 1: # 과제를 받았으면 if info[2] - 1 &gt; 0: work_list.append((info[1], info[2] - 1)) else: score += info[1] else: # 과제가 없으면 if work_list: work = work_list.pop() if work[1] - 1 &gt; 0: work_list.append((work[0], work[1] - 1)) else: score += work[0]print(score)","link":"/categories/Algorithm/Python/BAEKJOON-17952-21-07-13/"},{"title":"[백준] 1783번 병든 나이트","text":"출처: [백준] 1783번 병든 나이트 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 8302 3576 3048 42.827% 문제병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다. 2칸 위로, 1칸 오른쪽 1칸 위로, 2칸 오른쪽 1칸 아래로, 2칸 오른쪽 2칸 아래로, 1칸 오른쪽 병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다. 체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자. 입력첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다. 출력병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다. 예제 입력 11100 50 예제 출력 1148 예제 입력 211 1 예제 출력 211 예제 입력 3117 5 예제 출력 314 예제 입력 412 4 예제 출력 412 예제 입력 5120 4 예제 출력 514 출처 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: gudori888, han1g, jh05013, luluctrl4, shnoh 알고리즘 분류 구현 그리디 알고리즘 많은 조건 분기 소스코드12345678910111213141516171819import sysinput = sys.stdin.readlineN, M = map(int, input().split())# 4가지 모두 이용하려면, M&gt;6count = 0if N == 1: count = 1elif N == 2: # 세로가 2이면, 2번/3번 방법만 사용가능 --&gt; 오른쪽으로 두칸씩 count = min(4, (M + 1) // 2)elif M &lt; 7: # N&gt;=3, M&lt;7 --&gt; 오른쪽으로 한칸씩 count = min(4, M)else: # N&gt;=3, M&gt;7 --&gt; 2,3번 한번 나머지 1,4번 count = M - 2print(count)","link":"/categories/Algorithm/Python/BAEKJOON-1783-21-08-05/"},{"title":"[백준] 18115번 카드 놓기","text":"출처: [백준] 18115번 카드 놓기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 (추가 시간 없음) 1024 MB 723 403 314 57.615% 문제수현이는 카드 기술을 연습하고 있다. 수현이의 손에 들린 카드를 하나씩 내려놓아 바닥에 쌓으려고 한다. 수현이가 쓸 수 있는 기술은 다음 3가지다. 제일 위의 카드 1장을 바닥에 내려놓는다. 위에서 두 번째 카드를 바닥에 내려놓는다. 카드가 2장 이상일 때만 쓸 수 있다. 제일 밑에 있는 카드를 바닥에 내려놓는다. 카드가 2장 이상일 때만 쓸 수 있다. 수현이는 처음에 카드 N장을 들고 있다. 카드에는 1부터 N까지의 정수가 중복되지 않게 적혀 있다. 기술을 N번 사용하여 카드를 다 내려놓았을 때, 놓여 있는 카드들을 확인했더니 위에서부터 순서대로 1, 2, …, N이 적혀 있었다! 놀란 수현이는 처음에 카드가 어떻게 배치되어 있었는지 궁금해졌다. 처음 카드의 상태를 출력하여라. 입력첫 번째 줄에는 N (1 ≤ N ≤ 106)이 주어진다. 두 번째 줄에는 길이가 N인 수열 A가 주어진다. Ai가 x이면, i번째로 카드를 내려놓을 때 x번 기술을 썼다는 뜻이다. Ai는 1, 2, 3 중 하나이며, An은 항상 1이다. 출력초기 카드의 상태를 위에서부터 순서대로 출력하여라. 예제 입력 11251 1 1 1 1 예제 출력 115 4 3 2 1 예제 입력 21252 3 3 2 1 예제 출력 211 5 2 3 4 출처 University &gt; 서강대학교 &gt; 2019 Sogang Programming Contest (Champion) C번 문제를 검수한 사람: jh05013, shiftpsh 문제를 만든 사람: semteo04 알고리즘 분류 자료 구조 덱 풀이1234반대로1) 맨위의 카드를 바닥으로2) 맨위의 카드를 바닥에서 2번째로3) 맨위의 카드를 맨위로 소스코드12345678910111213141516171819202122import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())card_list = deque(range(1, N + 1))commands = list(map(int, input().split()))init_list = deque()while commands: command = commands.pop() temp = card_list.popleft() if command == 1: init_list.appendleft(temp) elif command == 2: init_list.insert(1, temp) elif command == 3: init_list.append(temp)print(*init_list)","link":"/categories/Algorithm/Python/BAEKJOON-18115-21-07-26/"},{"title":"[백준] 18258번 큐2","text":"출처: [백준] 18258번 큐2 문제정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오. 명령은 총 여섯 가지이다. push X: 정수 X를 큐에 넣는 연산이다. pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 큐에 들어있는 정수의 개수를 출력한다. empty: 큐가 비어있으면 1, 아니면 0을 출력한다. front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다. back: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다. 입력첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 2,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다. 출력출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다. 예제 입력 11234567891011121314151615push 1push 2frontbacksizeemptypoppoppopsizeemptypoppush 3emptyfront 예제 출력 1123456789101112122012-101-103 힌트 출처 문제를 만든 사람: jh05013 알고리즘 분류 자료 구조 큐 시간 제한 Python 3: 3 초 PyPy3: 3 초 Python 2: 3 초 PyPy2: 3 초 풀이 소스코드123456789101112131415161718192021222324252627282930313233import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())q = deque([])for _ in range(N): command = input().split() if command[0] == 'push': q.append(command[1]) elif command[0] == 'pop': if not q: print(-1) else: print(q.popleft()) elif command[0] == 'size': print(len(q)) elif command[0] == 'empty': if not q: print(1) else: print(0) elif command[0] == 'front': if not q: print(-1) else: print(q[0]) elif command[0] == 'back': if not q: print(-1) else: print(q[-1])","link":"/categories/Algorithm/Python/BAEKJOON-18258-21-03-23/"},{"title":"[백준] 18868번 멀티버스Ⅰ","text":"출처: [백준] 18868번 멀티버스Ⅰ 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 (추가 시간 없음) 512 MB 882 494 293 62.876% 문제M개의 우주가 있고, 각 우주에는 1부터 N까지 번호가 매겨진 행성이 N개 있다. 행성의 크기를 알고 있을때, 균등한 우주의 쌍이 몇 개인지 구해보려고 한다. 구성이 같은데 순서만 다른 우주의 쌍은 한 번만 센다. 두 우주 A와 B가 있고, 우주 A에 있는 행성의 크기는 A1, A2, …, AN, 우주 B에 있는 행성의 크기는 B1, B2, …, BN라고 하자. 두 우주의 행성 크기가 모든 1 ≤ i, j ≤ N에 대해서 아래와 같은 조건을 만족한다면, 두 우주를 균등하다고 한다. Ai &lt; Aj → Bi &lt; Bj Ai = Aj → Bi = Bj Ai &gt; Aj → Bi &gt; Bj 입력첫째 줄에 우주의 개수 M과 각 우주에 있는 행성의 개수 N이 주어진다. 둘째 줄부터 M개의 줄에 공백으로 구분된 행성의 크기가 한 줄에 하나씩 1번 우주부터 차례대로 주어진다. 출력첫째 줄에 균등한 우주의 쌍의 개수를 출력한다. 제한 2 ≤ M ≤ 10 3 ≤ N ≤ 100 1 ≤ 행성의 크기 ≤ 10,000 예제 입력 11232 31 3 212 50 31 예제 출력 111 (A, B) = (1, 2) A1 = 1 &lt; A2 = 3 이고, B1 = 12 &lt; B2 = 50 A1 = 1 &lt; A3 = 2 이고, B1 = 12 &lt; B3 = 31 A2 = 3 &gt; A3 = 2 이고, B2 = 50 &gt; B3 = 31 모든 1 ≤ i, j ≤ N에 대해서 만족한다. 예제 입력 21232 31 3 212 50 10 예제 출력 210 (A, B) = (1, 2) A1 = 1 &lt; A3 = 2 인데, B1 = 12 &gt; B3 = 10이다. 모든 1 ≤ i, j ≤ N에 대해서 만족하지 않는다. 예제 입력 31234565 320 10 3010 20 6080 25 7930 50 8080 25 81 예제 출력 312 1번과 5번 우주, 2번과 4번 우주가 균등하다. 힌트 출처 데이터를 추가한 사람: akaishuichi 문제를 만든 사람: baekjoon 알고리즘 분류 브루트포스 알고리즘 정렬 시간 제한 풀이 소스코드123456789101112131415161718192021222324import sysinput = sys.stdin.readlineM, N = map(int, input().split())space_list = [list(map(int, input().split())) for _ in range(M)]new_space_list = [[] for _ in range(M)]dictionary = {}for i in range(M): new_list = sorted(list(set(space_list[i]))) for j in range(len(new_list)): dictionary[new_list[j]] = j for x in (space_list[i]): new_space_list[i].append(dictionary[x])count = 0for i in range(M - 1): for j in range(i + 1, M): if new_space_list[i] == new_space_list[j]: count += 1print(count)","link":"/categories/Algorithm/Python/BAEKJOON-18868-21-04-11/"},{"title":"[백준] 18869번 멀티버스Ⅱ","text":"출처: [백준] 18869번 멀티버스Ⅱ 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 (추가 시간 없음) 512 MB 292 85 64 46.715% 문제M개의 우주가 있고, 각 우주에는 1부터 N까지 번호가 매겨진 행성이 N개 있다. 행성의 크기를 알고 있을때, 균등한 우주의 쌍이 몇 개인지 구해보려고 한다. 구성이 같은데 순서만 다른 우주의 쌍은 한 번만 센다. 두 우주 A와 B가 있고, 우주 A에 있는 행성의 크기는 A1, A2, …, AN, 우주 B에 있는 행성의 크기는 B1, B2, …, BN라고 하자. 두 우주의 행성 크기가 모든 1 ≤ i, j ≤ N에 대해서 아래와 같은 조건을 만족한다면, 두 우주를 균등하다고 한다. Ai &lt; Aj → Bi &lt; Bj Ai = Aj → Bi = Bj Ai &gt; Aj → Bi &gt; Bj 입력첫째 줄에 우주의 개수 M과 각 우주에 있는 행성의 개수 N이 주어진다. 둘째 줄부터 M개의 줄에 공백으로 구분된 행성의 크기가 한 줄에 하나씩 1번 우주부터 차례대로 주어진다. 출력첫째 줄에 균등한 우주의 쌍의 개수를 출력한다. 제한 2 ≤ M ≤ 100 3 ≤ N ≤ 10,000 1 ≤ 행성의 크기 ≤ 1,000,000 예제 입력 11232 31 3 212 50 31 예제 출력 111 (A, B) = (1, 2) A1 = 1 &lt; A2 = 3 이고, B1 = 12 &lt; B2 = 50 A1 = 1 &lt; A3 = 2 이고, B1 = 12 &lt; B3 = 31 A2 = 3 &gt; A3 = 2 이고, B2 = 50 &gt; B3 = 31 모든 1 ≤ i, j ≤ N에 대해서 만족한다. 예제 입력 21232 31 3 212 50 10 예제 출력 210 (A, B) = (1, 2) A1 = 1 &lt; A3 = 2 인데, B1 = 12 &gt; B3 = 10이다. 모든 1 ≤ i, j ≤ N에 대해서 만족하지 않는다. 예제 입력 31234565 320 10 3010 20 6080 25 7930 50 8080 25 81 예제 출력 312 1번과 5번 우주, 2번과 4번 우주가 균등하다. 힌트 출처 데이터를 추가한 사람: akaishuichi 문제를 만든 사람: baekjoon 알고리즘 분류 정렬 값 / 좌표 압축 시간 제한 풀이 소스코드1234567891011121314151617181920212223242526272829import sysinput = sys.stdin.readlineM, N = map(int, input().split())space_list = [list(map(int, input().split())) for _ in range(M)]new_space_list = [[] for _ in range(M)]dictionary = {}for i in range(M): new_list = sorted(list(set(space_list[i]))) for j in range(len(new_list)): dictionary[new_list[j]] = j for x in (space_list[i]): new_space_list[i].append(dictionary[x])new_space_list.sort()cnt, ans = 1, 0for i in range(1, M): if new_space_list[i] == new_space_list[i - 1]: cnt += 1 else: ans += cnt * (cnt - 1) // 2 cnt = 1ans += cnt * (cnt - 1) // 2print(ans)","link":"/categories/Algorithm/Python/BAEKJOON-18869-21-04-11/"},{"title":"[백준] 1874번 스택 수열","text":"출처: [백준] 1874번 스택 수열 문제스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다. 1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라. 입력첫 줄에 n (1 ≤ n ≤ 100,000)이 주어진다. 둘째 줄부터 n개의 줄에는 수열을 이루는 1이상 n이하의 정수가 하나씩 순서대로 주어진다. 물론 같은 정수가 두 번 나오는 일은 없다. 출력입력된 수열을 만들기 위해 필요한 연산을 한 줄에 한 개씩 출력한다. push연산은 +로, pop 연산은 -로 표현하도록 한다. 불가능한 경우 NO를 출력한다. 예제 입력 1123456789843687521 예제 출력 112345678910111213141516++++--++-++----- 예제 입력2123456512534 예제 출력21NO 힌트1부터 n까지에 수에 대해 차례로 [push, push, push, push, pop, pop, push, push, pop, push, push, pop, pop, pop, pop, pop] 연산을 수행하면 수열 [4, 3, 6, 8, 7, 5, 2, 1]을 얻을 수 있다. 출처 문제를 만든 사람: author5 문제의 오타를 찾은 사람: bgjuw12 데이터를 추가한 사람: djm03178 알고리즘 분류 자료 구조 스택 시간 제한 풀이 소스코드1234567891011121314151617181920212223242526272829import sysinput = sys.stdin.readlineN = int(input())stack = []count = 0result = []flag = 1for i in range(N): temp = int(input()) while count &lt; temp: count += 1 stack.append(count) result.append('+') if stack[-1] == temp: stack.pop() result.append('-') else: flag = 0 print('NO') breakif flag: print('\\n'.join(result))","link":"/categories/Algorithm/Python/BAEKJOON-1874-21-03-29/"},{"title":"[백준] 18870번 좌표 압축","text":"출처: [백준] 18870번 좌표 압축 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 512 MB 4416 2398 1774 55.042% 문제수직선 위에 N개의 좌표 X1, X2, …, XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다. Xi를 좌표 압축한 결과 X’i의 값은 Xi &gt; Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다. X1, X2, …, XN에 좌표 압축을 적용한 결과 X’1, X’2, …, X’N를 출력해보자. 입력첫째 줄에 N이 주어진다. 둘째 줄에는 공백 한 칸으로 구분된 X1, X2, …, XN이 주어진다. 출력첫째 줄에 X’1, X’2, …, X’N을 공백 한 칸으로 구분해서 출력한다. 제한 1 ≤ N ≤ 1,000,000 -109 ≤ Xi ≤ 109 예제 입력 11252 4 -10 4 -9 예제 출력 112 3 0 3 1 예제 입력 21261000 999 1000 999 1000 999 예제 출력 211 0 1 0 1 0 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 정렬 값 / 좌표 압축 시간 제한 풀이 소스코드12345678910111213141516import sysinput = sys.stdin.readlineN = int(input())coord_list = list(map(int, input().split()))new_list = sorted(list(set(coord_list)))d = {}for i in range(len(new_list)): d[new_list[i]] = ifor i in coord_list: print(d[i], end=&quot; &quot;)","link":"/categories/Algorithm/Python/BAEKJOON-18870-21-04-10/"},{"title":"[백준] 1912번 연속합 with Python","text":"출처: [백준] 1912번 연속합 문제n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다. 예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다. 입력첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다. 출력첫째 줄에 답을 출력한다. 예제 입력 1121010 -4 3 1 5 6 -35 12 21 -1 예제 출력 1133 예제 입력 212102 1 -4 3 4 -4 6 5 -5 1 예제 출력 2114 예제 입력 3125-1 -2 -3 -4 -5 예제 출력 31-1 힌트 출처 데이터를 추가한 사람: djm03178, dohyeokkim, doju, jh05013, kimdr123, seedkin 빠진 조건을 찾은 사람: isac322, Qwaz 문제의 오타를 찾은 사람: jh05013 잘못된 데이터를 찾은 사람: tncks0121 알고리즘 분류 다이나믹 프로그래밍 풀이 소스코드12345678910111213import sysinput = sys.stdin.readlineN = int(input())num_list = list(map(int, input().split()))dp = [num_list[0]]for i in range(N - 1): dp.append(max(dp[i] + num_list[i + 1], num_list[i + 1]))print(max(dp))","link":"/categories/Algorithm/Python/BAEKJOON-1912-21-03-22/"},{"title":"[백준] 1913번 달팽이","text":"출처: [백준] 1913번 달팽이 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 6337 3430 2684 55.045% 문제홀수인 자연수 N이 주어지면, 다음과 같이 1부터 N2까지의 자연수를 달팽이 모양으로 N×N의 표에 채울 수 있다. 9 2 3 8 1 4 7 6 5 25 10 11 12 13 24 9 2 3 14 23 8 1 4 15 22 7 6 5 16 21 20 19 18 17 N이 주어졌을 때, 이러한 표를 출력하는 프로그램을 작성하시오. 또한 N2 이하의 자연수가 하나 주어졌을 때, 그 좌표도 함께 출력하시오. 예를 들어 N=5인 경우 6의 좌표는 (4,3)이다. 입력첫째 줄에 홀수인 자연수 N(3 ≤ N ≤ 999)이 주어진다. 둘째 줄에는 위치를 찾고자 하는 N2 이하의 자연수가 하나 주어진다. 출력N개의 줄에 걸쳐 표를 출력한다. 각 줄에 N개의 자연수를 한 칸씩 띄어서 출력하면 되며, 자릿수를 맞출 필요가 없다. N+1번째 줄에는 입력받은 자연수의 좌표를 나타내는 두 정수를 한 칸 띄어서 출력한다. 예제 입력 112735 예제 출력 11234567849 26 27 28 29 30 3148 25 10 11 12 13 3247 24 9 2 3 14 3346 23 8 1 4 15 3445 22 7 6 5 16 3544 21 20 19 18 17 3643 42 41 40 39 38 375 7 출처 문제를 만든 사람: author5 알고리즘 분류 구현 소스코드12345678910111213141516171819202122232425262728293031323334353637import sysinput = sys.stdin.readlineN = int(input())M = int(input())snail = [[0 for _ in range(N)] for _ in range(N)]move = [(1, 0), (0, 1), (-1, 0), (0, -1)] # 하, 우, 상, 좌cur_num = N ** 2cur_x, cur_y = 0, 0direction = 0while cur_num &gt; 0: snail[cur_y][cur_x] = cur_num ny, nx = move[direction] dx = cur_x + nx dy = cur_y + ny if 0 &gt; dx or dx &gt;= N or 0 &gt; dy or dy &gt;= N or snail[dy][dx] != 0: # 갈 수 없는 곳만 (방문했던 곳X, 벽X) direction = (direction + 1) % 4 ny, nx = move[direction] cur_x += nx cur_y += ny cur_num -= 1temp_x, temp_y = 0, 0for i in range(N): for j in range(N): if snail[i][j] == M: temp_x = j temp_y = i print(snail[i][j], end=&quot; &quot;) print()print(temp_y + 1, temp_x + 1)","link":"/categories/Algorithm/Python/BAEKJOON-1913-21-06-22/"},{"title":"[백준] 1935번 후위 표기식2","text":"출처: [백준] 1935번 후위 표기식2 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 8614 4004 3204 46.549% 문제후위 표기식과 각 피연산자에 대응하는 값들이 주어져 있을 때, 그 식을 계산하는 프로그램을 작성하시오. 입력첫째 줄에 피연산자의 개수(1 ≤ N ≤ 26) 가 주어진다. 그리고 둘째 줄에는 후위 표기식이 주어진다. (여기서 피연산자는 A~Z의 영대문자이며, A부터 순서대로 N개의 영대문자만이 사용되며, 길이는 100을 넘지 않는다) 그리고 셋째 줄부터 N+2번째 줄까지는 각 피연산자에 대응하는 값이 주어진다. (3번째 줄에는 A에 해당하는 값, 4번째 줄에는 B에 해당하는값 , 5번째 줄에는 C …이 주어진다, 그리고 피연산자에 대응 하는 값은 정수이다) 출력계산 결과를 소숫점 둘째 자리까지 출력한다. 예제 입력 112345675ABC*+DE/-12345 예제 출력 116.20 예제 입력 21231AA+A+1 예제 출력 213.00 출처 데이터를 추가한 사람: arine 빠진 조건을 찾은 사람: ljk0411jg 문제의 오타를 찾은 사람: masioka, whtjddjs0723 알고리즘 분류 자료 구조 스택 소스코드1234567891011121314151617181920212223242526import sysinput = sys.stdin.readlineN = int(input())postfix = input().rstrip()num_list = [int(input()) for _ in range(N)]stack = []for element in postfix: if 'A' &lt;= element &lt;= 'Z': stack.append(num_list[ord(element) - ord('A')]) else: num2, num1 = stack.pop(), stack.pop() if element == '+': stack.append(num1 + num2) elif element == '-': stack.append(num1 - num2) elif element == '*': stack.append(num1 * num2) elif element == '/': stack.append(num1 / num2)print('%.2f' % stack[0])","link":"/categories/Algorithm/Python/BAEKJOON-1935-21-07-12/"},{"title":"[백준] 1966번 프린터 큐","text":"출처: [백준] 1966번 프린터 큐 문제여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다. 현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다. 나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다. 예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다. 여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다. 입력첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다. 테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M &lt; N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다. 출력각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다. 예제 입력 1123456731 054 21 2 3 46 01 1 9 1 1 1 예제 출력 1123125 힌트 출처 ICPC &gt; Regionals &gt; Europe &gt; Northwestern European Regional Contest &gt; NWERC 2006 F번 문제의 오타를 찾은 사람: doju 어색한 표현을 찾은 사람: iiwwnnaa, jh05013 링크 알고리즘 분류 구현 자료 구조 시뮬레이션 큐 시간 제한 풀이 소스코드1234567891011121314151617181920212223242526272829import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): N, M = map(int, input().split()) priority_list = list(map(int, input().split())) docs_list = list(range(len(priority_list))) docs_list[M] = 'target' order = 0 while True: num = priority_list[0] if num == max(priority_list): order += 1 if docs_list[0] == 'target': print(order) break else: priority_list.pop(0) docs_list.pop(0) else: priority_list.append(priority_list.pop(0)) docs_list.append(docs_list.pop(0))","link":"/categories/Algorithm/Python/BAEKJOON-1966-21-03-24/"},{"title":"[백준] 1987번 알파벳","text":"출처: [백준] 1987번 알파벳 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 256 MB 49798 15713 9586 29.155% 문제세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다. 말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다. 좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다. 입력첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다. 출력첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다. 예제 입력 11232 4CAABADCB 예제 출력 113 기타 입력12343 4ABBCECEDFGDH 기타 출력18 출처Olympiad &gt; Croatian Highschool Competitions in Informatics &gt; 2002 &gt; Regional Competition - Juniors 3번 데이터를 추가한 사람: august14, doju, jh05013 링크 PKU Judge Online 알고리즘 분류 그래프 이론 그래프 탐색 깊이 우선 탐색 백트래킹 풀이 소스코드_DFS1234567891011121314151617181920212223242526272829import sysinput = sys.stdin.readlinedx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]def dfs(x, y, count): global ans ans = max(ans, count) for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; R and 0 &lt;= ny &lt; C and passed[board[nx][ny]] == 0: passed[board[nx][ny]] = 1 dfs(nx, ny, count + 1) passed[board[nx][ny]] = 0R, C = map(int, input().split())board = [list(map(lambda x: ord(x) - 65, input().rstrip())) for _ in range(R)]passed = [0] * 26ans = 1passed[board[0][0]] = 1dfs(0, 0, ans)print(ans) 소스코드_BFS123456789101112131415161718192021222324252627282930import sysinput = sys.stdin.readlinedx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]def bfs(): global count queue = set() queue.add((0, 0, board[0][0])) while queue: x, y, ans = queue.pop() for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; R and 0 &lt;= ny &lt; C and board[nx][ny] not in ans: queue.add((nx, ny, ans + board[nx][ny])) count = max(count, len(ans) + 1)R, C = map(int, input().split())board = [list(input().rstrip()) for _ in range(R)]count = 1bfs()print(count) 소스코드_실패(메모리 초과)123456789101112131415161718192021222324252627282930import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readlinedx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]def dfs(x, y, cnt): global count count = max(cnt, count) for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; R and 0 &lt;= ny &lt; C and board[nx][ny] not in passed: passed.append(board[nx][ny]) dfs(nx, ny, cnt + 1) passed.append(board[nx][ny])R, C = map(int, input().split())board = [list(input().rstrip()) for _ in range(R)]passed = []count = 1dfs(0, 0, count)print(count)","link":"/categories/Algorithm/Python/BAEKJOON-1987-21-04-27/"},{"title":"[백준] 1992번 쿼드트리","text":"출처: [백준] 1992번 쿼드트리 문제흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다. 주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 “0”이 되고, 모두 1로만 되어 있으면 압축 결과는 “1”이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다 위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 “(0(0011)(0(0111)01)1)“로 표현된다. N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오. 입력첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다. 두 번째 줄부터는 길이 N의 문자열이 N개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다. 출력영상을 압축한 결과를 출력한다. 예제 입력 112345678981111000011110000000111000001110011110000111100001111001111110011 예제 출력 11((110(0101))(0010)1(0001)) 힌트 출처 알고리즘 분류 분할 정복 재귀 시간 제한 풀이 소스코드12345678910111213141516171819202122232425262728293031323334353637383940import sysinput = sys.stdin.readlineN = int(input())pixel_list = [list(map(int, input().rstrip())) for _ in range(N)]result = []def check_same(x, y, d): pixel = pixel_list[x][y] for i in range(x, x + d): for j in range(y, y + d): if pixel_list[i][j] != pixel: return False return Truedef solution(x, y, d): if check_same(x, y, d): if pixel_list[x][y]: result.append(1) else: result.append(0) else: d //= 2 result.append('(') solution(x, y, d) solution(x, y + d, d) solution(x + d, y, d) solution(x + d, y + d, d) result.append(')')solution(0, 0, N)for x in result: print(x, end=&quot;&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-1992-21-04-01/"},{"title":"[백준] 1991번 트리 순회","text":"출처: [백준] 1991번 트리 순회 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 25295 15857 12064 63.929% 문제이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오. 예를 들어 위와 같은 이진 트리가 입력되면, 전위 순회한 결과 : ABDCEFG // (루트) (왼쪽 자식) (오른쪽 자식) 중위 순회한 결과 : DBAECFG // (왼쪽 자식) (루트) (오른쪽 자식) 후위 순회한 결과 : DBEGFCA // (왼쪽 자식) (오른쪽 자식) (루트) 가 된다. 입력첫째 줄에는 이진 트리의 노드의 개수 N(1≤N≤26)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 노드와 그의 왼쪽 자식 노드, 오른쪽 자식 노드가 주어진다. 노드의 이름은 A부터 차례대로 영문자 대문자로 매겨지며, 항상 A가 루트 노드가 된다. 자식 노드가 없는 경우에는 .으로 표현된다. 출력첫째 줄에 전위 순회, 둘째 줄에 중위 순회, 셋째 줄에 후위 순회한 결과를 출력한다. 각 줄에 N개의 알파벳을 공백 없이 출력하면 된다. 예제 입력 1123456787A B CB D .C E FE . .F . GD . .G . . 예제 출력 1123ABDCEFGDBAECFGDBEGFCA 출처- 알고리즘 분류 트리 재귀 소스코드123456789101112131415161718192021222324252627282930313233343536373839import sysinput = sys.stdin.readlineN = int(input())tree = {}for _ in range(N): root, left, right = input().rstrip().split() tree[root] = [left, right]def preorder(root): if root != '.': print(root, end='') preorder(tree[root][0]) preorder(tree[root][1])def inorder(root): if root != '.': inorder(tree[root][0]) print(root, end='') inorder(tree[root][1])def postorder(root): if root != '.': postorder(tree[root][0]) postorder(tree[root][1]) print(root, end='')preorder('A')print()inorder('A')print()postorder('A')","link":"/categories/Algorithm/Python/BAEKJOON-1991-21-07-06/"},{"title":"[백준] 2002번 추월","text":"출처: [백준] 2002번 추월 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 2040 894 757 44.766% 문제대한민국을 비롯한 대부분의 나라에서는 터널 내에서의 차선 변경을 법률로 금하고 있다. 조금만 관찰력이 있는 학생이라면 터널 내부에서는 차선이 파선이 아닌 실선으로 되어 있다는 것을 알고 있을 것이다. 이는 차선을 변경할 수 없음을 말하는 것이고, 따라서 터널 내부에서의 추월은 불가능하다. 소문난 명콤비 경찰 대근이와 영식이가 추월하는 차량을 잡기 위해 한 터널에 투입되었다. 대근이는 터널의 입구에, 영식이는 터널의 출구에 각각 잠복하고, 대근이는 차가 터널에 들어가는 순서대로, 영식이는 차가 터널에서 나오는 순서대로 각각 차량 번호를 적어 두었다. N개의 차량이 지나간 후, 대근이와 영식이는 자신들이 적어 둔 차량 번호의 목록을 보고, 터널 내부에서 반드시 추월을 했을 것으로 여겨지는 차들이 몇 대 있다는 것을 알게 되었다. 대근이와 영식이를 도와 이를 구하는 프로그램을 작성해 보자. 입력입력은 총 2N+1개의 줄로 이루어져 있다. 첫 줄에는 차의 대수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 대근이가 적은 차량 번호 목록이 주어지고, N+2째 줄부터 N개의 줄에는 영식이가 적은 차량 번호 목록이 주어진다. 각 차량 번호는 6글자 이상 8글자 이하의 문자열로, 영어 대문자(‘A’-‘Z’)와 숫자(‘0’-‘9’)로만 이루어져 있다. 같은 차량 번호가 두 번 이상 주어지는 경우는 없다. 출력첫째 줄에 터널 내부에서 반드시 추월을 했을 것으로 여겨지는 차가 몇 대인지 출력한다. 예제 입력 11234567894ZG431SNZG5080KST123DZG206AZG206AZG431SNZG5080KST123D 예제 출력 111 예제 입력 212345678910115ZG508OKPU305ARI604BZG206AZG232ZFPU305AZG232ZFZG206AZG508OKRI604B 예제 출력 213 예제 입력 312345678910115ZG206APU234QOS945CKZG431SNZG5962JZG5962JOS945CKZG206APU234QZG431SN 예제 출력 312 출처 Olympiad &gt; Croatian Highschool Competitions in Informatics &gt; 2002 &gt; National Competition #1 - Seniors 1번 빠진 조건을 찾은 사람: kipa00 문제의 오타를 찾은 사람: pppqqqpq 알고리즘 분류 구현 자료 구조 문자열 브루트포스 알고리즘 해시를 사용한 집합과 맵 소스코드123456789101112131415161718192021222324import sysinput = sys.stdin.readlineN = int(input())count = 0input_car = {}output_car = []for i in range(N): input_car[input().rstrip()] = ifor i in range(N): output_car.append(input().rstrip())for i in range(N - 1): for j in range(i + 1, N): if input_car[output_car[i]] &gt; input_car[output_car[j]]: count += 1 breakprint(count)","link":"/categories/Algorithm/Python/BAEKJOON-2002-21-07-05/"},{"title":"[백준] 20001번 고무오리 디버깅","text":"출처: [백준] 20001번 고무오리 디버깅 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 512 MB 905 557 513 68.309% 문제백준 문제 풀이에 힘들어하는 수진이를 위해 민우는 문제해결에 도움이 되는 고무오리를 준비했다. 민우가 준비한 고무오리는 신비한 능력이 존재하는데, 최근에 풀던 백준 문제를 해결해주는 능력이다. 신비한 고무오리와 함께 수진이의 백준 풀이를 도와주자! 고무오리의 사용법은 다음과 같다. “고무오리 디버깅 시작” 이라고 외친다 문제들을 풀기 시작한다 고무오리를 받으면 최근 풀던 문제를 해결한다 “고무오리 디버깅 끝” 이라고 외치면 문제풀이를 종료한다. 하지만 고무오리에는 치명적인 문제가 있는데, 풀 문제가 없는데 사용한다면 고무오리는 체벌로 두 문제를 추가한다는 점이다. 입력첫 번째 줄에 “고무오리 디버깅 시작”이라고 주어진다. 두 번째 줄부터 “고무오리” 또는 “문제”가 주어진다. 이는 “고무오리 디버깅 끝”이 주어질 때까지 반복한다. 최대 102줄이 입력으로 주어진다. 출력고무오리 디버깅이 끝날 때, 주어진 문제를 수진이가 해결하였는지 여부에 따라 남은 문제 없이 모든 문제를 해결하였으면 “고무오리야 사랑해”을 출력하고 하나라도 문제가 남았다면 “힝구”를 출력하라. 예제 입력 112345678고무오리 디버깅 시작문제고무오리문제문제고무오리고무오리고무오리 디버깅 끝 예제 출력 11고무오리야 사랑해 예제 입력 212345고무오리 디버깅 시작고무오리고무오리고무오리고무오리 디버깅 끝 예제 출력 21고무오리야 사랑해 예제 입력 312345678910111213고무오리 디버깅 시작문제문제고무오리고무오리고무오리문제고무오리문제고무오리고무오리고무오리고무오리 디버깅 끝 예제 출력 31고무오리야 사랑해 예제 입력 4123고무오리 디버깅 시작고무오리고무오리 디버깅 끝 예제 출력 41힝구 출처 University &gt; 충남대학교 &gt; 제4회 생각하는 프로그래밍 대회 A번 빠진 조건을 찾은 사람: jh05013 문제를 만든 사람: siontama 알고리즘 분류 구현 자료 구조 스택 소스코드1234567891011121314151617181920212223242526import sysinput = sys.stdin.readlinestart = input().rstrip()question = []while True: input_string = input().rstrip() if input_string == '고무오리 디버깅 끝': break else: if input_string == '문제': question.append(0) elif input_string == '고무오리': if question: question.pop() else: question.append(0) question.append(0)if question: print(&quot;힝구&quot;)else: print(&quot;고무오리야 사랑해&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-20001-21-07-14/"},{"title":"[백준] 20301번 반전 요세푸스","text":"출처: [백준] 20301번 반전 요세푸스 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 (추가 시간 없음) 1024 MB 467 248 201 54.918% 문제요세푸스 문제는 다음과 같다. 1번 사람 오른쪽에는 2번 사람이 앉아 있고, 2번 사람 오른쪽에는 3번 사람이 앉아 있고, 계속하여 같은 방식으로 N명의 사람들이 원을 이루며 앉아 있다. N번 사람 오른쪽에는 1번 사람이 앉아 있다. 이제 K(≤N)번 사람을 우선 제거하고, 이후 직전 제거된 사람의 오른쪽의 K번째 사람을 계속 제거해 나간다. 모든 사람이 제거되었을 때, 제거된 사람의 순서는 어떻게 될까? 이 문제의 답을 (N, K)–요세푸스 순열이라고 하며, (7, 3)–요세푸스 순열은 ⟨3,6,2,7,5,1,4⟩가 된다. 하지만 한 방향으로만 계속 돌아가는 건 너무 지루하다. 따라서 요세푸스 문제에 재미를 더하기 위해 M명의 사람이 제거될 때마다 원을 돌리는 방향을 계속해서 바꾸려고 한다. 이렇게 정의된 새로운 문제의 답을 (N, K, M)–반전 요세푸스 순열이라고 하며, (7, 3, 4)–반전 요세푸스 순열은 ⟨3,6,2,7,1,5,4⟩가 된다. N, K, M이 주어질 때, (N, K, M)–반전 요세푸스 순열을 계산해 보자. 입력첫째 줄에 정수 N, K, M이 주어진다. (1≤N≤5 000, 1≤K,M≤N) 출력(N, K, M)–반전 요세푸스 순열을 이루는 수들을 한 줄에 하나씩 순서대로 출력한다. 예제 입력 117 3 4 예제 출력 112345673627154 출처 University &gt; 서강대학교 &gt; 2020 Sogang Programming Contest (Master) C번 문제를 검수한 사람: gumgood, jhnah917, pichulia, QuqqU, rhs0266, shiftpsh, sogangcse, woonikim 문제를 만든 사람: sbrus_1213 알고리즘 분류 구현 자료 구조 시뮬레이션 덱 소스코드 (최초)1234567891011121314151617181920212223242526import sysfrom collections import dequeinput = sys.stdin.readlineN, K, M = map(int, input().split())people = deque(x for x in range(1, N + 1))count = 0direction = 1while people: if direction: # 오른쪽 for _ in range(K - 1): people.append(people[0]) people.popleft() elif not direction: # 왼쪽 for _ in range(K): people.appendleft(people.pop()) print(people.popleft()) count += 1 if count == M: count = 0 direction = not direction 소스코드 (수정)12345678910111213141516171819202122import sysfrom collections import dequeinput = sys.stdin.readlineN, K, M = map(int, input().split())people = deque(x for x in range(1, N + 1))while people: for _ in range(M): people.rotate(-(K - 1)) # 오른쪽 if not people: break print(people.popleft()) for _ in range(M): people.rotate(K) # 왼쪽 if not people: break print(people.popleft())","link":"/categories/Algorithm/Python/BAEKJOON-20301-21-07-23/"},{"title":"[백준] 2108번 통계학","text":"출처: [백준] 2108번 통계학 문제수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자. 산술평균 : N개의 수들의 합을 N으로 나눈 값 중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값 최빈값 : N개의 수들 중 가장 많이 나타나는 값 범위 : N개의 수들 중 최댓값과 최솟값의 차이 N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오. 입력첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다. 출력첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다. 둘째 줄에는 중앙값을 출력한다. 셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다. 넷째 줄에는 범위를 출력한다. 예제 입력 11234565138-22 예제 출력 1123422110 예제 입력 21214000 예제 출력 212344000400040000 예제 입력 31234565-1-2-3-1-2 예제 출력 31234-2-2-12 힌트 출처 데이터를 추가한 사람: djm03178, jungyh1509, palilo, YunGoon 문제의 오타를 찾은 사람: jh05013, skynethttps://www.acmicpc.net/user/citizen) 알고리즘 분류 구현 정렬 풀이 소스코드12345678910111213141516171819202122232425262728293031import sysfrom collections import Counterinput = sys.stdin.readlineN = int(input())num_list = sorted([int(input()) for _ in range(N)])# for _ in range(N):# num_list.append(int(input()))## num_list.sort()# 산술평균print(round(sum(num_list) / N))# 중앙값print(num_list[N // 2])# 최빈값mode_num = Counter(num_list).most_common()if len(mode_num) &gt; 1: if mode_num[0][1] == mode_num[1][1]: print(mode_num[1][0]) else: print(mode_num[0][0])else: print(mode_num[0][0])# 범위print(num_list[-1] - num_list[0])","link":"/categories/Algorithm/Python/BAEKJOON-2108-21-03-21/"},{"title":"[백준] 21567번 숫자의 개수2","text":"출처: [백준] 21567번 숫자의 개수2 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 (추가 시간 없음) 128 MB 8 8 8 100.000% 문제세 개의 자연수 A, B, C가 주어질 때 A × B × C를 계산한 결과에 0부터 9까지 각각의 숫자가 몇 번씩 쓰였는지를 구하는 프로그램을 작성하시오. 예를 들어 A = 150, B = 266, C = 427 이라면 A × B × C = 150 × 266 × 427 = 17037300 이 되고, 계산한 결과 17037300 에는 0이 3번, 1이 1번, 3이 2번, 7이 2번 쓰였다. 입력첫째 줄에 M과 N, 그리고 K가 빈칸을 사이에 두고 차례로 주어진다. M, N, K는 모두 100 이하의 자연수이다. 둘째 줄부터 K개의 줄에는 한 줄에 하나씩 직사각형의 왼쪽 아래 꼭짓점의 x, y좌표값과 오른쪽 위 꼭짓점의 x, y좌표값이 빈칸을 사이에 두고 차례로 주어진다. 모눈종이의 왼쪽 아래 꼭짓점의 좌표는 (0,0)이고, 오른쪽 위 꼭짓점의 좌표는(N,M)이다. 입력되는 K개의 직사각형들이 모눈종이 전체를 채우는 경우는 없다. 출력첫째 줄에는 A × B × C의 결과에 0 이 몇 번 쓰였는지 출력한다. 마찬가지로 둘째 줄부터 열 번째 줄까지 A × B × C의 결과에 1부터 9까지의 숫자가 각각 몇 번 쓰였는지 차례로 한 줄에 하나씩 출력한다. 예제 입력 1123150266427 예제 출력 1123456789103102000200 예제 입력 2123111 예제 출력 2123456789100100000000 예제 입력 3123999999999999999999 예제 출력 31234567891050100001011 출처 알고리즘 분류 구현 소스코드12345678910111213141516171819202122import sysinput = sys.stdin.readlineA = int(input())B = int(input())C = int(input())product_value = A * B * Csplit_num = list(str(product_value).rstrip())num_dict = {}for i in range(10): num_dict[i] = 0for num in split_num: num_dict[int(num)] += 1for i in range(10): print(num_dict[i])","link":"/categories/Algorithm/Python/BAEKJOON-21567-21-04-25/"},{"title":"[백준] 2164번 카드2","text":"출처: [백준] 2164번 카드2 문제 N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다. 이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다. 예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다. N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오. 입력첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다. 출력첫째 줄에 남게 되는 카드의 번호를 출력한다. 예제 입력 116 예제 출력 114 힌트 출처 알고리즘 분류 자료 구조 큐 시간 제한 풀이 소스코드123456789101112131415import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())card_deque = deque([i for i in range(1, N + 1)])while len(card_deque) &gt; 1: card_deque.popleft() card_deque.rotate(-1)print(card_deque[0])","link":"/categories/Algorithm/Python/BAEKJOON-2164-21-03-23/"},{"title":"[백준] 2161번 카드1","text":"출처: [백준] 2161번 카드1 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 5741 3921 3505 70.651% 문제N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다. 이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다. 예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 버린 카드들은 순서대로 1 3 2가 되고, 남는 카드는 4가 된다. N이 주어졌을 때, 버린 카드들을 순서대로 출력하고, 마지막에 남게 되는 카드를 출력하는 프로그램을 작성하시오. 입력첫째 줄에 정수 N(1 ≤ N ≤ 1,000)이 주어진다. 출력첫째 줄에 버리는 카드들을 순서대로 출력한다. 제일 마지막에는 남게 되는 카드의 번호를 출력한다. 예제 입력 117 예제 출력 111 3 5 7 4 2 6 출처- 알고리즘 분류 구현 자료 구조 덱 큐 소스코드12345678910111213141516import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())card_deque = deque([i for i in range(1, N + 1)])removed_card = []while len(card_deque) &gt; 0: removed_card.append(card_deque.popleft()) card_deque.rotate(-1)print(*removed_card)","link":"/categories/Algorithm/Python/BAEKJOON-2161-21-07-19/"},{"title":"[백준] 2167번 2차원 배열의 합","text":"출처: [백준] 2167번 2차원 배열의 합 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 17302 9928 7836 59.296% 문제2차원 배열이 주어졌을 때 (i, j) 위치부터 (x, y) 위치까지에 저장되어 있는 수들의 합을 구하는 프로그램을 작성하시오. 배열의 (i, j) 위치는 i행 j열을 나타낸다. 입력첫째 줄에 배열의 크기 N, M(1 ≤ N, M ≤ 300)이 주어진다. 다음 N개의 줄에는 M개의 정수로 배열이 주어진다. 배열에 포함되어 있는 수는 절댓값이 10,000보다 작거나 같은 정수이다. 그 다음 줄에는 합을 구할 부분의 개수 K(1 ≤ K ≤ 10,000)가 주어진다. 다음 K개의 줄에는 네 개의 정수로 i, j, x, y가 주어진다(i ≤ x, j ≤ y). 출력K개의 줄에 순서대로 배열의 합을 출력한다. 배열의 합은 231-1보다 작거나 같다. 예제 입력 112345672 31 2 48 16 3231 1 2 31 2 1 21 3 2 3 예제 출력 112363236 출처 빠진 조건을 찾은 사람: iriszero 잘못된 데이터를 찾은 사람: tncks0121 알고리즘 분류 구현 누적 합 소스코드12345678910111213141516import sysinput = sys.stdin.readlineN, M = map(int, input().split())matrix = [list(map(int, input().split())) for _ in range(N)]K = int(input())dp = [[0] * (M + 1) for _ in range(N + 1)]for i in range(1, N + 1): for j in range(1, M + 1): dp[i][j] = matrix[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1]for _ in range(K): i, j, x, y = map(int, input().split()) print(dp[x][y] - dp[x][j - 1] - dp[i - 1][y] + dp[i - 1][j - 1]) 소스코드 (시간초과)12345678910111213141516import sysinput = sys.stdin.readlineN, M = map(int, input().split())matrix = [list(map(int, input().split())) for _ in range(N)]K = int(input())for _ in range(K): i, j, x, y = map(int, input().split()) arr_sum = 0 for a in range(i, x + 1): for b in range(j, y + 1): arr_sum += matrix[a - 1][b - 1] print(arr_sum)","link":"/categories/Algorithm/Python/BAEKJOON-2167-21-06-15/"},{"title":"[백준] 2178번 미로 탐색","text":"출처: [백준] 2178번 미로 탐색 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 192 MB 88211 34772 22181 38.133% 문제N×M크기의 배열로 표현되는 미로가 있다. 1 0 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 1 미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다. 위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다. 입력첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다. 출력첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다. 예제 입력 1123454 6101111101010101011111011 예제 출력 1115 예제 입력 2123454 6110110110110111111111101 예제 출력 219 예제 입력 31232 2510111011101110111011101111110111011101110111011101 예제 출력 3138 예제 입력 4123456787 71011111111000110000011000001100000110000011111111 예제 출력 4113 힌트 출처 데이터를 추가한 사람: djm03178, jh05013, poia0304 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 시간 제한 풀이 소스코드123456789101112131415161718192021222324252627282930313233343536373839import sysfrom collections import dequeinput = sys.stdin.readlineN, M = map(int, input().split())# matrix 배열matrix = [list(map(int, input().rstrip())) for _ in range(N)]# 이동할 네 방향 정의 (상,하,좌,우)dx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]# BFS 소스코드 구현def bfs(x, y): # 큐(Queue) 구현을 위해 deque 라이브러리 사용 queue = deque() queue.append((x, y)) # 시작점 (0,0) # 큐가 빌 때까지 반복하기 while queue: x, y = queue.popleft() # 현재 위치에서 4가지 방향으로의 위치 확인 for i in range(4): nx = x + dx[i] ny = y + dy[i] # 미로 탐색 공간 내에서만 if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; M: # 벽이 아닌경우 if matrix[nx][ny] == 1: queue.append((nx, ny)) matrix[nx][ny] = matrix[x][y] + 1 # 가장 오른쪽 아래까지의 최단 거리 반환 return matrix[N - 1][M - 1]print(bfs(0, 0))","link":"/categories/Algorithm/Python/BAEKJOON-2178-21-04-09/"},{"title":"[백준] 2304번 창고 다각형","text":"출처: [백준] 2304번 창고 다각형 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 4418 1870 1510 44.360% 문제N 개의 막대 기둥이 일렬로 세워져 있다. 기둥들의 폭은 모두 1 m이며 높이는 다를 수 있다. 이 기둥들을 이용하여 양철로 된 창고를 제작하려고 한다. 창고에는 모든 기둥이 들어간다. 이 창고의 지붕을 다음과 같이 만든다. 지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다. 지붕의 가장자리는 땅에 닿아야 한다. 비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다. 그림 1은 창고를 옆에서 본 모습을 그린 것이다. 이 그림에서 굵은 선으로 표시된 부분이 지붕에 해당되고, 지붕과 땅으로 둘러싸인 다각형이 창고를 옆에서 본 모습이다. 이 다각형을 창고 다각형이라고 하자. 그림1 . 기둥과 지붕(굵은 선)의 예 창고 주인은 창고 다각형의 면적이 가장 작은 창고를 만들기를 원한다. 그림 1에서 창고 다각형의 면적은 98 ㎡이고, 이 경우가 가장 작은 창고 다각형이다. 기둥들의 위치와 높이가 주어질 때, 가장 작은 창고 다각형의 면적을 구하는 프로그램을 작성하시오. 입력첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 그 다음 N 개의 줄에는 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과 높이를 나타내는 정수 H가 한 개의 빈 칸을 사이에 두고 주어진다. L과 H는 둘 다 1 이상 1,000 이하이다. 출력첫 줄에 창고 다각형의 면적을 나타내는 정수를 출력한다. 예제 입력 11234567872 411 415 84 65 38 1013 6 예제 출력 1198 출처 Olympiad &gt; 한국정보올림피아드 &gt; KOI 2005 &gt; 초등부 2번 알고리즘 분류 자료 구조 브루트포스 알고리즘 스택 소스코드12345678910111213141516171819202122232425262728293031323334353637import sysinput = sys.stdin.readlineN = int(input())pillars = []for _ in range(N): idx, height = map(int, input().split()) pillars.append((idx, height))pillars.sort(key=lambda x: x[0]) # 정렬max_pillar = max(pillars, key=lambda x: x[1]) # 가장 높은 기둥찾기# 땅에 기둥세우기area = [0] * (pillars[-1][0] + 1)for idx, height in pillars: area[idx] = heightmax_index = area.index(max_pillar[1]) # 높은 기둥의 인덱스찾기temp = 0total = 0# 왼쪽부터 가장 높은 기둥까지for i in range(max_index + 1): if area[i] &gt; temp: temp = area[i] total += temptemp = 0# 오른쪽부터 가장높은 기둥까지for i in range(pillars[-1][0], max_index, -1): if area[i] &gt; temp: temp = area[i] total += tempprint(total)","link":"/categories/Algorithm/Python/BAEKJOON-2304-21-07-12/"},{"title":"[백준] 2257번 화학식량","text":"출처: [백준] 2257번 화학식량 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 1931 617 474 35.268% 문제우리가 널리 사용하는 H2O(물), CH3COOH(아세트산)과 같은 화학식은 알파벳과 숫자, 그리고 괄호로 구성된다. 먼저 알파벳은 원자를 나타내는 것으로 H는 수소(Hydrogen), C는 탄소(Carbon), O는 산소(Oxygen) 원자를 뜻한다. 또한 원자를 나타내는 알파벳 뒤에 따르는 숫자는 그 원자가 몇 개 포함되어 있는지를 뜻한다. 따라서 COOHHH 분자는 CO2H3로 나타낼 수 있다. 이 문제에서, 숫자는 항상 2 이상 9 이하로만 입력으로 주어진다. 따라서 CO23과 같이 숫자가 두자리인 경우는 없다. 물의 화학식을 보고 물은 두 개의 수소 원자와 한 개의 산소 원자로 이루어졌음을 알 수 있다. 또한 아세트산의 화학식처럼 한 종류의 알파벳이 화학식에 여러 번 나타날 수도 있다. 실제 화학식 또한 이렇게 사용되는데, 이는 분자의 결합 구조를 나타내기 위함이다. 종종 화학식에는 괄호가 사용되기도 하는데 괄호로 묶인 원자들은 하나의 새로운 원자와 같은 작용을 한다. 따라서 CH(CO2H)(CO2H)(CO2H) 분자는 CH(CO2H)3와 같이 나타낼 수 있다. 괄호 안에 아무런 알파벳도 없는 경우도 있을 수 있는데, 이런 경우는 괄호가 없는 경우와 마찬가지라고 생각하면 된다. 이러한 화학식을 보고 우리는 화학식량을 계산할 수 있는데, 화학식량이란 그 화학식에 포함되어 있는 모든 원자들의 질량의 합을 말한다. 수소 원자 하나의 질량은 1, 탄소 원자 하나의 질량은 12, 산소 원자 하나의 질량은 16이다. 물은 두 개의 수소 원자와 한 개의 산소 원자로 이루어져 있으므로 물의 화학식량은 18이다. 화학식이 주어졌을 때, 이 화학식의 화학식량을 계산하는 프로그램을 작성하시오. 화학식은 수소, 탄소, 산소만을 포함하고 있는 것만이 입력으로 주어진다. 입력첫째 줄에 화학식이 주어진다. 화학식은 H, C, O, (, ), 2, 3, 4, 5, 6, 7, 8, 9만으로 이루어진 문자열이며, 그 길이는 100을 넘지 않는다. 출력첫째 줄에 화학식량을 출력한다. 분자량이 10,000이 넘는 고분자는 입력으로 주어지지 않는다. 예제 입력 11(H)2(O) 예제 출력 1118 출처 ICPC &gt; Regionals &gt; Africa and Arab &gt; Arab Collegiate Programming Contest &gt; 2009 Arab Collegiate Programming Contest A번 문제를 번역한 사람: baekjoon 알고리즘 분류 자료 구조 문자열 스택 소스코드123456789101112131415161718192021222324252627import sysinput = sys.stdin.readlineinput_string = list(input().rstrip())values = {'H': 1, 'C': 12, 'O': 16}stack = []tmp = 0for x in input_string: if x == '(': stack.append(x) elif x == ')': tmp = 0 while stack[-1] != '(': num = stack.pop() tmp += num stack.pop() stack.append(tmp) elif x.isdigit(): tmp = stack.pop() stack.append(tmp * int(x)) else: stack.append(values[x])print(sum(stack))","link":"/categories/Algorithm/Python/BAEKJOON-2257-21-07-15/"},{"title":"[백준] 2309번 일곱 난쟁이","text":"출처: [백준] 2309번 일곱 난쟁이 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 58006 24046 17750 43.684% 문제왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다. 아홉 명의 난쟁이는 모두 자신이 “백설 공주와 일곱 난쟁이”의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다. 아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오. 입력아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다. 출력일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다. 예제 입력 11234567892072319101525813 예제 출력 11234567781013192023 출처 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2004 &gt; 초등부 1번 어색한 표현을 찾은 사람: upple1 알고리즘 분류 브루트포스 알고리즘 소스코드11234567891011121314151617import sysfrom itertools import combinationsinput = sys.stdin.readlinedwarfs = [int(input()) for _ in range(9)]dwarfs.sort()nPr = combinations(dwarfs, 7)temp = []for case in list(nPr): if sum(case) == 100: temp = case breakfor x in temp: print(x) 소스코드21234567891011121314151617181920212223import sysinput = sys.stdin.readlinedwarfs = [int(input()) for _ in range(9)]dwarfs.sort()height_sum = sum(dwarfs)delete_element1 = 0delete_element2 = 0for i in range(9): for j in range(i + 1, 9): if height_sum - (dwarfs[i] + dwarfs[j]) == 100: delete_element1 = dwarfs[i] delete_element2 = dwarfs[j] breakfor dwarf in dwarfs: if dwarf == delete_element1 or dwarf == delete_element2: continue else: print(dwarf)","link":"/categories/Algorithm/Python/BAEKJOON-2309-21-05-08/"},{"title":"[백준] 2346번 풍선 터뜨리기","text":"출처: [백준] 2346번 풍선 터뜨리기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 4 MB 7479 2869 2217 40.464% 문제1번부터 N번까지 N개의 풍선이 원형으로 놓여 있고. i번 풍선의 오른쪽에는 i+1번 풍선이 있고, 왼쪽에는 i-1번 풍선이 있다. 단, 1번 풍선의 왼쪽에 N번 풍선이 있고, N번 풍선의 오른쪽에 1번 풍선이 있다. 각 풍선 안에는 종이가 하나 들어있고, 종이에는 -N보다 크거나 같고, N보다 작거나 같은 정수가 하나 적혀있다. 이 풍선들을 다음과 같은 규칙으로 터뜨린다. 우선, 제일 처음에는 1번 풍선을 터뜨린다. 다음에는 풍선 안에 있는 종이를 꺼내어 그 종이에 적혀있는 값만큼 이동하여 다음 풍선을 터뜨린다. 양수가 적혀 있을 경우에는 오른쪽으로, 음수가 적혀 있을 때는 왼쪽으로 이동한다. 이동할 때에는 이미 터진 풍선은 빼고 이동한다. 예를 들어 다섯 개의 풍선 안에 차례로 3, 2, 1, -3, -1이 적혀 있었다고 하자. 이 경우 3이 적혀 있는 1번 풍선, -3이 적혀 있는 4번 풍선, -1이 적혀 있는 5번 풍선, 1이 적혀 있는 3번 풍선, 2가 적혀 있는 2번 풍선의 순서대로 터지게 된다. 입력첫째 줄에 자연수 N(1 ≤ N ≤ 1,000)이 주어진다. 다음 줄에는 차례로 각 풍선 안의 종이에 적혀 있는 수가 주어진다. 종이에 0은 적혀있지 않다. 출력첫째 줄에 터진 풍선의 번호를 차례로 나열한다. 예제 입력 11253 2 1 -3 -1 예제 출력 111 4 5 3 2 출처 잘못된 데이터를 찾은 사람: tncks0121 알고리즘 분류 자료 구조 덱 소스코드12345678910111213141516171819202122232425import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())balloons = [x for x in range(1, N + 1)]papers = list(map(int, input().split()))bomb = deque()for balloon, paper in zip(balloons, papers): bomb.append([balloon, paper])while bomb: balloon, paper = bomb.popleft() print(balloon, end=&quot; &quot;) if bomb: if paper &gt; 0: for _ in range(paper - 1): bomb.append(bomb.popleft()) else: for _ in range(-paper): bomb.appendleft(bomb.pop())","link":"/categories/Algorithm/Python/BAEKJOON-2346-21-07-23/"},{"title":"[백준] 2442번 별 찍기 - 5","text":"출처: [백준] 2442번 별 찍기 - 5 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 31653 17941 16137 57.227% 문제첫째 줄에는 별 1개, 둘째 줄에는 별 3개, …, N번째 줄에는 별 2×N-1개를 찍는 문제 별은 가운데를 기준으로 대칭이어야 한다. 입력첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다. 출력첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다. 예제 입력 115 예제 출력 112345 * *** ***** **************** 힌트 출처 문제를 만든 사람: baekjoon 문제의 오타를 찾은 사람: youngminz 알고리즘 분류 구현 시간 제한 풀이 소스코드123456789import sysinput = sys.stdin.readlineN = int(input())for i in range(1, N + 1): print(' ' * (N - i) + '*' * (2 * i - 1))","link":"/categories/Algorithm/Python/BAEKJOON-2442-21-04-17/"},{"title":"[백준] 2331번 반복수열","text":"출처: [백준] 2331번 반복수열 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 256 MB 9795 4407 3250 44.176% 문제다음과 같이 정의된 수열이 있다. D[1] = A D[n] = D[n-1]의 각 자리의 숫자를 P번 곱한 수들의 합 예를 들어 A=57, P=2일 때, 수열 D는 {57, 74(=5^2+7^2=25+49), 65, 61, 37, 58, 89, 145, 42, 20, 4, 16, 37, …}이 된다. 그 뒤에는 앞서 나온 수들(57부터가 아니라 58부터)이 반복된다. 이와 같은 수열을 계속 구하다 보면 언젠가 이와 같은 반복수열이 된다. 이때, 반복되는 부분을 제외했을 때, 수열에 남게 되는 수들의 개수를 구하는 프로그램을 작성하시오. 위의 예에서는 {57, 74, 65, 61}의 네 개의 수가 남게 된다. 입력첫째 줄에 A(1 ≤ A ≤ 9999), P(1 ≤ P ≤ 5)가 주어진다. 출력첫째 줄에 반복되는 부분을 제외했을 때, 수열에 남게 되는 수들의 개수를 출력한다. 예제 입력 1157 2 예제 출력 114 출처- 알고리즘 분류 구현 소스코드112345678910111213141516171819202122232425import sysinput = sys.stdin.readlineA, P = map(int, input().split())stack = [A]temp = 0while 1: value = str(stack[-1]) temp = 0 for i in range(len(value)): temp += int(value[i]) ** P if temp in stack: value = str(stack[-1]) temp = 0 for i in range(len(value)): temp += int(value[i]) ** P break else: stack.append(temp)print(stack.index(temp)) 소스코드21234567891011121314151617181920212223242526import sysinput = sys.stdin.readlineA, P = map(int, input().split())stack = [A]removed_stack = []while stack: value = str(stack[-1]) temp = 0 for i in range(len(value)): temp += int(value[i]) ** P if temp not in stack: stack.append(temp) else: stack.append(temp) if temp in removed_stack: break else: removed_stack.append(temp)print(len(set(stack) - set(removed_stack)))","link":"/categories/Algorithm/Python/BAEKJOON-2331-21-06-20/"},{"title":"[백준] 2444번 별 찍기 - 7","text":"출처: [백준] 2444번 별 찍기 - 7 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 18668 13189 12075 72.992% 문제예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요. 입력첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다. 출력첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다. 예제 입력 115 예제 출력 1123456789 * *** ***** **************** ******* ***** *** * 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 구현 시간 제한 풀이 소스코드123456789101112import sysinput = sys.stdin.readlineN = int(input())for i in range(1, N + 1): print(' ' * (N - i) + '*' * (2 * i - 1))for i in reversed(range(1, N)): print(' ' * (N - i) + '*' * (2 * i - 1))","link":"/categories/Algorithm/Python/BAEKJOON-2444-21-04-17/"},{"title":"[백준] 2445번 별 찍기 - 8","text":"출처: [백준] 2445번 별 찍기 - 8 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 18262 13350 12206 73.846% 문제예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요. 입력첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다. 출력첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다. 예제 입력 115 예제 출력 1123456789* *** ***** ******* ****************** ******* ***** *** * 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 구현 시간 제한 풀이 소스코드123456789101112import sysinput = sys.stdin.readlineN = int(input())for i in reversed(range(1, N)): print('*' * (N - i) + ' ' * (2 * i) + '*' * (N - i))for i in range(N): print('*' * (N - i) + ' ' * (2 * i) + '*' * (N - i))","link":"/categories/Algorithm/Python/BAEKJOON-2445-21-04-17/"},{"title":"[백준] 2443번 별 찍기 - 6","text":"출처: [백준] 2443번 별 찍기 - 6 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 16915 12444 11585 75.174% 문제첫째 줄에는 별 2×N-1개, 둘째 줄에는 별 2×N-3개, …, N번째 줄에는 별 1개를 찍는 문제 별은 가운데를 기준으로 대칭이어야 한다. 입력첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다. 출력첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다. 예제 입력 115 예제 출력 112345********* ******* ***** *** * 힌트 출처 문제를 만든 사람: baekjoon 문제의 오타를 찾은 사람: youngminz 알고리즘 분류 구현 시간 제한 풀이 소스코드123456789import sysinput = sys.stdin.readlineN = int(input())for i in reversed(range(1, N + 1)): print(' ' * (N - i) + '*' * (2 * i - 1))","link":"/categories/Algorithm/Python/BAEKJOON-2443-21-04-17/"},{"title":"[백준] 2446번 별 찍기 - 9","text":"출처: [백준] 2446번 별 찍기 - 9 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 33081 18703 17182 57.652% 문제예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요. 입력첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다. 출력첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다. 예제 입력 115 예제 출력 1123456789********* ******* ***** *** * *** ***** **************** 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 구현 시간 제한 풀이 소스코드123456789101112import sysinput = sys.stdin.readlineN = int(input())for i in reversed(range(1, N + 1)): print(' ' * (N - i) + &quot;*&quot; * (2 * i - 1))for i in range(2, N + 1): print(' ' * (N - i) + &quot;*&quot; * (2 * i - 1))","link":"/categories/Algorithm/Python/BAEKJOON-2446-21-04-17/"},{"title":"[백준] 2447번 별 찍기-10","text":"출처: [백준] 2447번 별 찍기-10 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 128 MB 37375 17060 13949 46.314% 문제재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, …)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다. 크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다. 123**** **** N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다. 입력첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k &lt; 8이다. 출력첫째 줄부터 N번째 줄까지 별을 출력한다. 예제 입력 1127 예제 출력 1123456789101112131415161718192021222324252627**************************** ** ** ** ** ** ** ** ** ******************************* ****** ****** **** * * ** * * ** * * **** ****** ****** ******************************* ** ** ** ** ** ** ** ** ************************************* ********** ** ** * * ** ** ********** ************ *** *** **** * * * * * * **** *** *** ************ ********** ** ** * * ** ** ********** ************************************* ** ** ** ** ** ** ** ** ******************************* ****** ****** **** * * ** * * ** * * **** ****** ****** ******************************* ** ** ** ** ** ** ** ** **************************** 힌트 출처 문제를 만든 사람: baekjoon 문제를 다시 작성한 사람: jh05013 알고리즘 분류 분할 정복 재귀 시간 제한 풀이 1, 4, 7, 10, 13, 16, 19, 22, 25 …. 3으로 나눈 나머지가 1인 부분이 공백 전체를 봤을때, 3줄씩 한 세트라고 하면, 3, 4, 5, 12, 13, 14, 21, 22, 23…. (n//3)%3==1인 부분이 공백 소스코드1234567891011121314151617181920212223242526272829import sysinput = sys.stdin.readlineN = int(input())arr = [['*'] * N for _ in range(N)] # output array 생성temp = Ncnt = 0while temp != 1: # 입력받은 n이 3의 몇승? temp /= 3 cnt += 1'''1, 4, 7, 10, 13, 16, 19, 22, 25 .... 3으로 나눈 나머지가 1인 부분이 공백전체를 봤을때, 3줄씩 한 세트라고 하면, 3, 4, 5, 12, 13, 14, 21, 22, 23.... (n//3)%3==1인 부분이 공백'''for i in range(cnt): idx = [] for j in range(N): if (j // 3 ** i) % 3 == 1: idx.append(j) for row in idx: for col in idx: arr[row][col] = ' 'print('\\n'.join([''.join([str(i) for i in row]) for row in arr]))","link":"/categories/Algorithm/Python/BAEKJOON-2447-21-04-13/"},{"title":"[백준] 2455번 지능형 기차","text":"출처: [백준] 2455번 지능형 기차 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 16669 12017 10733 76.730% 문제최근에 개발된 지능형 기차가 1번역(출발역)부터 4번역(종착역)까지 4개의 정차역이 있는 노선에서 운행되고 있다. 이 기차에는 타거나 내리는 사람 수를 자동으로 인식할 수 있는 장치가 있다. 이 장치를 이용하여 출발역에서 종착역까지 가는 도중 기차 안에 사람이 가장 많을 때의 사람 수를 계산하려고 한다. 단, 이 기차를 이용하는 사람들은 질서 의식이 투철하여, 역에서 기차에 탈 때, 내릴 사람이 모두 내린 후에 기차에 탄다고 가정한다. 내린 사람 수 탄 사람 수 1번역(출발역) 0 32 2번역 3 13 3번역 28 25 4번역(종착역) 39 0 예를 들어, 위와 같은 경우를 살펴보자. 이 경우, 기차 안에 사람이 가장 많은 때는 2번역에서 3명의 사람이 기차에서 내리고, 13명의 사람이 기차에 탔을 때로, 총 42명의 사람이 기차 안에 있다. 이 기차는 다음 조건을 만족하면서 운행된다고 가정한다. 기차는 역 번호 순서대로 운행한다. 출발역에서 내린 사람 수와 종착역에서 탄 사람 수는 0이다. 각 역에서 현재 기차에 있는 사람보다 더 많은 사람이 내리는 경우는 없다. 기차의 정원은 최대 10,000명이고, 정원을 초과하여 타는 경우는 없다. 4개의 역에 대해 기차에서 내린 사람 수와 탄 사람 수가 주어졌을 때, 기차에 사람이 가장 많을 때의 사람 수를 계산하는 프로그램을 작성하시오. 입력각 역에서 내린 사람 수와 탄 사람 수가 빈칸을 사이에 두고 첫째 줄부터 넷째 줄까지 역 순서대로 한 줄에 하나씩 주어진다. 출력첫째 줄에 최대 사람 수를 출력한다. 예제 입력 112340 323 1328 2539 0 예제 출력 1142 힌트 출처Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2011 &gt; 초등부 1번 데이터를 추가한 사람: ryu_eclipse, surung9898 알고리즘 분류 수학 구현 사칙연산 시간 제한 풀이 소스코드1234567891011121314import sysinput = sys.stdin.readlinemax_p = 0sum_p = 0for _ in range(4): out_p, in_p = map(int, input().split()) sum_p -= out_p sum_p += in_p max_p = max(max_p, sum_p)print(max_p)","link":"/categories/Algorithm/Python/BAEKJOON-2455-21-04-19/"},{"title":"[백준] 2475번 검증수","text":"출처: [백준] 2475번 검증수 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 17465 13196 11861 76.900% 문제컴퓨터를 제조하는 회사인 KOI 전자에서는 제조하는 컴퓨터마다 6자리의 고유번호를 매긴다. 고유번호의 처음 5자리에는 00000부터 99999까지의 수 중 하나가 주어지며 6번째 자리에는 검증수가 들어간다. 검증수는 고유번호의 처음 5자리에 들어가는 5개의 숫자를 각각 제곱한 수의 합을 10으로 나눈 나머지이다. 예를 들어 고유번호의 처음 5자리의 숫자들이 04256이면, 각 숫자를 제곱한 수들의 합 0+16+4+25+36 = 81 을 10으로 나눈 나머지인 1이 검증수이다. 입력첫째 줄에 고유번호의 처음 5자리의 숫자들이 빈칸을 사이에 두고 하나씩 주어진다. 출력첫째 줄에 검증수를 출력한다. 예제 입력 110 4 2 5 6 예제 출력 111 힌트 출처Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2010 &gt; 초등부 1번 잘못된 데이터를 찾은 사람: rory143, tncks0121 알고리즘 분류 수학 구현 사칙연산 시간 제한 풀이 소스코드123456789101112import sysinput = sys.stdin.readlinelists = list(map(int, input().split()))result = 0for num in lists: result += num ** 2print(result % 10)","link":"/categories/Algorithm/Python/BAEKJOON-2475-21-04-19/"},{"title":"[백준] 2468번 안전 영역","text":"출처: [백준] 2468번 안전 영역 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 40557 15312 10254 34.415% 문제재난방재청에서는 많은 비가 내리는 장마철에 대비해서 다음과 같은 일을 계획하고 있다. 먼저 어떤 지역의 높이 정보를 파악한다. 그 다음에 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는 안전한 영역이 최대로 몇 개가 만들어 지는 지를 조사하려고 한다. 이때, 문제를 간단하게 하기 위하여, 장마철에 내리는 비의 양에 따라 일정한 높이 이하의 모든 지점은 물에 잠긴다고 가정한다. 어떤 지역의 높이 정보는 행과 열의 크기가 각각 N인 2차원 배열 형태로 주어지며 배열의 각 원소는 해당 지점의 높이를 표시하는 자연수이다. 예를 들어, 다음은 N=5인 지역의 높이 정보이다. 이제 위와 같은 지역에 많은 비가 내려서 높이가 4 이하인 모든 지점이 물에 잠겼다고 하자. 이 경우에 물에 잠기는 지점을 회색으로 표시하면 다음과 같다. 물에 잠기지 않는 안전한 영역이라 함은 물에 잠기지 않는 지점들이 위, 아래, 오른쪽 혹은 왼쪽으로 인접해 있으며 그 크기가 최대인 영역을 말한다. 위의 경우에서 물에 잠기지 않는 안전한 영역은 5개가 된다(꼭짓점으로만 붙어 있는 두 지점은 인접하지 않는다고 취급한다). 또한 위와 같은 지역에서 높이가 6이하인 지점을 모두 잠기게 만드는 많은 비가 내리면 물에 잠기지 않는 안전한 영역은 아래 그림에서와 같이 네 개가 됨을 확인할 수 있다. 이와 같이 장마철에 내리는 비의 양에 따라서 물에 잠기지 않는 안전한 영역의 개수는 다르게 된다. 위의 예와 같은 지역에서 내리는 비의 양에 따른 모든 경우를 다 조사해 보면 물에 잠기지 않는 안전한 영역의 개수 중에서 최대인 경우는 5임을 알 수 있다. 어떤 지역의 높이 정보가 주어졌을 때, 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하는 프로그램을 작성하시오. 입력첫째 줄에는 어떤 지역을 나타내는 2차원 배열의 행과 열의 개수를 나타내는 수 N이 입력된다. N은 2 이상 100 이하의 정수이다. 둘째 줄부터 N개의 각 줄에는 2차원 배열의 첫 번째 행부터 N번째 행까지 순서대로 한 행씩 높이 정보가 입력된다. 각 줄에는 각 행의 첫 번째 열부터 N번째 열까지 N개의 높이 정보를 나타내는 자연수가 빈 칸을 사이에 두고 입력된다. 높이는 1이상 100 이하의 정수이다. 출력첫째 줄에 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 출력한다. 예제 입력 112345656 8 2 6 23 2 3 4 66 7 3 3 27 2 5 3 68 9 5 2 7 예제 출력 115 노트아무 지역도 물에 잠기지 않을 수도 있다. 출처Olympiad &gt; 한국정보올림피아드 &gt; KOI 2010 &gt; 초등부 2번 문제의 오타를 찾은 사람: apjw6112 어색한 표현을 찾은 사람: jh05013 잘못된 데이터를 찾은 사람: tncks0121 알고리즘 분류 그래프 이론 그래프 탐색 브루트포스 알고리즘 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_DFS12345678910111213141516171819202122232425262728293031323334import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readlinedx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]def dfs(x, y, h): for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; N and ground[nx][ny] &gt; h and not visited[nx][ny]: visited[nx][ny] = True dfs(nx, ny, h)N = int(input())ground = [list(map(int, input().split())) for _ in range(N)]result = 0for k in range(max(max(ground))): count = 0 visited = [[False] * N for _ in range(N)] for i in range(N): for j in range(N): if ground[i][j] &gt; k and not visited[i][j]: count += 1 visited[i][j] = True dfs(i, j, k) result = max(result, count)print(result)","link":"/categories/Algorithm/Python/BAEKJOON-2468-21-04-22/"},{"title":"[백준] 2503번 숫자 야구","text":"출처: [백준] 2503번 숫자 야구 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 9137 4152 3430 45.923% 문제정보문화진흥원 정보 영재 동아리에서 동아리 활동을 하던 영수와 민혁이는 쉬는 시간을 틈타 숫자야구 게임을 하기로 했다. 영수는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 마음속으로 생각한다. (예: 324) 민혁이는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 영수에게 묻는다. (예: 123) 민혁이가 말한 세 자리 수에 있는 숫자들 중 하나가 영수의 세 자리 수의 동일한 자리에 위치하면 스트라이크 한 번으로 센다. 숫자가 영수의 세 자리 수에 있긴 하나 다른 자리에 위치하면 볼 한 번으로 센다. 예) 영수가 324를 갖고 있으면 429는 1 스트라이크 1 볼이다. 241은 0 스트라이크 2 볼이다. 924는 2 스트라이크 0 볼이다. 영수는 민혁이가 말한 수가 몇 스트라이크 몇 볼인지를 답해준다. 민혁이가 영수의 세 자리 수를 정확하게 맞추어 3 스트라이크가 되면 게임이 끝난다. 아니라면 민혁이는 새로운 수를 생각해 다시 영수에게 묻는다. 현재 민혁이와 영수는 게임을 하고 있는 도중에 있다. 민혁이가 영수에게 어떤 수들을 물어보았는지, 그리고 각각의 물음에 영수가 어떤 대답을 했는지가 입력으로 주어진다. 이 입력을 바탕으로 여러분은 영수가 생각하고 있을 가능성이 있는 수가 총 몇 개인지를 알아맞혀야 한다. 아래와 같은 경우를 생각해보자. 민혁: 123 영수: 1 스트라이크 1 볼. 민혁: 356 영수: 1 스트라이크 0 볼. 민혁: 327 영수: 2 스트라이크 0 볼. 민혁: 489 영수: 0 스트라이크 1 볼. 이때 가능한 답은 324와 328, 이렇게 두 가지이다. 영수는 동아리의 규율을 잘 따르는 착한 아이라 민혁이의 물음에 곧이곧대로 정직하게 답한다. 그러므로 영수의 답들에는 모순이 없다. 민혁이의 물음들과 각각의 물음에 대한 영수의 답이 입력으로 주어질 때 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력하는 프로그램을 작성하시오. 입력첫째 줄에는 민혁이가 영수에게 몇 번이나 질문을 했는지를 나타내는 1 이상 100 이하의 자연수 N이 주어진다. 이어지는 N개의 줄에는 각 줄마다 민혁이가 질문한 세 자리 수와 영수가 답한 스트라이크 개수를 나타내는 정수와 볼의 개수를 나타내는 정수, 이렇게 총 세 개의 정수가 빈칸을 사이에 두고 주어진다. 출력첫 줄에 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력한다. 예제 입력 1123454123 1 1356 1 0327 2 0489 0 1 예제 출력 112 출처 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2008 &gt; 초등부 3번 잘못된 데이터를 찾은 사람: Apple_Cplus 데이터를 추가한 사람: tlstlfgks3 알고리즘 분류 브루트포스 알고리즘 소스코드1234567891011121314151617181920212223242526272829import sysfrom itertools import permutationsinput = sys.stdin.readlinenum = [1, 2, 3, 4, 5, 6, 7, 8, 9]cases = list(permutations(num, 3))N = int(input())for _ in range(N): ques, s_c, b_c = map(int, input().split()) ques = list(str(ques)) temp_cases = [] for i in range(len(cases)): strike, ball = 0, 0 for j in range(3): if cases[i][j] == int(ques[j]): strike += 1 elif int(ques[j]) in cases[i]: ball += 1 if s_c == strike and b_c == ball: temp_cases.append(cases[i]) # 한 줄 끝나고, 맞은 케이스만 사용할 수 있도록 cases = temp_casesprint(len(cases))","link":"/categories/Algorithm/Python/BAEKJOON-2503-21-07-17/"},{"title":"[백준] 2504번 괄호의 값","text":"출처: [백준] 2504번 괄호의 값 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 29463 7308 5555 27.818% 문제4개의 기호 ‘(’, ‘)’, ‘[’, ‘]’를 이용해서 만들어지는 괄호열 중에서 올바른 괄호열이란 다음과 같이 정의된다. 한 쌍의 괄호로만 이루어진 ‘()’와 ‘[]’는 올바른 괄호열이다. 만일 X가 올바른 괄호열이면 ‘(X)’이나 ‘[X]’도 모두 올바른 괄호열이 된다. X와 Y 모두 올바른 괄호열이라면 이들을 결합한 XY도 올바른 괄호열이 된다. 예를 들어 ‘(()[[]])’나 ‘(())[][]’ 는 올바른 괄호열이지만 ‘([)]’ 나 ‘(()()[]’ 은 모두 올바른 괄호열이 아니다. 우리는 어떤 올바른 괄호열 X에 대하여 그 괄호열의 값(괄호값)을 아래와 같이 정의하고 값(X)로 표시한다. ‘()’ 인 괄호열의 값은 2이다. ‘[]’ 인 괄호열의 값은 3이다. ‘(X)’ 의 괄호값은 2×값(X) 으로 계산된다. ‘[X]’ 의 괄호값은 3×값(X) 으로 계산된다. 올바른 괄호열 X와 Y가 결합된 XY의 괄호값은 값(XY)= 값(X)+값(Y) 로 계산된다. 예를 들어 ‘(()[[]])([])’ 의 괄호값을 구해보자. ‘()[[]]’ 의 괄호값이 2 + 3×3=11 이므로 ‘(()[[ ]])’의 괄호값은 2×11=22 이다. 그리고 ‘([])’의 값은 2×3=6 이므로 전체 괄호열의 값은 22 + 6 = 28 이다. 여러분이 풀어야 할 문제는 주어진 괄호열을 읽고 그 괄호값을 앞에서 정의한대로 계산하여 출력하는 것이다. 입력첫째 줄에 괄호열을 나타내는 문자열(스트링)이 주어진다. 단 그 길이는 1 이상, 30 이하이다. 출력첫째 줄에 그 괄호열의 값을 나타내는 정수를 출력한다. 만일 입력이 올바르지 못한 괄호열이면 반드시 0을 출력해야 한다. 예제 입력 11(()[[]])([]) 예제 출력 1128 출처 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2008 &gt; 초등부 4번 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2008 &gt; 중등부 2번 데이터를 추가한 사람: 906bc, djm03178, eatgugbab, leedongbin, sang7, sankim90 잘못된 데이터를 찾은 사람: djm03178 알고리즘 분류 구현 자료 구조 스택 재귀 소스코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import sysinput = sys.stdin.readlineinput_string = list(input().rstrip())stack = []def solution(string): for bracket in string: if bracket == ')': tmp = 0 while stack: top = stack.pop() if top == '(': if tmp == 0: stack.append(2) else: stack.append(tmp * 2) break elif top == '[': return 0 else: tmp += int(top) elif bracket == ']': tmp = 0 while stack: top = stack.pop() if top == '[': if tmp == 0: stack.append(3) else: stack.append(tmp * 3) break elif top == '(': return 0 else: tmp += int(top) else: stack.append(bracket) return stackif solution(input_string): print(0 if '(' in stack or '[' in stack else sum(stack))else: print(0)","link":"/categories/Algorithm/Python/BAEKJOON-2504-21-06-16/"},{"title":"[백준] 2522번 별 찍기 - 12","text":"출처: [백준] 2522번 별 찍기 - 12 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 11072 9348 8753 85.479% 문제예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요. 입력첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다. 출력첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다. 예제 입력 113 예제 출력 112345 * ***** ** * 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 구현 시간 제한 풀이 소스코드1234567891011import sysinput = sys.stdin.readlineN = int(input())for i in range(1, N + 1): print(' ' * (N - i) + '*' * i)for i in reversed(range(1, N)): print(' ' * (N - i) + '*' * i)","link":"/categories/Algorithm/Python/BAEKJOON-2522-21-04-17/"},{"title":"[백준] 2523번 별 찍기 - 13","text":"출처: [백준] 2523번 별 찍기 - 13 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 21128 14779 13815 71.252% 문제예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요. 입력첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다. 출력첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다. 예제 입력 113 예제 출력 112345********* 힌트 출처 문제를 만든 사람: baekjoon 알고리즘 분류 구현 시간 제한 풀이 소스코드1234567891011import sysinput = sys.stdin.readlineN = int(input())for i in range(1, N + 1): print('*' * i)for i in reversed(range(1, N)): print('*' * i)","link":"/categories/Algorithm/Python/BAEKJOON-2523-21-04-17/"},{"title":"[백준] 2563번 색종이","text":"출처: [백준] 2563번 색종이 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 9793 6870 5908 71.327% 문제가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오. 예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다. 입력첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다 출력첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다. 예제 입력 1123433 715 75 2 예제 출력 11260 출처 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2007 &gt; 초등부 2번 알고리즘 분류 구현 소스코드12345678910111213141516171819import sysinput = sys.stdin.readlinepapers = [[0 for _ in range(101)] for _ in range(101)]N = int(input())for _ in range(N): x, y = map(int, input().split()) for i in range(x, x + 10): for j in range(y, y + 10): papers[j][i] = 1result = 0for row in papers: result += row.count(1)print(result)","link":"/categories/Algorithm/Python/BAEKJOON-2563-21-05-23/"},{"title":"[백준] 2583번 영역 구하기","text":"출처: [백준] 2583번 영역 구하기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 21003 11698 9290 56.702% 문제눈금의 간격이 1인 M×N(M,N≤100)크기의 모눈종이가 있다. 이 모눈종이 위에 눈금에 맞추어 K개의 직사각형을 그릴 때, 이들 K개의 직사각형의 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어진다. 예를 들어 M=5, N=7 인 모눈종이 위에 &lt;그림 1&gt;과 같이 직사각형 3개를 그렸다면, 그 나머지 영역은 &lt;그림 2&gt;와 같이 3개의 분리된 영역으로 나누어지게 된다. &lt;그림 2&gt;와 같이 분리된 세 영역의 넓이는 각각 1, 7, 13이 된다. M, N과 K 그리고 K개의 직사각형의 좌표가 주어질 때, K개의 직사각형 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어지는지, 그리고 분리된 각 영역의 넓이가 얼마인지를 구하여 이를 출력하는 프로그램을 작성하시오. 입력첫째 줄에 M과 N, 그리고 K가 빈칸을 사이에 두고 차례로 주어진다. M, N, K는 모두 100 이하의 자연수이다. 둘째 줄부터 K개의 줄에는 한 줄에 하나씩 직사각형의 왼쪽 아래 꼭짓점의 x, y좌표값과 오른쪽 위 꼭짓점의 x, y좌표값이 빈칸을 사이에 두고 차례로 주어진다. 모눈종이의 왼쪽 아래 꼭짓점의 좌표는 (0,0)이고, 오른쪽 위 꼭짓점의 좌표는(N,M)이다. 입력되는 K개의 직사각형들이 모눈종이 전체를 채우는 경우는 없다. 출력첫째 줄에 분리되어 나누어지는 영역의 개수를 출력한다. 둘째 줄에는 각 영역의 넓이를 오름차순으로 정렬하여 빈칸을 사이에 두고 출력한다. 예제 입력 112345 7 30 2 4 41 1 2 54 0 6 2 예제 출력 11231 7 13 출처Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2006 &gt; 고등부 2번 문제의 오타를 찾은 사람: alphago92 데이터를 추가한 사람: hjhj97 잘못된 데이터를 찾은 사람: kookmin20103324 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_DFS1234567891011121314151617181920212223242526272829303132333435363738394041import syssys.setrecursionlimit(10**6)input = sys.stdin.readline# 방향정의dx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]def dfs(x, y, count): ground[x][y] = 1 for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; M and 0 &lt;= ny &lt; N: if ground[nx][ny] == 0: count = dfs(nx, ny, count + 1) return countM, N, K = map(int, input().split())ground = [[0] * N for _ in range(M)]for _ in range(K): x1, y1, x2, y2 = map(int, input().split()) for i in range(y1, y2): for j in range(x1, x2): ground[i][j] = 1count = []for i in range(M): for j in range(N): if ground[i][j] == 0: count.append(dfs(i, j, 1))print(len(count))for x in sorted(count): print(x, end=&quot; &quot;)","link":"/categories/Algorithm/Python/BAEKJOON-2583-21-04-23/"},{"title":"[백준] 2490번 윷놀이","text":"출처: [백준] 2490번 윷놀이 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 21283 12299 10934 58.194% 문제우리나라 고유의 윷놀이는 네 개의 윷짝을 던져서 배(0)와 등(1)이 나오는 숫자를 세어 도, 개, 걸, 윷, 모를 결정한다. 네 개 윷짝을 던져서 나온 각 윷짝의 배 혹은 등 정보가 주어질 때 도(배 한 개, 등 세 개), 개(배 두 개, 등 두 개), 걸(배 세 개, 등 한 개), 윷(배 네 개), 모(등 네 개) 중 어떤 것인지를 결정하는 프로그램을 작성하라. 입력첫째 줄부터 셋째 줄까지 각 줄에 각각 한 번 던진 윷짝들의 상태를 나타내는 네 개의 정수(0 또는 1)가 빈칸을 사이에 두고 주어진다. 출력첫째 줄부터 셋째 줄까지 한 줄에 하나씩 결과를 도는 A, 개는 B, 걸은 C, 윷은 D, 모는 E로 출력한다. 예제 입력 11230 1 0 11 1 1 00 0 1 1 예제 출력 1123BAB 힌트 출처Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2009 &gt; 초등부 1번 잘못된 데이터를 찾은 사람: djm03178 문제의 오타를 찾은 사람: eric00513 알고리즘 분류 구현 시간 제한 풀이 소스코드 1123456789101112131415161718import sysinput = sys.stdin.readlinefor _ in range(3): lists = list(map(int, input().split())) if lists.count(1) == 0: print('D') elif lists.count(1) == 1: print('C') elif lists.count(1) == 2: print('B') elif lists.count(1) == 3: print('A') elif lists.count(1) == 4: print('E') 소스코드 21234567891011121314151617181920212223242526272829303132import sysinput = sys.stdin.readline# 0: 배# 1: 등# 도(0,111), 개(00,11), 걸(000,1), 윷(0000), 모(1111)for _ in range(3): lists = list(map(int, input().split())) front = 0 # 배 rear = 0 # 등 for num in lists: if num == 0: front += 1 else: rear += 1 if rear == 0 and front == 4: print('D') elif rear == 1 and front == 3: print('C') elif rear == 2 and front == 2: print('B') elif rear == 3 and front == 1: print('A') elif rear == 4 and front == 0: print('E')","link":"/categories/Algorithm/Python/BAEKJOON-2490-21-04-19/"},{"title":"[백준] 2606번 바이러스","text":"출처: [백준] 2606번 바이러스 문제신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다. 예를 들어 7대의 컴퓨터가 &lt;그림 1&gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다. 어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오. 입력첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다. 출력1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다. 예제 입력 112345678761 22 31 55 25 64 7 예제 출력 114 힌트 출처 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2004 &gt; 초등부 3번 잘못된 데이터를 찾은 사람: djm03178, jsa3824 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_BFS12345678910111213141516171819202122232425262728293031import sysfrom collections import dequeinput = sys.stdin.readlinecomputers = int(input())edges = int(input())networks = {}for i in range(computers): networks[i + 1] = set()for i in range(edges): a, b = map(int, input().split()) networks[a].add(b) networks[b].add(a)def bfs(network, start): queue = [start] while queue: for i in network[queue.pop()]: if i not in visited: visited.append(i) queue.append(i)visited = []bfs(networks, 1)print(len(visited) - 1) 소스코드_DFS(List)1234567891011121314151617181920212223242526import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readlinedef dfs(graph, v, visited): visited[v] = True for i in graph[v]: if not visited[i]: dfs(graph, i, visited)computers, edges = int(input()), int(input())networks = [[] for _ in range(computers + 1)]visited = [False] * (computers + 1)for i in range(edges): a, b = map(int, input().split()) networks[a].append(b) networks[b].append(a)dfs(networks, 1, visited)print(visited.count(True) - 1) 소스코드_DFS(Dict)1234567891011121314151617181920212223242526272829import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readlinecomputers = int(input())edges = int(input())networks = {}for i in range(computers): networks[i + 1] = set()for i in range(edges): a, b = map(int, input().split()) networks[a].add(b) networks[b].add(a)def dfs(graph, v, visited): visited[v] = True for i in graph[v]: if not visited[i]: dfs(graph, i, visited)visited = [False] * (computers + 1)dfs(networks, 1, visited)print(visited.count(True) - 1)","link":"/categories/Algorithm/Python/BAEKJOON-2606-21-04-08/"},{"title":"[백준] 2644번 촌수계산","text":"출처: [백준] 2644번 촌수계산 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 20625 9485 7194 45.397% 문제우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다. 여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오. 입력사람들은 1, 2, 3, …, n (1≤n≤100)의 연속된 번호로 각각 표시된다. 입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다. 그리고 셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다. 넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다. 각 사람의 부모는 최대 한 명만 주어진다. 출력입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다. 어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다. 예제 입력 11234567891097 371 21 32 72 82 94 54 6 예제 출력 113 출처Olympiad &gt; 한국정보올림피아드 &gt; KOI 1999 &gt; 중등부 1번 문제의 오타를 찾은 사람: dkdsla12, YunGoon 빠진 조건을 찾은 사람: jh05013 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_DFS12345678910111213141516171819202122232425262728293031import sysinput = sys.stdin.readlineN = int(input())comp1, comp2 = map(int, input().split())M = int(input())family = {}for i in range(N): family[i + 1] = set()for i in range(M): x, y = map(int, input().split()) family[x].add(y) family[y].add(x)def dfs(graph, target, count): visited[target] = count for i in graph[target]: if not visited[i]: dfs(graph, i, count + 1)visited = [False] * (N + 1)dfs(family, comp2, 1)if not visited[comp1]: print(-1)else: print(visited[comp1] - 1)","link":"/categories/Algorithm/Python/BAEKJOON-2644-21-04-26/"},{"title":"[백준] 2693번 N번째 큰 수","text":"출처: [백준] 2693번 N번째 큰 수 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 32 MB 3791 3044 2767 81.502% 문제배열 A가 주어졌을 때, N번째 큰 값을 출력하는 프로그램을 작성하시오. 배열 A의 크기는 항상 10이고, 자연수만 가지고 있다. N은 항상 3이다. 입력첫째 줄에 테스트 케이스의 개수 T(1 &lt;= T &lt;= 1,000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 배열 A의 원소 10개가 공백으로 구분되어 주어진다. 이 원소는 1보다 크거나 같고, 1,000보다 작거나 같은 자연수이다. 출력각 테스트 케이스에 대해 한 줄에 하나씩 배열 A에서 3번째 큰 값을 출력한다. 예제 입력 11234541 2 3 4 5 6 7 8 9 1000338 304 619 95 343 496 489 116 98 127931 240 986 894 826 640 965 833 136 138940 955 364 188 133 254 501 122 768 408 예제 출력 112348489931768 출처 ICPC &gt; Regionals &gt; North America &gt; Greater New York Region &gt; 2009 Greater New York Programming Contest A번 문제를 번역한 사람: baekjoon 잘못된 데이터를 찾은 사람: occidere 알고리즘 분류 구현 정렬 소스코드1234567891011import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): arr = list(map(int, input().split())) arr.sort(reverse=True) print(arr[2])","link":"/categories/Algorithm/Python/BAEKJOON-2693-21-06-19/"},{"title":"[백준] 2667번 단지번호붙이기","text":"출처: [백준] 2667번 단지번호붙이기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 80852 33112 20949 39.110% 문제&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. &lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오. 입력첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다. 출력첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오. 예제 입력 11234567870110100011010111101010000111010000001111100111000 예제 출력 112343789 힌트 출처 Olympiad &gt; 한국정보올림피아드 &gt; KOI 1996 &gt; 초등부 1번 잘못된 데이터를 찾은 사람: djm03178 데이터를 추가한 사람: djm03178, jh05013 문제의 오타를 찾은 사람: metadata 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_DFS(List)123456789101112131415161718192021222324252627282930313233343536import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readline# 방향 정의(상,하,좌,우)dx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]def dfs(x, y, house): ground[x][y] = 0 # 해당 지점은 확인 for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; N: if ground[nx][ny] == 1: house = dfs(nx, ny, house + 1) return houseN = int(input())ground = [list(map(int, input().rstrip())) for _ in range(N)]houses = [] # 각 단지내 집의 수for i in range(N): for j in range(N): if ground[i][j] == 1: houses.append(dfs(i, j, 1))print(len(houses))for house in sorted(houses): print(house)","link":"/categories/Algorithm/Python/BAEKJOON-2667-21-04-20/"},{"title":"[백준] 2630번 색종이 만들기","text":"출처: [백준] 2630번 색종이 만들기 문제아래 &lt;그림 1&gt;과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다. 전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다. 전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 &lt;그림 2&gt;의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다. 위와 같은 규칙에 따라 잘랐을 때 &lt;그림 3&gt;은 &lt;그림 1&gt;의 종이를 처음 나눈 후의 상태를, &lt;그림 4&gt;는 두 번째 나눈 후의 상태를, &lt;그림 5&gt;는 최종적으로 만들어진 다양한 크기의 9장의 하얀색 색종이와 7장의 파란색 색종이를 보여주고 있다. 입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때 잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오. 입력첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다. 색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다. 출력첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다. 예제 입력 112345678981 1 0 0 0 0 1 11 1 0 0 0 0 1 10 0 0 0 1 1 0 00 0 0 0 1 1 0 01 0 0 0 1 1 1 10 1 0 0 1 1 1 10 0 1 1 1 1 1 10 0 1 1 1 1 1 1 예제 출력 11297 힌트 출처 Olympiad &gt; 한국정보올림피아드 &gt; KOI 2001 &gt; 중등부 1번 잘못된 데이터를 찾은 사람: choiking10 문제의 오타를 찾은 사람: shoark7 데이터를 추가한 사람: troas96 알고리즘 분류 분할 정복 재귀 시간 제한 풀이 소스코드1 12345678910111213141516171819202122232425262728293031323334353637import sysinput = sys.stdin.readlineN = int(input())paper_list = [list(map(int, input().split())) for _ in range(N)]result = [] # white(0), blue(1)def check_same(x, y, d): color = paper_list[x][y] for i in range(x, x + d): for j in range(y, y + d): if paper_list[i][j] != color: return False return Truedef solution(x, y, d): if check_same(x, y, d): if paper_list[x][y]: result.append(1) else: result.append(0) else: d //= 2 solution(x, y, d) solution(x + d, y, d) solution(x, y + d, d) solution(x + d, y + d, d)solution(0, 0, N)print(result.count(0))print(result.count(1))","link":"/categories/Algorithm/Python/BAEKJOON-2630-21-04-01/"},{"title":"[백준] 2748번 피보나치 수2","text":"출처: [백준] 2748번 피보나치 수2 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 54967 21274 17729 38.752% 문제피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다. n=17일때 까지 피보나치 수를 써보면 다음과 같다. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597 n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 n이 주어진다. n은 90보다 작거나 같은 자연수이다. 출력첫째 줄에 n번째 피보나치 수를 출력한다. 예제 입력 1110 예제 출력 1155 힌트 출처 알고리즘 분류 수학 다이나믹 프로그래밍 비슷한 문제 2747번. 피보나치 수 2749번. 피보나치 수 3 10826번. 피보나치 수 4 10870번. 피보나치 수 5 풀이 소스코드 1 (반복문을 이용한 다이나믹 프로그래밍)12345678910111213import sysinput = sys.stdin.readlinefibo = [-1] * 100fibo[0] = 0fibo[1] = 1N = int(input())for i in range(2, N + 1): fibo[i] = fibo[i - 1] + fibo[i - 2]print(fibo[N]) 소스코드 2 (재귀를 이용한 다이나믹 프로그래밍)12345678910111213141516171819import sysinput = sys.stdin.readlinen = int(input())fibo_memo = [-1] * 99def fibo_dynamic(n): if n &lt;= 2: return 1 if fibo_memo[n] != -1: return fibo_memo[n] fibo_memo[n] = fibo_dynamic(n - 1) + fibo_dynamic(n - 2) return fibo_memo[n]print(fibo_dynamic(n))","link":"/categories/Algorithm/Python/BAEKJOON-2748-21-04-04/"},{"title":"[백준] 2740번 행렬곱셈","text":"출처: [백준] 2740번 행렬곱셈 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 6980 4853 4230 71.610% 문제N x M크기의 행렬 A와 M x K크기의 행렬 B가 주어졌을 때, 두 행렬을 곱하는 프로그램을 작성하시오. 입력첫째 줄에 행렬 A의 크기 N 과 M이 주어진다. 둘째 줄부터 N개의 줄에 행렬 A의 원소 M개가 순서대로 주어진다. 그 다음 줄에는 행렬 B의 크기 M과 K가 주어진다. 이어서 M개의 줄에 행렬 B의 원소 K개가 차례대로 주어진다. N과 M, 그리고 K는 100보다 작거나 같고, 행렬의 원소는 절댓값이 100보다 작거나 같은 정수이다. 출력첫째 줄부터 N개의 줄에 행렬 A와 B를 곱한 행렬을 출력한다. 행렬의 각 원소는 공백으로 구분한다. 예제 입력 112345673 21 23 45 62 3-1 -2 00 0 3 예제 출력 1123-1 -2 6-3 -6 12-5 -10 18 힌트 출처 잘못된 조건을 찾은 사람: bupjae 문제의 오타를 찾은 사람: ekdns7952 잘못된 데이터를 찾은 사람: WeissBlume 알고리즘 분류 수학 구현 시간 제한 풀이 소스코드12345678910111213141516171819202122import sysinput = sys.stdin.readlineN, M = map(int, input().split())A_matrix = [list(map(int, input().split())) for _ in range(N)]M, K = map(int, input().split())B_matrix = [list(map(int, input().split())) for _ in range(M)]result_matrix = [[0 for _ in range(K)] for _ in range(N)]for n in range(N): for k in range(K): for m in range(M): result_matrix[n][k] += A_matrix[n][m] * B_matrix[m][k]for row in result_matrix: for value in row: print(value, end=&quot; &quot;) print()","link":"/categories/Algorithm/Python/BAEKJOON-2740-21-04-03/"},{"title":"[백준] 2743번 단어 길이 재기","text":"출처: [백준] 2743번 단어 길이 재기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 14281 11663 10225 83.171% 문제알파벳으로만 이루어진 단어를 입력받아, 그 길이를 출력하는 프로그램을 작성하시오. 입력첫째 줄에 영어 소문자와 대문자로만 이루어진 단어가 주어진다. 단어의 길이는 최대 100이다. 출력첫째 줄에 입력으로 주어진 단어의 길이를 출력한다. 예제 입력 11pulljima 예제 출력 118 출처 데이터를 추가한 사람: 79brue 문제를 만든 사람: baekjoon 알고리즘 분류 구현 문자열 소스코드1234string = input()print(len(string))","link":"/categories/Algorithm/Python/BAEKJOON-2743-21-05-29/"},{"title":"[백준] 2747번 피보나치 수","text":"출처: [백준] 2747번 피보나치 수 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 (추가 시간 없음) 128 MB 41190 19031 15550 47.730% 문제피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다. n=17일때 까지 피보나치 수를 써보면 다음과 같다. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597 n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 n이 주어진다. n은 45보다 작거나 같은 자연수이다. 출력첫째 줄에 n번째 피보나치 수를 출력한다. 예제 입력 1110 예제 출력 1155 힌트 출처 알고리즘 분류 수학 구현 비슷한 문제 2748번. 피보나치 수 2 2749번. 피보나치 수 3 10826번. 피보나치 수 4 10870번. 피보나치 수 5 풀이 소스코드 1 (반복문을 이용한 다이나믹 프로그래밍)12345678910111213import sysinput = sys.stdin.readlinefibo = [-1] * 100fibo[0] = 0fibo[1] = 1N = int(input())for i in range(2, N + 1): fibo[i] = fibo[i - 1] + fibo[i - 2]print(fibo[N]) 소스코드 2 (재귀를 이용한 다이나믹 프로그래밍)123456789101112131415161718import sysinput = sys.stdin.readlinefibo = [-1] * 99def fibo_dp(n): if n &lt;= 1: return n elif fibo[n] != -1: return fibo[n] else: fibo[n] = fibo_dp(n - 1) + fibo_dp(n - 2) return fibo[n]N = int(input())print(fibo_dp(N))","link":"/categories/Algorithm/Python/BAEKJOON-2747-21-04-04/"},{"title":"[백준] 2749번 피보나치 수3","text":"출처: [백준] 2749번 피보나치 수3 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 17482 5649 4570 38.230% 문제피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다. n=17일때 까지 피보나치 수를 써보면 다음과 같다. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597 n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다. 출력첫째 줄에 n번째 피보나치 수를 1,000,000으로 나눈 나머지를 출력한다. 예제 입력 111000 예제 출력 11228875 힌트 피사노 주기 출처 문제를 만든 사람: baekjoon 알고리즘 분류 수학 분할 정복을 이용한 거듭제곱 비슷한 문제 2747번. 피보나치 수 2748번. 피보나치 수 2 10826번. 피보나치 수 4 10870번. 피보나치 수 5 풀이 소스코드 1 (반복문을 이용한 다이나믹 프로그래밍)1234567891011121314151617import sysinput = sys.stdin.readlinemod = 1000000p = int(mod / 10 * 15) # 피사노주기에 의해 M = 10^k 일 때, k &gt; 2 라면, 주기는 항상 15 × 10^(k-1) 입니다fibo = [0] * pfibo[1] = 1N = int(input())for i in range(2, p): fibo[i] = fibo[i - 1] + fibo[i - 2] fibo[i] %= modprint(fibo[N % p])","link":"/categories/Algorithm/Python/BAEKJOON-2749-21-04-04/"},{"title":"[백준] 2776번 암기왕","text":"출처: [백준] 2776번 암기왕 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 256 MB 10889 3396 1943 27.981% 문제연종이는 엄청난 기억력을 가지고 있다. 그래서 하루 동안 본 정수들을 모두 기억 할 수 있다. 하지만 이를 믿을 수 없는 동규는 그의 기억력을 시험해 보기로 한다. 동규는 연종을 따라 다니며, 연종이 하루 동안 본 정수들을 모두 ‘수첩1’에 적어 놓았다. 그것을 바탕으로 그가 진짜 암기왕인지 알아보기 위해, 동규는 연종에게 M개의 질문을 던졌다. 질문의 내용은 “X라는 정수를 오늘 본 적이 있는가?” 이다. 연종은 막힘없이 모두 대답을 했고, 동규는 연종이 봤다고 주장하는 수 들을 ‘수첩2’에 적어 두었다. 집에 돌아온 동규는 답이 맞는지 확인하려 하지만, 연종을 따라다니느라 너무 힘들어서 여러분에게 도움을 요청했다. 동규를 도와주기 위해 ‘수첩2’에 적혀있는 순서대로, 각각의 수에 대하여, ‘수첩1’에 있으면 1을, 없으면 0을 출력하는 프로그램을 작성해보자. 입력첫째 줄에 테스트케이스의 개수 T가 들어온다. 다음 줄에는 ‘수첩 1’에 적어 놓은 정수의 개수 N(1 ≤ N ≤ 1,000,000)이 입력으로 들어온다. 그 다음 줄에 ‘수첩 1’에 적혀 있는 정수들이 N개 들어온다. 그 다음 줄에는 ‘수첩 2’에 적어 놓은 정수의 개수 M(1 ≤ M ≤ 1,000,000) 이 주어지고, 다음 줄에 ‘수첩 2’에 적어 놓은 정수들이 입력으로 M개 들어온다. 모든 정수들의 범위는 int 로 한다. 출력‘수첩2’에 적혀있는 M개의 숫자 순서대로, ‘수첩1’에 있으면 1을, 없으면 0을 출력한다. 예제 입력 112345154 1 5 2 351 3 7 9 5 예제 출력 11234511001 출처 잘못된 데이터를 찾은 사람: august14, djm03178 문제의 오타를 찾은 사람: chjiiwon30 알고리즘 분류 자료 구조 정렬 이분 탐색 해시를 사용한 집합과 맵 12345678910111213141516171819import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): N = int(input()) N_Note = set(map(int, input().split())) M = int(input()) M_Note = list(map(int, input().split())) for num in M_Note: if num in N_Note: print(1) else: print(0)","link":"/categories/Algorithm/Python/BAEKJOON-2776-21-07-03/"},{"title":"[백준] 2798번 블랙잭","text":"출처: [백준] 2798번 블랙잭 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 61157 27608 21782 44.404% 문제카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다. 한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다. 김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다. 이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다. N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오. 입력첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다. 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다. 출력첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다. 예제 입력 1125 215 6 7 8 9 예제 출력 1121 예제 입력 21210 50093 181 245 214 315 36 185 138 216 295 예제 출력 21497 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2011/2012 &gt; Contest #6 1번 문제를 번역한 사람: baekjoon 빠진 조건을 찾은 사람: bupjae 문제의 오타를 찾은 사람: eric00513, joonas, otter66 알고리즘 분류 브루트포스 알고리즘 소스코드123456789101112131415161718import sysfrom itertools import combinationsinput = sys.stdin.readlinen, m = map(int, input().split())cards_list = list(map(int, input().split()))result = list(combinations(cards_list, 3))max_sum = 0for cards in result: temp_sum = sum(cards) if m &gt;= temp_sum &gt; max_sum: max_sum = temp_sumprint(max_sum) 소스코드12345678910111213141516import sysinput = sys.stdin.readlineN, M = map(int, input().split())cards_list = list(map(int, input().split()))max_sum = 0for i in range(N): for j in range(i + 1, N): for k in range(j + 1, N): if M &gt;= cards_list[i] + cards_list[j] + cards_list[k] &gt; max_sum: max_sum = cards_list[i] + cards_list[j] + cards_list[k]print(max_sum)","link":"/categories/Algorithm/Python/BAEKJOON-2798-21-03-07/"},{"title":"[백준] 2810번 컵홀더","text":"출처: [백준] 2810번 컵홀더 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 5819 2412 2094 40.787% 문제십년이면 강산이 변한다. 강산이네 동네에 드디어 극장이 생겼고, 강산이는 극장에 놀러갔다. 매점에서 콜라를 산 뒤, 자리에 앉은 강산이는 큰 혼란에 빠졌다. 양쪽 컵홀더를 이미 옆 사람들이 차지했기 때문에 콜라를 꽂을 컵 홀더가 없었기 때문이다. 영화를 보는 내내 콜라를 손에 들고 있던 강산이는 극장에 다시 왔을 때는 꼭 콜라를 컵 홀더에 놓겠다는 다짐을 한 후 집에 돌아갔다. 극장의 한 줄에는 자리가 N개가 있다. 서로 인접한 좌석 사이에는 컵홀더가 하나씩 있고, 양 끝 좌석에는 컵홀더가 하나씩 더 있다. 또, 이 극장에는 커플석이 있다. 커플석 사이에는 컵홀더가 없다. 극장의 한 줄의 정보가 주어진다. 이때, 이 줄에 사람들이 모두 앉았을 때, 컵홀더에 컵을 꽂을 수 있는 최대 사람의 수를 구하는 프로그램을 작성하시오. 모든 사람은 컵을 한 개만 들고 있고, 자신의 좌석의 양 옆에 있는 컵홀더에만 컵을 꽂을 수 있다. S는 일반 좌석, L은 커플석을 의미하며, L은 항상 두개씩 쌍으로 주어진다. 어떤 좌석의 배치가 SLLLLSSLL일때, 컵홀더를 *로 표시하면 아래와 같다. 1*S*LL*LL*S*S*LL* 위의 예에서 적어도 두 명은 컵홀더를 사용할 수 없다. 입력첫째 줄에 좌석의 수 N이 주어진다. (1 ≤ N ≤ 50) 둘째 줄에는 좌석의 정보가 주어진다. 출력컵을 컵홀더에 놓을 수 있는 최대 사람의 수를 출력한다. 예제 입력 1123SSS 예제 출력 113 예제 입력 2124SLLS 예제 출력 214 예제 입력 3129SLLLLSSLL 예제 출력 317 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2011/2012 &gt; Contest #4 1번 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: silvercube 알고리즘 분류 구현 문자열 그리디 알고리즘 소스코드1234567891011121314import sysinput = sys.stdin.readlineN = int(input())seats = input().rstrip()couples = seats.count('LL')if couples &lt; 2: print(len(seats))else: print(len(seats) - couples + 1)","link":"/categories/Algorithm/Python/BAEKJOON-2810-21-08-05/"},{"title":"[백준] 2841번 외계인의 기타 연주","text":"출처: [백준] 2841번 외계인의 기타 연주 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 5543 2390 1881 42.605% 문제상근이의 상상의 친구 외계인은 손가락을 수십억개 가지고 있다. 어느 날 외계인은 기타가 치고 싶었고, 인터넷에서 간단한 멜로디를 검색했다. 이제 이 기타를 치려고 한다. 보통 기타는 1번 줄부터 6번 줄까지 총 6개의 줄이 있고, 각 줄은 P개의 프렛으로 나누어져 있다. 프렛의 번호도 1번부터 P번까지 나누어져 있다. 멜로디는 음의 연속이고, 각 음은 줄에서 해당하는 프렛을 누르고 줄을 튕기면 연주할 수 있다. 예를 들면, 4번 줄의 8번 프렛을 누르고 튕길 수 있다. 만약, 어떤 줄의 프렛을 여러 개 누르고 있다면, 가장 높은 프렛의 음이 발생한다. 예를 들어, 3번 줄의 5번 프렛을 이미 누르고 있다고 하자. 이때, 7번 프렛을 누른 음을 연주하려면, 5번 프렛을 누르는 손을 떼지 않고 다른 손가락으로 7번 프렛을 누르고 줄을 튕기면 된다. 여기서 2번 프렛의 음을 연주하려고 한다면, 5번과 7번을 누르던 손가락을 뗀 다음에 2번 프렛을 누르고 연주해야 한다. 이렇게 손가락으로 프렛을 한 번 누르거나 떼는 것을 손가락을 한 번 움직였다고 한다. 어떤 멜로디가 주어졌을 때, 손가락의 가장 적게 움직이는 회수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 멜로디에 포함되어 있는 음의 수 N과 한 줄에 있는 프렛의 수 P가 주어진다. (N ≤ 500,000, 2 ≤ P ≤ 300,000) 다음 N개 줄에는 멜로디의 한 음을 나타내는 두 정수가 주어진다. 첫 번째 정수는 줄의 번호이고 두 번째 정수는 그 줄에서 눌러야 하는 프렛의 번호이다. 입력으로 주어진 음의 순서대로 기타를 연주해야 한다. 출력첫째 줄에 멜로디를 연주하는데 필요한 최소 손가락 움직임을 출력한다. 예제 입력 11234565 152 82 102 122 102 5 예제 출력 117 예제 입력 2123456787 151 52 32 52 72 41 51 3 예제 출력 219 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2010/2011 &gt; Contest #7 3번 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: wxogus25 알고리즘 분류 자료 구조 스택 소스코드1234567891011121314151617181920212223242526272829303132333435import sysinput = sys.stdin.readlineN, P = map(int, input().split())melody = [[] for _ in range(7)]count = 0for _ in range(N): a, b = map(int, input().split()) if melody[a]: if melody[a][-1] &lt; b: melody[a].append(b) count += 1 elif melody[a][-1] &gt; b: while melody[a][-1] &gt; b: melody[a].pop() count += 1 if not melody[a]: break if melody[a] and melody[a][-1] == b: continue else: melody[a].append(b) count += 1 elif melody[a][-1] == b: continue else: melody[a].append(b) count += 1print(count)","link":"/categories/Algorithm/Python/BAEKJOON-2841-21-07-16/"},{"title":"[백준] 2847번 게임을 만든 동준이","text":"출처: [백준] 2847번 게임을 만든 동준이 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 6784 3091 2711 45.794% 문제학교에서 그래픽스 수업을 들은 동준이는 수업시간에 들은 내용을 바탕으로 스마트폰 게임을 만들었다. 게임에는 총 N개의 레벨이 있고, 각 레벨을 클리어할 때 마다 점수가 주어진다. 플레이어의 점수는 레벨을 클리어하면서 얻은 점수의 합으로, 이 점수를 바탕으로 온라인 순위를 매긴다. 동준이는 레벨을 난이도 순으로 배치했다. 하지만, 실수로 쉬운 레벨이 어려운 레벨보다 점수를 많이 받는 경우를 만들었다. 이 문제를 해결하기 위해 동준이는 특정 레벨의 점수를 감소시키려고 한다. 이렇게해서 각 레벨을 클리어할 때 주는 점수가 증가하게 만들려고 한다. 각 레벨을 클리어할 때 얻는 점수가 주어졌을 때, 몇 번 감소시키면 되는지 구하는 프로그램을 작성하시오. 점수는 항상 양수이어야 하고, 1만큼 감소시키는 것이 1번이다. 항상 답이 존재하는 경우만 주어진다. 정답이 여러 가지인 경우에는 점수를 내리는 것을 최소한으로 하는 방법을 찾아야 한다. 입력첫째 줄에 레벨의 수 N이 주어진다. (1 ≤ N ≤ 100) 다음 N개 줄에는 각 레벨을 클리어하면 얻는 점수가 첫 번째 레벨부터 마지막 레벨까지 순서대로 주어진다. 점수는 20,000보다 작은 양의 정수이다. 출력첫째 줄에 점수를 몇 번 감소시키면 되는지 출력한다. 예제 입력 112343555 예제 출력 113 예제 입력 21234545375 예제 출력 216 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2010/2011 &gt; Contest #6 3번 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: kdy312, occidere 알고리즘 분류 그리디 알고리즘 소스코드12345678910111213141516171819import sysinput = sys.stdin.readlineN = int(input())levels = [int(input()) for _ in range(N)]result = 0max_level = levels[-1]for i in range(N - 2, -1, -1): if levels[i] &gt;= max_level: temp = max_level - 1 result += levels[i] - temp max_level = levels[i] = temp else: max_level = levels[i]print(result)","link":"/categories/Algorithm/Python/BAEKJOON-2847-21-08-06/"},{"title":"[백준]2865번 나는 위대한 슈퍼스타K","text":"출처: [백준] 2865번 나는 위대한 슈퍼스타K 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 1279 509 439 41.572% 문제상근이는 한국 최고의 가수를 뽑는 “나는 위대한 슈퍼스타K”의 감독이다. 상근이는 다음과 같이 참가자를 선발하려고 한다. “나는 위대한 슈퍼스타K”의 예선에는 N명이 참가했고, 서로 다른 M개 장르에 대한 오디션을 보았다. 심사위원은 모든 참가자의 각 장르에 대한 능력을 점수로 매겼다. 이 점수는 실수로 나타낸다. 본선에는 총 K명이 나갈 수 있다. 각 참가자는 본선에서 단 하나의 장르만 부를 수 있고, 이 장르는 상근이가 정해준다. 한 사람이 여러 장르를 부를 수는 없지만, 여러 사람이 같은 장르를 부를 수는 있다. 모든 참가자의 각 장르에 대한 능력이 주어진다. 이때, 능력의 합이 최대가 되도록 참가자와 장르를 선택하는 프로그램을 작성하시오. 입력첫째 줄에 N, M, K가 주어진다. (1 ≤ M ≤ 100, 1 ≤ K ≤ N ≤ 100) 다음 M개의 줄은 각 장르에 대한 참가자의 능력이 주어진다. 이 줄에는 N개의 (i, s)쌍이 주어진다. 여기서 i는 참가자의 번호, s는 그 참가자의 장르에 대한 능력이다. 이 쌍은 능력이 감소하는 순서대로 주어진다. 참가자의 번호는 1부터 N까지 이다. 각 줄에 모든 학생은 한 번씩 등장한다. 출력첫째 줄에 본선 참가자의 능력의 합을 소수점 첫째자리까지 반올림해 출력한다. 예제 입력 1123454 4 34 5.0 2 4.0 3 2.0 1 1.02 2.0 3 1.0 1 0.5 4 0.34 6.0 3 5.0 2 2.0 1 0.01 4.0 2 3.0 4 0.6 3 0.3 예제 출력 1115.0 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2010/2011 &gt; Contest #3 3번 문제를 번역한 사람: baekjoon 알고리즘 분류 자료 구조 그리디 알고리즘 정렬 우선순위 큐 소스코드1234567891011121314151617181920212223import sysinput = sys.stdin.readlineN, M, K = map(int, input().split())skills = {}for i in range(N): skills[i + 1] = 0for i in range(M): genre = list(map(float, input().split())) for j in range(0, N * 2, 2): if genre[j + 1] &gt; skills[genre[j]]: skills[genre[j]] = genre[j + 1] # print(skills)score = sorted(list(skills.values()), reverse=True)# print(score)total_sum = sum(score[:K])print('%.1f' % total_sum)","link":"/categories/Algorithm/Python/BAEKJOON-2865-21-05-19/"},{"title":"[백준] 2902번 KMP는 왜 KMP일까?","text":"출처: [백준] 2902번 KMP는 왜 KMP일까? 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 11163 8826 7996 80.768% 문제KMP 알고리즘이 KMP인 이유는 이를 만든 사람의 성이 Knuth, Morris, Prett이기 때문이다. 이렇게 알고리즘에는 발견한 사람의 성을 따서 이름을 붙이는 경우가 많다. 또 다른 예로, 유명한 비대칭 암호화 알고리즘 RSA는 이를 만든 사람의 이름이 Rivest, Shamir, Adleman이다. 사람들은 이렇게 사람 성이 들어간 알고리즘을 두 가지 형태로 부른다. 첫 번째는 성을 모두 쓰고, 이를 하이픈(-)으로 이어 붙인 것이다. 예를 들면, Knuth-Morris-Pratt이다. 이것을 긴 형태라고 부른다. 두 번째로 짧은 형태는 만든 사람의 성의 첫 글자만 따서 부르는 것이다. 예를 들면, KMP이다. 동혁이는 매일매일 자신이 한 일을 모두 메모장에 적어놓는다. 잠을 자기 전에, 오늘 하루 무엇을 했는지 되새겨 보는 것으로 하루를 마감한다. 하루는 이 메모를 보던 중, 지금까지 긴 형태와 짧은 형태를 섞어서 적어 놓은 것을 발견했다. 이렇게 긴 형태로 하루 일을 기록하다가는 메모장 가격이 부담되어 파산될 것이 뻔하기 때문에, 앞으로는 짧은 형태로 기록하려고 한다. 긴 형태의 알고리즘 이름이 주어졌을 때, 이를 짧은 형태로 바꾸어 출력하는 프로그램을 작성하시오. 입력입력은 한 줄로 이루어져 있고, 최대 100글자의 영어 알파벳 대문자, 소문자, 그리고 하이픈 (‘-‘, 아스키코드 45)로만 이루어져 있다. 첫 번째 글자는 항상 대문자이다. 그리고, 하이픈 뒤에는 반드시 대문자이다. 그 외의 모든 문자는 모두 소문자이다. 출력첫 줄에 짧은 형태 이름을 출력한다. 예제 입력 11Knuth-Morris-Pratt 예제 출력 11KMP 예제 입력 21Mirko-Slavko 예제 출력 21MS 예제 입력 31Pasko-Patak 예제 출력 31PP 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2009/2010 &gt; Contest #4 1번 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: eric00513 빠진 조건을 찾은 사람: hoy9090 알고리즘 분류 구현 문자열 소스코드11234567input_string = list(input().split('-'))output_string = ''for x in input_string: output_string += x[0]print(output_string) 소스코드2123456789input_string = list(input().rstrip())output_string = ''for x in input_string: if 'A' &lt;= x &lt;= 'Z': output_string += xprint(output_string)","link":"/categories/Algorithm/Python/BAEKJOON-2902-21-06-14/"},{"title":"[백준] 3020번 개똥벌레","text":"출처: [백준] 3020번 개똥벌레 문제개똥벌레 한 마리가 장애물(석순과 종유석)로 가득찬 동굴에 들어갔다. 동굴의 길이는 N미터이고, 높이는 H미터이다. (N은 짝수) 첫 번째 장애물은 항상 석순이고, 그 다음에는 종유석과 석순이 번갈아가면서 등장한다. 아래 그림은 길이가 14미터이고 높이가 5미터인 동굴이다. (예제 그림) 이 개똥벌레는 장애물을 피하지 않는다. 자신이 지나갈 구간을 정한 다음 일직선으로 지나가면서 만나는 모든 장애물을 파괴한다. 위의 그림에서 4번째 구간으로 개똥벌레가 날아간다면 파괴해야하는 장애물의 수는 총 여덟개이다. (4번째 구간은 길이가 3인 석순과 길이가 4인 석순의 중간지점을 말한다) 하지만, 첫 번째 구간이나 다섯 번째 구간으로 날아간다면 개똥벌레는 장애물 일곱개만 파괴하면 된다. 동굴의 크기와 높이, 모든 장애물의 크기가 주어진다. 이때, 개똥벌레가 파괴해야하는 장애물의 최솟값과 그러한 구간이 총 몇 개 있는지 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 H가 주어진다. N은 항상 짝수이다. (2 ≤ N ≤ 200,000, 2 ≤ H ≤ 500,000) 다음 N개 줄에는 장애물의 크기가 순서대로 주어진다. 장애물의 크기는 H보다 작은 양수이다. 출력첫째 줄에 개똥벌레가 파괴해야 하는 장애물의 최솟값과 그러한 구간의 수를 공백으로 구분하여 출력한다. 예제 입력 112345678910111213141514 513422434333233 예제 출력 117 2 힌트 출처Olympiad &gt; Croatian Highschool Competitions in Informatics &gt; 2007 &gt; Croatian Regional Competition in Informatics 2007 3번 Olympiad &gt; Croatian Highschool Competitions in Informatics &gt; 2007 &gt; Regional Competition - Juniors 4번 문제를 번역한 사람: baekjoon 어색한 표현을 찾은 사람: citizen 알고리즘 분류 이분 탐색 누적 합 풀이 소스코드Using Bisect123456789101112131415161718192021222324252627282930313233import sysfrom bisect import bisect_leftinput = sys.stdin.readlineN, H = map(int, input().split())down = []up = []for i in range(N): if i % 2 == 0: # 짝수: 석순 down.append(int(input())) else: up.append(int(input()))down.sort()up.sort()min_count = Nresult = 0for i in range(1, H + 1): down_count = len(down) - bisect_left(down, i - 0.5) up_count = len(up) - bisect_left(up, H - i + 0.5) if min_count == down_count + up_count: result += 1 elif min_count &gt; down_count + up_count: result = 1 min_count = down_count + up_countprint(min_count, result) non Bisect123456789101112131415161718192021222324252627282930313233343536373839404142434445import sysinput = sys.stdin.readlineN, H = map(int, input().split())down = []up = []for i in range(N): if i % 2 == 0: # 짝수: 석순 down.append(int(input())) else: up.append(int(input()))down.sort()up.sort()def binary_search(array, target, start, end): while start &lt;= end: mid = (start + end) // 2 if array[mid] &lt; target: start = mid + 1 else: end = mid - 1 return startmin_count = Nresult = 0for i in range(1, H + 1): down_count = len(down) - binary_search(down, i - 0.5, 0, len(down) - 1) up_count = len(up) - binary_search(up, H - i + 0.5, 0, len(up) - 1) if min_count == down_count + up_count: result += 1 elif min_count &gt; down_count + up_count: result = 1 min_count = down_count + up_countprint(min_count, result)","link":"/categories/Algorithm/Python/BAEKJOON-3020-21-03-20/"},{"title":"[백준] 3046번 R2","text":"출처: [백준] 3046번 R2 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 14772 12053 11178 82.788% 문제두 숫자 R1과 R2가 있을 때, 두 수의 평균 S는 (R1+R2)/2와 같다. 상근이는 정인이 생일 선물로 두 숫자 R1과 R2를 주려고 한다. 생일 파티에서 상근이는 정인이에게 이 두 숫자를 말해주고, 정인이는 이 숫자를 받아 적는다. 그리고 나서 기쁜 마음으로 1년동안 이 숫자를 외우면서 산다. 상근이는 R1과 R2를 엄청난 고민 끝에 정했다. 작년에는 R1과 R2를 까먹어서 아무 숫자나 정해서 주었기 때문에, 올해는 까먹지 않기 위해서 평균 S도 같이 기억하려고 한다. 오늘은 정인이 생일이다. 5분 후에 상근이는 생일 선물로 두 숫자 R1과 R2를 말해주어야 하지만, 안타깝게도 R2를 까먹고 말았다. 하지만 R1과 S는 기억하고 있다! 상근이를 도와 R2가 몇 인지 구하는 프로그램을 작성하시오. 입력첫째 줄에 두 정수 R1과 S가 주어진다. 두 수는 -1000보다 크거나 같고, 1000보다 작거나 같다. 출력첫째 줄에 R2를 출력한다. 예제 입력 1111 15 예제 출력 1119 예제 입력 214 3 예제 출력 212 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2006/2007 &gt; Contest #2 1번 문제를 번역한 사람: baekjoon 알고리즘 분류 수학 구현 사칙연산 소스코드1234R1, S = map(int, input().split())print(S * 2 - R1)","link":"/categories/Algorithm/Python/BAEKJOON-3046-21-06-15/"},{"title":"[백준] 3009번 네 번째 점","text":"출처: [백준] 3009번 네 번째 점 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 16000 11461 10418 73.335% 문제세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오. 입력세 점의 좌표가 한 줄에 하나씩 주어진다. 좌표는 1보다 크거나 같고, 1000보다 작거나 같은 정수이다. 출력직사각형의 네 번째 점의 좌표를 출력한다. 예제 입력 112330 2010 1010 20 예제 출력 1130 10 힌트 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2007/2008 &gt; Contest #1 1번 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: onjo0127 데이터를 추가한 사람: pichulia 알고리즘 분류 구현 기하학 링크 TJU Online Judge 풀이 소스코드1234567891011121314151617181920import sysinput = sys.stdin.readlinex_list = []y_list = []for _ in range(3): x, y = map(int, input().split()) x_list.append(x) y_list.append(y)for i in range(3): if x_list.count(x_list[i]) == 1: x = x_list[i] if y_list.count(y_list[i]) == 1: y = y_list[i]print(x, y)","link":"/categories/Algorithm/Python/BAEKJOON-3009-21-04-06/"},{"title":"[백준] 3085번 사탕게임","text":"출처: [백준] 3085번 사탕게임 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 17749 5491 3869 30.534% 문제상근이는 어렸을 적에 “봄보니 (Bomboni)” 게임을 즐겨했다. 가장 처음에 N×N크기에 사탕을 채워 놓는다. 사탕의 색은 모두 같지 않을 수도 있다. 상근이는 사탕의 색이 다른 인접한 두 칸을 고른다. 그 다음 고른 칸에 들어있는 사탕을 서로 교환한다. 이제, 모두 같은 색으로 이루어져 있는 가장 긴 연속 부분(행 또는 열)을 고른 다음 그 사탕을 모두 먹는다. 사탕이 채워진 상태가 주어졌을 때, 상근이가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 보드의 크기 N이 주어진다. (3 ≤ N ≤ 50) 다음 N개 줄에는 보드에 채워져 있는 사탕의 색상이 주어진다. 빨간색은 C, 파란색은 P, 초록색은 Z, 노란색은 Y로 주어진다. 사탕의 색이 다른 인접한 두 칸이 존재하는 입력만 주어진다. 출력첫째 줄에 상근이가 먹을 수 있는 사탕의 최대 개수를 출력한다. 예제 입력 112343CCPCCPPPC 예제 출력 113 예제 입력 2123454PPPPCYZYCCPYPPCC 예제 출력 214 예제 입력 31234565YCPZYCYZZPCCPPPYCYZCCPPZZ 예제 출력 314 힌트예제 3의 경우 4번 행의 Y와 C를 바꾸면 사탕 네 개를 먹을 수 있다. 출처 Olympiad &gt; Croatian Highschool Competitions in Informatics &gt; 2012 &gt; Junior Croatian Olympiad in Informatics - Exam #1 1번 데이터를 추가한 사람: 10jobss, sanhaehong 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: jh05013 잘못된 조건을 찾은 사람: juhyun16 알고리즘 분류 구현 브루트포스 알고리즘 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import sysinput = sys.stdin.readlinedef check(arr): n = len(board) answer = 1 for i in range(n): cnt = 1 for j in range(1, n): # 열 순회하면서 연속 숫자 세기 if arr[i][j] == arr[i][j - 1]: # 이전것과 같으면 cnt+1 cnt += 1 else: # 이전 것과 다르면 cnt=1 초기화 cnt = 1 if cnt &gt; answer: answer = cnt cnt = 1 for j in range(1, n): # 행 순회하면서 연속 숫자 세기 if arr[j][i] == arr[j - 1][i]: # 이전것과 같으면 cnt+1 cnt += 1 else: # 이전 것과 다르면 cnt=1 초기화 cnt = 1 if cnt &gt; answer: answer = cnt return answerN = int(input())board = [list(input().rstrip()) for _ in range(N)]result = 0for i in range(N): for j in range(N): if j + 1 &lt; N: # 열 체크 board[i][j], board[i][j + 1] = board[i][j + 1], board[i][j] # 인접 교환 temp = check(board) if temp &gt; result: result = temp board[i][j], board[i][j + 1] = board[i][j + 1], board[i][j] # 원복 if i + 1 &lt; N: # 행 체크 board[i][j], board[i + 1][j] = board[i + 1][j], board[i][j] # 인접 교환 temp = check(board) if temp &gt; result: result = temp board[i][j], board[i + 1][j] = board[i + 1][j], board[i][j] # 원복print(result)","link":"/categories/Algorithm/Python/BAEKJOON-3085-21-06-19/"},{"title":"[백준] 3190번 뱀","text":"출처: [백준] 3190번 뱀 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 36404 14381 9512 37.674% 문제 ‘Dummy’ 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다. 게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다. 뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다. 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다. 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다. 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다. 사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라. 입력첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100) 다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다. 다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100) 다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데, 정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 ‘L’) 또는 오른쪽(C가 ‘D’)로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다. 출력첫째 줄에 게임이 몇 초에 끝나는지 출력한다. 예제 입력 1123456789633 42 55 333 D15 L17 D 예제 출력 119 예제 입력 212345678910111041 21 31 41 548 D10 D11 D13 L 예제 출력 2121 예제 입력 31234567891011121051 51 31 21 61 748 D10 D11 D13 L 예제 출력 3113 출처 Olympiad &gt; Croatian Highschool Competitions in Informatics &gt; 2005 &gt; National Competition #1 - Juniors 2번 문제의 오타를 찾은 사람: dlwocks31, hax3 빠진 조건을 찾은 사람: doju, joonas, zhsks311 문제를 번역한 사람: sehun 알고리즘 분류 구현 자료 구조 시뮬레이션 덱 큐 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import sysfrom collections import dequeinput = sys.stdin.readlineN = int(input())board = [[0] * (N) for _ in range(N)] # NxN 보드 생성K = int(input()) # 사과 개수for _ in range(K): # 사과 위치 지정 0:없음, 1:있음 y, x = map(int, input().split()) board[y - 1][x - 1] = 2# 우, 하, 좌, 상 // 시계방향dx = [1, 0, -1, 0]dy = [0, 1, 0, -1]L = int(input()) # 방향 전환 횟수times = deque()directions = deque()for _ in range(L): time, dire = input().rstrip().split() times.append(int(time)) directions.append(dire)count = 0direction = 0nx, ny = 0, 0 # 초기위치visited = deque([[ny, nx]])while True: count += 1 # 칸 이동 nx += dx[direction] ny += dy[direction] if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; N and board[ny][nx] != 1: # 보드 체크 # 사과가 있으면 그냥 추가, 없으면 꼬리 제거하고 추가 if board[ny][nx] == 0: # 사과가 없으면 temp_y, temp_x = visited.popleft() board[temp_y][temp_x] = 0 # 꼬리 줄어듬 board[ny][nx] = 1 visited.append([ny, nx]) else: print(count) exit(0) if count in times: dire = directions.popleft() if dire == 'D': direction += 1 if direction &gt; 3: direction = 0 else: direction -= 1 if direction &lt; 0: direction = 3","link":"/categories/Algorithm/Python/BAEKJOON-3190-21-07-22/"},{"title":"[백준] 4889번 안정적인 문자열","text":"출처: [백준] 4889번 안정적인 문자열 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 2235 1068 890 46.793% 문제여는 괄호와 닫는 괄호만으로 이루어진 문자열이 주어진다. 여기서 안정적인 문자열을 만들기 위한 최소 연산의 수를 구하려고 한다. 안정적인 문자열의 정의란 다음과 같다. 123451. 빈 문자열은 안정적이다.2. S가 안정적이라면, {S}도 안정적인 문자열이다.3. S와 T가 안정적이라면, ST(두 문자열의 연결)도 안정적이다.{}, {}{}, {{}{}}는 안정적인 문자열이지만, }{, {{}{, {}{는 안정적인 문자열이 아니다. 문자열에 행할 수 있는 연산은 여는 괄호를 닫는 괄호로 바꾸거나, 닫는 괄호를 여는 괄호로 바꾸는 것 2가지이다. 입력입력은 여러 개의 데이터 세트로 이루어져 있다. 각 데이터 세트는 한 줄로 이루어져 있다. 줄에는 여는 괄호와 닫는 괄호만으로 이루어진 문자열이 주어진다. 문자열의 길이가 2000을 넘는 경우는 없고, 항상 길이는 짝수이다. 입력의 마지막 줄은 ‘-‘가 한 개 이상 주어진다. 출력각 테스트 케이스에 대해서, 테스트 케이스 번호와 입력으로 주어진 문자열을 안정적으로 바꾸는데 필요한 최소 연산의 수를 출력한다. 예제 입력 11234}{{}{}{}{{{}--- 예제 출력 11231. 22. 03. 1 출처 ICPC &gt; Regionals &gt; Africa and Arab &gt; Arab Collegiate Programming Contest &gt; 2009 Arab Collegiate Programming Contest A번 문제를 번역한 사람: baekjoon 알고리즘 분류 자료 구조 문자열 스택 소스코드1234567891011121314151617181920212223242526import mathimport sysinput = sys.stdin.readlinei = 0while True: i += 1 input_string = list(input().rstrip()) if input_string[0] == '-': break else: open_bracket = [] close_bracket = [] for x in input_string: if x == '{': open_bracket.append(x) elif x == '}': if open_bracket: open_bracket.pop() else: close_bracket.append(x) count = math.ceil(len(open_bracket) / 2) + math.ceil(len(close_bracket) / 2) print(f&quot;{i}. {count}&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-4889-21-07-16/"},{"title":"[백준] 3986번 좋은 단어","text":"출처: [백준] 3986번 좋은 단어 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 7866 3720 3094 48.863% 문제이번 계절학기에 심리학 개론을 수강 중인 평석이는 오늘 자정까지 보고서를 제출해야 한다. 보고서 작성이 너무 지루했던 평석이는 노트북에 엎드려서 꾸벅꾸벅 졸다가 제출 마감 1시간 전에 깨고 말았다. 안타깝게도 자는 동안 키보드가 잘못 눌려서 보고서의 모든 글자가 A와 B로 바뀌어 버렸다! 그래서 평석이는 보고서 작성을 때려치우고 보고서에서 ‘좋은 단어’나 세보기로 마음 먹었다. 평석이는 단어 위로 아치형 곡선을 그어 같은 글자끼리(A는 A끼리, B는 B끼리) 쌍을 짓기로 하였다. 만약 선끼리 교차하지 않으면서 각 글자를 정확히 한 개의 다른 위치에 있는 같은 글자와 짝 지을수 있다면, 그 단어는 ‘좋은 단어’이다. 평석이가 ‘좋은 단어’ 개수를 세는 것을 도와주자. 입력첫째 줄에 단어의 수 N이 주어진다. (1 ≤ N ≤ 100) 다음 N개 줄에는 A와 B로만 이루어진 단어가 한 줄에 하나씩 주어진다. 단어의 길이는 2와 100,000사이이며, 모든 단어 길이의 합은 1,000,000을 넘지 않는다. 출력첫째 줄에 좋은 단어의 수를 출력한다. 예제 입력 112343ABABAABBABBA 예제 출력 112 예제 입력 212343AAAAAAB 예제 출력 211 예제 입력 3121ABBABB 예제 출력 311 출처 Contest &gt; Croatian Open Competition in Informatics &gt; COCI 2012/2013 &gt; Contest #4 2번 문제를 번역한 사람: baekjoon, csehydrogen 알고리즘 분류 자료 구조 문자열 스택 소스코드123456789101112131415161718192021222324import sysinput = sys.stdin.readlineN = int(input())cnt = 0for _ in range(N): stack = [] word = list(input().rstrip()) while word: temp = word.pop() if not stack: stack.append(temp) else: if stack[-1] == temp: stack.pop() else: stack.append(temp) if not stack: cnt += 1print(cnt)","link":"/categories/Algorithm/Python/BAEKJOON-3986-21-07-08/"},{"title":"[백준] 4153번 직각삼각형","text":"출처: [백준] 4153번 직각삼각형 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 23581 12574 11416 53.629% 문제과거 이집트인들은 각 변들의 길이가 3, 4, 5인 삼각형이 직각 삼각형인것을 알아냈다. 주어진 세변의 길이로 삼각형이 직각인지 아닌지 구분하시오. 입력입력은 여러개의 테스트케이스로 주어지며 마지막줄에는 0 0 0이 입력된다. 각 테스트케이스는 모두 30,000보다 작은 양의 정수로 주어지며, 각 입력은 변의 길이를 의미한다. 출력각 입력에 대해 직각 삼각형이 맞다면 “right”, 아니라면 “wrong”을 출력한다. 예제 입력 112346 8 1025 52 605 12 130 0 0 예제 출력 1123rightwrongright 힌트 출처 Contest &gt; Waterloo’s local Programming Contests &gt; 2 October, 2010 A번 문제를 번역한 사람: josephwon0310 잘못된 데이터를 찾은 사람: occidere 알고리즘 분류 수학 기하학 풀이 소스코드 11234567891011121314import sysinput = sys.stdin.readlinewhile True: edge_list = list(map(int, input().split())) edge_list.sort() if edge_list[0] == 0: break if edge_list[0] ** 2 + edge_list[1] ** 2 == edge_list[2] ** 2: print('right') else: print(&quot;wrong&quot;) 소스코드 2123456789101112131415import sysinput = sys.stdin.readlinewhile True: edge_list = list(map(int, input().split())) long_edge=max(edge_list) if long_edge == 0: break edge_list.remove(long_edge) if edge_list[0] ** 2 + edge_list[1] ** 2 == long_edge ** 2: print('right') else: print(&quot;wrong&quot;)","link":"/categories/Algorithm/Python/BAEKJOON-4153-21-04-06/"},{"title":"[백준] 1011번 Fly me to the Alpha Centauri","text":"출처: [백준] 1011번 Fly me to the Alpha Centauri 문제우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다. 그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 k-1 , k 혹은 k+1 광년만을 다시 이동할 수 있다. 예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다. ) 김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 x지점에서 y지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 y지점에 도착해서도 공간 이동장치의 안전성을 위하여 y지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다. 김우현을 위해 x지점부터 정확히 y지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라. 입력입력의 첫 줄에는 테스트케이스의 개수 T가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 x 와 목표 위치 y 가 정수로 주어지며, x는 항상 y보다 작은 값을 갖는다. (0 ≤ x &lt; y &lt; 231) 출력각 테스트 케이스에 대해 x지점으로부터 y지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다. 예제 입력 1123430 31 545 50 예제 출력 1123334 힌트 출처 문제를 번역한 사람: AIAI 알고리즘 분류 수학 풀이 소스코드12345678910111213141516171819202122import sysimport mathinput = sys.stdin.readlineT = int(input())for _ in range(T): x, y = map(int, input().split()) distance = y - x if distance &lt;= 3: print(distance) else: n = int(math.sqrt(distance)) if distance == n ** 2: print(2 * n - 1) elif n ** 2 &lt; distance &lt;= n ** 2 + n: print(2 * n) else: print(2 * n + 1)","link":"/categories/Algorithm/Python/BAEKJOON-1011-21-03-21/"},{"title":"[백준] 4949번 균형잡힌 세상","text":"출처: [백준] 4949번 균형잡힌 세상 문제세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다. 정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다. 문자열에 포함되는 괄호는 소괄호(“()”) 와 대괄호(“[]”)로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다. 모든 왼쪽 소괄호(“(“)는 오른쪽 소괄호(“)”)와만 짝을 이뤄야 한다. 모든 왼쪽 대괄호(“[“)는 오른쪽 대괄호(“]”)와만 짝을 이뤄야 한다. 모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다. 모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다. 짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다. 정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자. 입력하나 또는 여러줄에 걸쳐서 문자열이 주어진다. 각 문자열은 영문 알파벳, 공백, 소괄호(“( )”) 대괄호(“[ ]”)등으로 이루어져 있으며, 길이는 100글자보다 작거나 같다. 입력의 종료조건으로 맨 마지막에 점 하나(“.”)가 들어온다. 출력각 줄마다 해당 문자열이 균형을 이루고 있으면 “yes”를, 아니면 “no”를 출력한다. 예제 입력 112345678So when I die (the [first] I will see in (heaven) is a score list).[ first in ] ( first out ).Half Moon tonight (At least it is better than no Moon at all].A rope may form )( a trail in a maze.Help( I[m being held prisoner in a fortune cookie factory)].([ (([( [ ] ) ( ) (( ))] )) ]). .. 예제 출력 11234567yesyesnononoyesyes 힌트7번째의 “ .”와 같이 괄호가 하나도 없는 경우도 균형잡힌 문자열로 간주할 수 있다. 출처ICPC &gt; Regionals &gt; Asia Pacific &gt; Japan &gt; Japan Domestic Contest &gt; 2011 Japan Domestic Contest B번 문제의 오타를 찾은 사람: chminoo 잘못된 번역을 찾은 사람: jh05013 문제를 번역한 사람: occidere 알고리즘 분류 자료 구조 문자열 스택 시간 제한 풀이 소스코드1234567891011121314151617181920212223242526272829303132import sysinput = sys.stdin.readlinewhile True: string = input().rstrip() if string == '.': break stack = [] flag = 1 for char in string: if char == '(' or char == '[': stack.append(char) elif char == ')': if not stack or stack[-1] == '[': flag = 0 break elif stack[-1] == '(': stack.pop() elif char == ']': if not stack or stack[-1] == '(': flag = 0 break elif stack[-1] == '[': stack.pop() if flag == 1 and not stack: print('yes') else: print('no')","link":"/categories/Algorithm/Python/BAEKJOON-4949-21-03-29/"},{"title":"[백준] 5430번 AC","text":"출처: [백준] 5430번 AC 문제선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다. 이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다. 함수 R은 배열에 있는 숫자의 순서를 뒤집는 함수이고, D는 첫 번째 숫자를 버리는 함수이다. 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다. 함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, “AB”는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다. 예를 들어, “RDD”는 배열을 뒤집은 다음 처음 두 숫자를 버리는 함수이다. 배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오. 입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 최대 100이다. 각 테스트 케이스의 첫째 줄에는 수행할 함수 p가 주어진다. p의 길이는 1보다 크거나 같고, 100,000보다 작거나 같다. 다음 줄에는 배열에 들어있는 수의 개수 n이 주어진다. (0 ≤ n ≤ 100,000) 다음 줄에는 [x1,…,xn]과 같은 형태로 배열에 들어있는 수가 주어진다. (1 ≤ xi ≤ 100) 전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다. 출력각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다. 만약, 에러가 발생한 경우에는 error를 출력한다. 예제 입력 1123456789101112134RDD4[1,2,3,4]DD1[42]RRD6[1,1,2,3,5,8]D0[] 예제 출력 11234[2,1]error[1,2,3,5,8]error 힌트 출처 ICPC &gt; Regionals &gt; Europe &gt; Northwestern European Regional Contest &gt; Benelux Algorithm Programming Contest &gt; BAPC 2012 I번 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: chatterboy, doju 데이터를 추가한 사람: jh05013 알고리즘 분류 구현 자료 구조 문자열 덱 시간 제한 풀이 소스코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import sysfrom collections import dequeT = int(input())for _ in range(T): comm = input() N = int(sys.stdin.readline()) temp = input()[1:-1] if ',' not in temp and temp != &quot;&quot;: num_list = deque([int(temp)]) elif temp != &quot;&quot;: num_list = deque(map(int, temp.split(','))) else: num_list = deque() flag = True cnt = 0 # Reverse의 개수 for i in range(len(comm)): if comm[i] == &quot;R&quot;: cnt += 1 else: if len(num_list) == 0: flag = 0 break if cnt % 2 == 0: num_list.popleft() else: num_list.pop() if cnt % 2 == 1: num_list.reverse() if flag: print(&quot;[&quot;, end=&quot;&quot;) for i in range(len(num_list)): if i == len(num_list) - 1: print(num_list[i], end=&quot;&quot;) else: print(str(num_list[i]) + &quot;,&quot;, end=&quot;&quot;) print(&quot;]&quot;) else: print('error')","link":"/categories/Algorithm/Python/BAEKJOON-5430-21-03-25/"},{"title":"[백준] 5397번 키로거","text":"출처: [백준] 5397번 키로거 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 27893 7211 4761 24.497% 문제창영이는 강산이의 비밀번호를 훔치기 위해서 강산이가 사용하는 컴퓨터에 키로거를 설치했다. 며칠을 기다린 끝에 창영이는 강산이가 비밀번호 창에 입력하는 글자를 얻어냈다. 키로거는 사용자가 키보드를 누른 명령을 모두 기록한다. 따라서, 강산이가 비밀번호를 입력할 때, 화살표나 백스페이스를 입력해도 정확한 비밀번호를 알아낼 수 있다. 강산이가 비밀번호 창에서 입력한 키가 주어졌을 때, 강산이의 비밀번호를 알아내는 프로그램을 작성하시오. 입력첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한줄로 이루어져 있고, 강산이가 입력한 순서대로 길이가 L인 문자열이 주어진다. (1 ≤ L의 길이 ≤ 1,000,000) 강산이가 백스페이스를 입력했다면, ‘-‘가 주어진다. 이때 커서의 바로 앞에 글자가 존재한다면, 그 글자를 지운다. 화살표의 입력은 ‘&lt;’와 ‘&gt;’로 주어진다. 이때는 커서의 위치를 움직일 수 있다면, 왼쪽 또는 오른쪽으로 1만큼 움직인다. 나머지 문자는 비밀번호의 일부이다. 물론, 나중에 백스페이스를 통해서 지울 수는 있다. 만약 커서의 위치가 줄의 마지막이 아니라면, 커서 및 커서 오른쪽에 있는 모든 문자는 오른쪽으로 한 칸 이동한다. 출력각 테스트 케이스에 대해서, 강산이의 비밀번호를 출력한다. 비밀번호의 길이는 항상 0보다 크다. 예제 입력 11232&lt;&lt;BP&lt;A&gt;&gt;Cd-ThIsIsS3Cr3t 예제 출력 112BAPCThIsIsS3Cr3t 출처 ICPC &gt; Regionals &gt; Europe &gt; Northwestern European Regional Contest &gt; Benelux Algorithm Programming Contest &gt; BAPC 2010 I번 문제를 번역한 사람: baekjoon 어색한 표현을 찾은 사람: djm03178 문제의 오타를 찾은 사람: eles320 잘못된 번역을 찾은 사람: jh05013 알고리즘 분류 자료 구조 스택 연결 리스트 소스코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): stack = list(input().rstrip()) left, right = [], [] for x in stack: if x == '&lt;': if left: right.append(left.pop()) elif x == '&gt;': if right: left.append(right.pop()) elif x == '-': if left: left.pop() else: left.append(x) if right: left.extend(reversed(right)) print(''.join(left)) ----------------시간초과-------------------import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): stack = list(input().rstrip()) password = [] cur = 0 while stack: temp = stack.pop() if temp == '-' and stack: stack.pop() elif temp == '&gt;': cur -= 1 elif temp == '&lt;': cur += 1 else: password.insert(cur, temp) cur = 0 print(''.join(password))","link":"/categories/Algorithm/Python/BAEKJOON-5397-21-07-09/"},{"title":"[백준] 4963번 섬의 개수","text":"출처: [백준] 4963번 섬의개수 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 30659 15375 11056 49.234% 문제정사각형으로 이루어져 있는 섬과 바다 지도가 주어진다. 섬의 개수를 세는 프로그램을 작성하시오. 한 정사각형과 가로, 세로 또는 대각선으로 연결되어 있는 사각형은 걸어갈 수 있는 사각형이다. 두 정사각형이 같은 섬에 있으려면, 한 정사각형에서 다른 정사각형으로 걸어서 갈 수 있는 경로가 있어야 한다. 지도는 바다로 둘러싸여 있으며, 지도 밖으로 나갈 수 없다. 입력입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 지도의 너비 w와 높이 h가 주어진다. w와 h는 50보다 작거나 같은 양의 정수이다. 둘째 줄부터 h개 줄에는 지도가 주어진다. 1은 땅, 0은 바다이다. 입력의 마지막 줄에는 0이 두 개 주어진다. 출력각 테스트 케이스에 대해서, 섬의 개수를 출력한다. 예제 입력 1123456789101112131415161718192021222324251 102 20 11 03 21 1 11 1 15 41 0 1 0 01 0 0 0 01 0 1 0 11 0 0 1 05 41 1 1 0 11 0 1 0 11 0 1 0 11 0 1 1 15 51 0 1 0 10 0 0 0 01 0 1 0 10 0 0 0 01 0 1 0 10 0 예제 출력 1123456011319 출처ICPC &gt; Regionals &gt; Asia Pacific &gt; Japan &gt; Japan Domestic Contest &gt; 2009 Japan Domestic Contest B번 문제를 번역한 사람: baekjoon 문제의 오타를 찾은 사람: j4bez 링크 TJU Online Judge 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 깊이 우선 탐색 풀이 소스코드_DFS123456789101112131415161718192021222324252627282930313233343536import syssys.setrecursionlimit(10 ** 6)input = sys.stdin.readline# 방향정의 (상,하,좌,우, 1,5,7,9)dx = [-1, 1, 0, 0, -1, 1, 1, -1]dy = [0, 0, -1, 1, 1, 1, -1, -1]def dfs(x, y): ground[x][y] = -1 for i in range(8): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; H and 0 &lt;= ny &lt; W and ground[nx][ny] == 1: dfs(nx, ny)while True: W, H = map(int, input().split()) if W == 0 and H == 0: break ground = [list(map(int, input().split())) for _ in range(H)] count = 0 for i in range(H): for j in range(W): if ground[i][j] == 1: dfs(i, j) count += 1 print(count)","link":"/categories/Algorithm/Python/BAEKJOON-4963-21-04-21/"},{"title":"[백준] 5464번 주차장","text":"출처: [백준] 5464번 주차장 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 186 109 96 61.146% 문제시내 주차장은 1부터 N까지 번호가 매겨진 N개의 주차 공간을 가지고 있다. 이 주차장은 매일 아침 모든 주차 공간이 비어 있는 상태에서 영업을 시작하며, 하룻동안 다음과 같은 방식으로 운영된다. 차가 주차장에 도착하면, 주차장 관리인이 비어있는 주차 공간이 있는지를 검사한다. 만일 비어있는 공간이 없으면, 차량을 빈 공간이 생길 때까지 입구에서 기다리게 한다. 만일 빈 주차 공간이 하나만 있거나 또는 빈 주차 공간이 없다가 한 대의 차량이 주차장을 떠나면 곧바로 그 장소에 주차를 하게 한다. 만일 빈 주차 공간이 여러 곳이 있으면, 그 중 번호가 가장 작은 주차 공간에 주차하도록 한다. 만일 주차장에 여러 대의 차량이 도착하면, 일단 도착한 순서대로 입구의 대기장소에서 줄을 서서 기다려야 한다. 대기장소는 큐(queue)와 같이, 먼저 대기한 차량부터 주차한다. 주차료는 주차한 시간이 아닌 차량의 무게에 비례하는 방식으로 책정된다. 주차료는 차랑의 무게에다 주차 공간마다 따로 책정된 단위 무게당 요금을 곱한 가격이다. 주차장 관리원은 오늘 M대의 차량이 주차장을 이용할 것이라는 것을 알고 있다. 또한, 차량들이 들어오고 나가는 순서도 알고 있다. 주차 공간별 요금과 차량들의 무게와 출입 순서가 주어질 때, 오늘 하룻동안 주차장이 벌어들일 총 수입을 계산하는 프로그램을 작성하라. 입력반드시 표준 입력으로부터 다음의 데이터를 읽어야 한다. 첫 번째 줄에는 정수 N과 M이 빈칸을 사이에 두고 주어진다. 그 다음 N개의 줄에는 주차 공간들의 단위 무게당 요금을 나타내는 정수들이 주어진다. 그 중 s번째 줄에는 주차 공간 s의 단위 무게당 요금 Rs가 들어있다. 그 다음 M개의 줄에는 차량들의 무게를 나타내는 정수들이 주어진다. 차량들은 1 부터 M 까지 번호로 구분되고, 이 번호는 출입 순서와는 상관없다. 이 M개의 줄 중 k번째 줄에는 차량 k의 무게를 나타내는 정수 Wk가 들어있다. 그 다음 2*M 개의 줄에는 차량들의 주차장 출입 순서를 나타내는 정수들이 한 줄에 하나씩 주어진다. 양의 정수 i는 차량 i가 주차장에 들어오는 것을 의미하고, 음의 정수 -i는 차량 i가 주차장에서 나가는 것을 의미한다. 주차장에 들어오지 않은 차량이 주차장에서 나가는 경우는 없다. 1 번부터 M 번까지 모든 차량은 정확하게 한 번씩 주차장에 들어오고, 한 번씩 주차장에서 나간다. 또한 입구에서 대기 중인 차량이 주차를 하지 못하고 나가는 경우는 없다. 1 ≤ N ≤ 100 주차 공간의 수 1 ≤ M ≤ 2,000 차량의 수 1 ≤ Rs ≤ 100 주차 공간 s의 단위 무게당 요금 1 ≤ Wk ≤ 10,000 차량 k의 무게 출력출력은 반드시 표준 출력으로 하여야 하며, 하나의 줄에 한 개의 정수를 출력한다. 이 정수는 오늘 하룻동안 주차장이 벌어들인 총 수입이다. 예제 입력 1123456789101112131415163 423520010030080032-314-4-2-1 예제 출력 115300 예제 입력 21234567891011121314152 452100500100020003124-1-3-2-4 예제 출력 2116200 힌트 차량 3이 주차 공간 1에 주차한다. 주차료는 300 * 2 = 600 이다. 차량 2가 주차 공간 2에 주차한다. 주차료는 100 * 3 = 300 이다. 차량 1이 차랑 3이 떠난 주차공간 1에 주차한다. 주차료는 200 * 2 = 400 이다. 차량 4가 마지막 남은 주차 공간 3에 주차한다. 주차료는 800 * 5 = 4,000 이다. 출처 Olympiad &gt; International Olympiad in Informatics &gt; IOI 2009 5번 알고리즘 분류 구현 자료 구조 시뮬레이션 큐 소스코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import sysfrom collections import dequeimport heapqinput = sys.stdin.readlineN, M = map(int, input().split())# N~: 단위 무게당 요금을 나타내는 정수, N: 주차공간 1,2,3....# M~: 차량들의 무게fees = [int(input()) for _ in range(N)]weights = [int(input()) for _ in range(M)]parking = {}for i in range(M + 1): parking[i + 1] = []waiting = deque()total_fee = 0parking_idx = [x for x in range(N)]heapq.heapify(parking_idx)for i in range(2 * M): if parking_idx and waiting: car_num = waiting.popleft() idx = heapq.heappop(parking_idx) parking[car_num] = [idx, fees[idx], weights[car_num - 1]] car_num = int(input()) if car_num &gt; 0: # 입차 if parking_idx: idx = heapq.heappop(parking_idx) parking[car_num] = [idx, fees[idx], weights[car_num - 1]] else: waiting.append(car_num) else: car_num = abs(car_num) idx = parking[car_num][0] fee = parking[car_num][1] weight = parking[car_num][2] total_fee += fee * weight heapq.heappush(parking_idx, idx)print(total_fee)","link":"/categories/Algorithm/Python/BAEKJOON-5464-21-07-22/"},{"title":"[백준] 7576번 토마토","text":"출처: [백준] 7576번 토마토 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 84627 29824 18694 33.321% 문제철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다. 창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다. 토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다. 입력첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 토마토가 하나 이상 있는 경우만 입력으로 주어진다. 출력여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다. 예제 입력 1123456 40 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 예제 출력 118 예제 입력 2123456 40 -1 0 0 0 0-1 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 예제 출력 21-1 예제 입력 3123456 41 -1 0 0 0 00 -1 0 0 0 00 0 0 0 -1 00 0 0 0 -1 1 예제 출력 316 예제 입력 41234565 5-1 1 0 0 00 -1 -1 -1 00 -1 -1 -1 00 -1 -1 -1 00 0 0 0 0 예제 출력 4114 예제 입력 51232 21 -1-1 1 예제 출력 510 힌트 출처 Olympiad &gt; 한국정보올림피아드 &gt; 한국정보올림피아드시․도지역본선 &gt; 지역본선 2013 &gt; 고등부 1번 데이터를 추가한 사람: baekjoon, djm03178 잘못된 데이터를 찾은 사람: tncks0121 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 시간 제한 풀이 소스코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import sysfrom collections import dequeinput = sys.stdin.readlineN, M = map(int, input().split())boxes = [list(map(int, input().split())) for _ in range(M)]dx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]def bfs(): while tomatoes: x, y = tomatoes.popleft() for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; M and 0 &lt;= ny &lt; N and boxes[nx][ny] == 0: boxes[nx][ny] = boxes[x][y] + 1 tomatoes.append((nx, ny))tomatoes = deque()for i in range(M): for j in range(N): if boxes[i][j] == 1: tomatoes.append((i, j))bfs()alreadyTrue = Falsecount = 0for row in boxes: for tomato in row: if tomato == 0: alreadyTrue = True count = max(count, tomato)if alreadyTrue: print(-1)elif count == -1: print(0)else: print(count - 1)","link":"/categories/Algorithm/Python/BAEKJOON-7576-21-04-09/"},{"title":"[백준] 9012번 괄호","text":"출처: [백준] 9012번 괄호 문제괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다. 여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 입력입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다. 출력출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다. 예제 입력 112345676(())())(((()())()(()())((()))((()()(()))(((())))()()()()()(()()())()(()((())()( 예제 출력 1123456NONOYESNOYESNO 예제 입력 212343(())())(() 예제 출력 2123NONONO 힌트 출처 ICPC &gt; Regionals &gt; Asia Pacific &gt; Korea &gt; Nationwide Internet Competition &gt; Daejeon Nationalwide Internet Competition 2012 G번 데이터를 만든 사람: baekjoon 데이터를 추가한 사람: jh05013 문제의 오타를 찾은 사람: marona 알고리즘 분류 자료 구조 문자열 스택 시간 제한 풀이 소스코드 11234567891011121314151617181920212223import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): string = list(input().rstrip()) while len(string) != 0: if string[0] == ')': print(&quot;NO&quot;) break else: if ')' in string: string.remove(')') string.remove('(') else: print(&quot;NO&quot;) break if len(string) == 0: print(&quot;YES&quot;) 소스코드 2123456789101112131415161718192021222324import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): string = list(input().rstrip()) vps_sum = 0 for x in string: if x == '(': vps_sum += 1 elif x == ')': vps_sum -= 1 if vps_sum &lt; 0: print(&quot;NO&quot;) break if vps_sum == 0: print('YES') elif vps_sum &gt; 0: print('NO')","link":"/categories/Algorithm/Python/BAEKJOON-9012-21-03-27/"},{"title":"[백준] 5568번 카드 놓기","text":"출처: [백준] 5568번 카드 놓기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 2813 1519 1197 53.082% 문제상근이는 카드 n(4 ≤ n ≤ 10)장을 바닥에 나란히 놓고 놀고있다. 각 카드에는 1이상 99이하의 정수가 적혀져 있다. 상근이는 이 카드 중에서 k(2 ≤ k ≤ 4)장을 선택하고, 가로로 나란히 정수를 만들기로 했다. 상근이가 만들 수 있는 정수는 모두 몇 가지일까? 예를 들어, 카드가 5장 있고, 카드에 쓰여 있는 수가 1, 2, 3, 13, 21라고 하자. 여기서 3장을 선택해서 정수를 만들려고 한다. 2, 1, 13을 순서대로 나열하면 정수 2113을 만들 수 있다. 또, 21, 1, 3을 순서대로 나열하면 2113을 만들 수 있다. 이렇게 한 정수를 만드는 조합이 여러 가지 일 수 있다. n장의 카드에 적힌 숫자가 주어졌을 때, 그 중에서 k개를 선택해서 만들 수 있는 정수의 개수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 n이, 둘째 줄에 k가 주어진다. 셋째 줄부터 n개 줄에는 카드에 적혀있는 수가 주어진다. 출력첫째 줄에 상근이가 만들 수 있는 정수의 개수를 출력한다. 예제 입력 11234564212121 예제 출력 117 예제 입력 2123456786372212721 예제 출력 2168 힌트예제 1의 경우 상근이는 11, 12, 21, 112, 121, 122, 212를 만들 수 있다. 출처 Olympiad &gt; Japanese Olympiad in Informatics &gt; Japanese Olympiad in Informatics Qualification Round &gt; JOI 2010 예선 4번 문제를 번역한 사람: baekjoon 알고리즘 분류 자료 구조 브루트포스 알고리즘 해시를 사용한 집합과 맵 재귀 소스코드12345678910111213141516171819import sysfrom itertools import permutationsinput = sys.stdin.readlineN = int(input())K = int(input())card_list = []for _ in range(N): card_list.append(input().rstrip())result = []for x in permutations(card_list, K): result.append(''.join(x))result = list(set(result))print(len(result))","link":"/categories/Algorithm/Python/BAEKJOON-5568-21-06-30/"},{"title":"[백준] 9251번 LCS","text":"출처: [백준] 9251번 LCS 문제LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다. 예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다. 입력첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다. 출력첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다. 예제 입력 112ACAYKPCAPCAK 예제 출력 114 힌트 출처 문제를 만든 사람: baekjoon 데이터를 추가한 사람: qpwoeiruty 알고리즘 분류 다이나믹 프로그래밍 문자열 풀이 소스코드123456789101112131415161718import sysinput = sys.stdin.readlinestr1 = ' ' + input().rstrip()str2 = ' ' + input().rstrip()dp = [[0] * len(str2) for _ in range(len(str1))]for i in range(1, len(str1)): for j in range(1, len(str2)): if str1[i] == str2[j]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])print(dp[-1][-1])","link":"/categories/Algorithm/Python/BAEKJOON-9251-21-03-22/"},{"title":"[백준] 9093번 단어 뒤집기","text":"출처: [백준] 9093번 단어 뒤집기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 11508 5586 4215 49.699% 문제문장이 주어졌을 때, 단어를 모두 뒤집어서 출력하는 프로그램을 작성하시오. 단, 단어의 순서는 바꿀 수 없다. 단어는 영어 알파벳으로만 이루어져 있다. 입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 문장이 하나 주어진다. 단어의 길이는 최대 20, 문장의 길이는 최대 1000이다. 단어와 단어 사이에는 공백이 하나 있다. 출력각 테스트 케이스에 대해서, 입력으로 주어진 문장의 단어를 모두 뒤집어 출력한다. 예제 입력 11232I am happy todayWe want to win the first prize 예제 출력 112I ma yppah yadoteW tnaw ot niw eht tsrif ezirp 출처 ICPC &gt; Regionals &gt; Asia Pacific &gt; Korea &gt; Asia Regional - Taejon 2001 PA번 문제를 번역한 사람: baekjoon 알고리즘 분류 구현 문자열 소스코드123456789101112import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): sentence = list(input().rstrip().split(&quot; &quot;)) for x in sentence: print(''.join(reversed(list(x))), end=&quot; &quot;) print()","link":"/categories/Algorithm/Python/BAEKJOON-9093-21-06-24/"},{"title":"[백준] 7562번 나이트의 이동","text":"출처: [백준] 7562번 나이트의 이동 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 25244 12068 9035 46.974% 문제체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까? 입력입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, …, l-1} × {0, …, l-1}로 나타낼 수 있다. 둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다. 출력각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다. 예제 입력 112345678910380 07 01000 030 50101 11 1 예제 출력 11235280 출처 University &gt; Tu-Darmstadt Programming Contest &gt; TUD Contest 2001 3번 문제를 번역한 사람: baekjoon 데이터를 추가한 사람: sait2000 문제의 오타를 찾은 사람: sgchoi5 링크 PKU Judge Online TJU Online Judge 알고리즘 분류 그래프 이론 그래프 탐색 너비 우선 탐색 소스코드1234567891011121314151617181920212223242526272829303132333435363738import sysfrom collections import dequeinput = sys.stdin.readlineT = int(input())# 나이트가 이동할 수 있는 8가지 방향 정의steps = [(-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)]def BFS(graph, start): queue = deque([start]) while queue: # 큐에서 하나의 원소를 뽑아 출력하기 r, c = queue.popleft() if r == target_row and c == target_column: return graph[r][c] for step in steps: # 이동하고자 하는 위치 확인 next_row = r + step[0] next_col = c + step[1] # 해당 위치로 이동이 가능하다면 카운트 증가 if 0 &lt;= next_row &lt; I and 0 &lt;= next_col &lt; I and graph[next_row][next_col] == 0: graph[next_row][next_col] = graph[r][c] + 1 queue.append((next_row, next_col))for _ in range(T): I = int(input()) chess_board = [[0] * (I + 1) for _ in range(I + 1)] row, column = map(int, input().split()) target_row, target_column = map(int, input().split()) result = BFS(chess_board, (row, column)) print(result)","link":"/categories/Algorithm/Python/BAEKJOON-7562-21-05-19/"},{"title":"[백준] 9375번 패션왕 신해빈","text":"출처: [백준] 9375번 패션왕 신해빈 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 8972 4744 4148 54.350% 문제해빈이는 패션에 매우 민감해서 한번 입었던 옷들의 조합을 절대 다시 입지 않는다. 예를 들어 오늘 해빈이가 안경, 코트, 상의, 신발을 입었다면, 다음날은 바지를 추가로 입거나 안경대신 렌즈를 착용하거나 해야한다. 해빈이가 가진 의상들이 주어졌을때 과연 해빈이는 알몸이 아닌 상태로 며칠동안 밖에 돌아다닐 수 있을까? 입력첫째 줄에 테스트 케이스가 주어진다. 테스트 케이스는 최대 100이다. 각 테스트 케이스의 첫째 줄에는 해빈이가 가진 의상의 수 n(0 ≤ n ≤ 30)이 주어진다. 다음 n개에는 해빈이가 가진 의상의 이름과 의상의 종류가 공백으로 구분되어 주어진다. 같은 종류의 의상은 하나만 입을 수 있다. 모든 문자열은 1이상 20이하의 알파벳 소문자로 이루어져있으며 같은 이름을 가진 의상은 존재하지 않는다. 출력각 테스트 케이스에 대해 해빈이가 알몸이 아닌 상태로 의상을 입을 수 있는 경우를 출력하시오. 예제 입력 112345678923hat headgearsunglasses eyewearturban headgear3mask facesunglasses facemakeup face 예제 출력 11253 힌트첫 번째 테스트 케이스는 headgear에 해당하는 의상이 hat, turban이며 eyewear에 해당하는 의상이 sunglasses이므로 (hat), (turban), (sunglasses), (hat,sunglasses), (turban,sunglasses)로 총 5가지 이다. 출처 ICPC &gt; Regionals &gt; Europe &gt; Northwestern European Regional Contest &gt; Benelux Algorithm Programming Contest &gt; BAPC 2013 I번 문제를 번역한 사람: lll4592 문제의 오타를 찾은 사람: sunsal0704 알고리즘 분류 자료 구조 문자열 해시를 사용한 집합과 맵 소스코드123456789101112131415161718192021import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): clothes = {} N = int(input()) for _ in range(N): name, kind = input().split() if kind in clothes: clothes[kind] += 1 else: clothes[kind] = 1 case = 1 for key in clothes.keys(): case = case * (clothes[key] + 1) print(case - 1)","link":"/categories/Algorithm/Python/BAEKJOON-9375-21-05-23/"},{"title":"[백준] 9466번 텀 프로젝트","text":"출처: [백준] 9466번 텀 프로젝트 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 3 초 256 MB 30631 7499 4796 24.632% 문제이번 가을학기에 ‘문제 해결’ 강의를 신청한 학생들은 텀 프로젝트를 수행해야 한다. 프로젝트 팀원 수에는 제한이 없다. 심지어 모든 학생들이 동일한 팀의 팀원인 경우와 같이 한 팀만 있을 수도 있다. 프로젝트 팀을 구성하기 위해, 모든 학생들은 프로젝트를 함께하고 싶은 학생을 선택해야 한다. (단, 단 한 명만 선택할 수 있다.) 혼자 하고 싶어하는 학생은 자기 자신을 선택하는 것도 가능하다. 학생들이(s1, s2, …, sr)이라 할 때, r=1이고 s1이 s1을 선택하는 경우나, s1이 s2를 선택하고, s2가 s3를 선택하고,…, sr-1이 sr을 선택하고, sr이 s1을 선택하는 경우에만 한 팀이 될 수 있다. 예를 들어, 한 반에 7명의 학생이 있다고 하자. 학생들을 1번부터 7번으로 표현할 때, 선택의 결과는 다음과 같다. 1 2 3 4 5 6 7 3 1 3 7 3 4 6 위의 결과를 통해 (3)과 (4, 7, 6)이 팀을 이룰 수 있다. 1, 2, 5는 어느 팀에도 속하지 않는다. 주어진 선택의 결과를 보고 어느 프로젝트 팀에도 속하지 않는 학생들의 수를 계산하는 프로그램을 작성하라. 입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫 줄에는 학생의 수가 정수 n (2 ≤ n ≤ 100,000)으로 주어진다. 각 테스트 케이스의 둘째 줄에는 선택된 학생들의 번호가 주어진다. (모든 학생들은 1부터 n까지 번호가 부여된다.) 출력각 테스트 케이스마다 한 줄에 출력하고, 각 줄에는 프로젝트 팀에 속하지 못한 학생들의 수를 나타내면 된다. 예제 입력 112345273 1 3 7 3 4 681 2 3 4 5 6 7 8 예제 출력 11230 힌트 출처 ICPC &gt; Regionals &gt; Asia Pacific &gt; Korea &gt; Asia Regional - Daejeon 2013 L번 문제를 번역한 사람: plzrun 데이터를 추가한 사람: qwe123rt45 링크 ACM-ICPC Live Archive 알고리즘 분류 그래프 이론 그래프 탐색 깊이 우선 탐색 풀이 연결 된 점이 싸이클이 되면 팀 형성… 소스코드12345678910111213141516171819202122232425262728293031323334import syssys.setrecursionlimit(10**6)input = sys.stdin.readlinetest_case = int(input())def dfs(v): global result team[v] = True cycle.append(v) num = arr[v] if not team[num]: dfs(num) else: if num in cycle: result += cycle[cycle.index(num):] returnfor _ in range(test_case): N = int(input()) arr = [0] + list(map(int, input().split())) team = [True] + [False] * N result = [] for i in range(1, N + 1): if not team[i]: cycle = [] dfs(i) print(N - len(result))","link":"/categories/Algorithm/Python/BAEKJOON-9466-21-04-18/"},{"title":"[백준] 9322번 철벽 보안 알고리즘","text":"출처: [백준] 9322번 철벽 보안 알고리즘 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 1389 853 679 63.045% 문제소희는 공개키와 개인키 한 쌍으로 보안을 유지하는 것이 매우 불편하다고 생각했다. 그래서 소희는 공개키만을 이용하는 암호화 체계를 개발했다. 이를 “철벽 보안 알고리즘”이라고 부르기로 했다. 알고리즘은 다음과 같다. 한 단어는 1~10개의 대문자(A-Z)들로 이루어진 문자열이다. 한 문장은 공백으로 구분된 단어들로 이루어졌다. 제 1 공개키는 최대 한 번만 사용된 단어들로 되어있다. 제 2 공개키는 제 1 공개키의 단어들을 재배치하여 만들어진다. 평문(암호화 되지 않은 문장)은 제 1 공개키와 같이 여러 단어들로 되어있지만, 제 1 공개키와 다르게 각 단어들은 중복이 가능하다. 암호문(암호화 된 문장)은 평문을 제 2 공개키를 만든 규칙의 반대로 재배치하여 만들어진다. 주어진 2개의 공개키와 암호문으로 평문을 복구하라. 입력입력의 첫 줄에는 테스트 케이스의 수를 의미하는 하나의 정수가 입력된다. 정수는 100을 넘지 않는다. 각 테스트케이스마다 아래 항목들을 한 줄씩 입력받는다. 한 문장의 단어 수 n (1 ≤ n ≤ 1 000) 제 1 공개키 제 2 공개키 암호문 모든 단어들은 최소 1개, 최대 10개의 대문자들로 이루어져있다. 출력각 케이스마다 암호문을 해독한 평문 을 한 줄에 줄력한다. 예제 입력 112345678924A B C DD A B CC B A P3SECURITY THROUGH OBSCURITYOBSCURITY THROUGH SECURITYTOMORROW ATTACK WE 예제 출력 112B A P CWE ATTACK TOMORROW 출처 ICPC &gt; Regionals &gt; Europe &gt; Northwestern European Regional Contest &gt; Benelux Algorithm Programming Contest &gt; BAPC 2013 Preliminaries E번 문제를 번역한 사람: joonas 문제의 오타를 찾은 사람: lakshimi 알고리즘 분류 구현 자료 구조 문자열 해시를 사용한 집합과 맵 소스코드12345678910111213141516171819import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): N = int(input()) first_public_key = list(input().split()) second_public_key = list(input().split()) cipher_text = list(input().split()) rule = [] for i in range(N): rule.append(second_public_key.index(first_public_key[i])) for i in rule: print(cipher_text[i], end=' ')","link":"/categories/Algorithm/Python/BAEKJOON-9322-21-07-04/"},{"title":"[백준] 9471번 피사노 주기","text":"출처: [백준] 9471번 피사노 주기 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 128 MB 853 602 504 75.224% 문제1960년, IBM의 직원 Donald Wall은 피보나치 수열을 m으로 나눈 나머지가 주기를 이룬다는 것을 증명했다. 예를 들어, 피보나치 수열의 처음 10개를 11로 나눈 예는 다음과 같다. n 1 2 3 4 5 6 7 8 9 10 F(n) 1 1 2 3 5 8 13 21 34 55 F(n) mod 11 1 1 2 3 5 8 2 10 1 0 나머지를 이용해서 만든 수열은 주기가 나타날 수 있다. k(m)을 반복하는 부분 수열의 길이라고 했을 때, k(11) = 10임을 알 수 있다. Wall은 아래와 같은 여러 가지 성질도 증명했다. m &gt; 2인 경우에 k(m)은 짝수이다. 임의의 짝수 정수 n &gt; 2에 대해서, k(m) = n인 m이 항상 존재한다. k(m) ≤ m2 - 1 k(2n) = 3×2(n-1) k(5n) = 4×5n k(2×5n) = 6n n &gt; 2라면, k(10n) = 15×10(n-1) m이 주어졌을 때, k(m)을 구하는 프로그램을 작성하시오. 입력첫째 줄에 테스트 케이스의 개수 P (1 ≤ P ≤ 1000)가 주어진다. 각 테스트 케이스는 N과 M으로 이루어져 있다. N은 테스트 케이스의 번호이고, M은 문제에서 설명한 m이다. (2 ≤ M ≤ 1,000,000) 출력각 테스트 케이스마다 테스트 케이스 번호를 출력하고 k(M)을 출력한다. 예제 입력 112345651 42 53 114 1234565 987654 예제 출력 1123451 62 203 104 154565 332808 힌트 출처 ICPC &gt; Regionals &gt; North America &gt; Greater New York Region &gt; 2013 Greater New York Programming Contest D번 문제를 번역한 사람: baekjoon 알고리즘 분류 수학 링크 ACM-ICPC Live Archive 풀이 소스코드123456789101112131415161718192021222324252627282930313233import sysinput = sys.stdin.readlineN = int(input())def fibo(n): if len(fibo_list) &gt; n: return fibo_list[n] else: fibo_list[n] = (fibo(n - 1) + fibo(n - 2)) % mod return fibo_list[n]def cycle(): x = 1 while True: if fibo_list[x] == 0 and fibo_list[x - 1] == 1: return x x += 1 fibo(x)for _ in range(N): fibo_list = dict() fibo_list[0] = 0 fibo_list[1] = 1 fibo_list[2] = 1 idx, mod = map(int, input().split()) print(idx, cycle())","link":"/categories/Algorithm/Python/BAEKJOON-9471-21-04-05/"},{"title":"[프로그래머스] Lv2.카펫","text":"출처: [코딩테스트 연습 카펫] 문제Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다. Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다. 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다. 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다. 입출력 brown yellow return 10 2 [4, 3] 8 1 [3, 3] 24 24 [8, 6] 출처 소스코드1234567891011121314def solution(brown, yellow): answer = [] carpet = brown + yellow for i in range(1, carpet + 1): col = i row = carpet / col if col &gt;= row: if (col - 2) * (row - 2) == yellow: answer.append(col) answer.append(int(row)) break return answer","link":"/categories/Algorithm/Python/PROGRAMMERS-BRUTEFORCE-carpet-06-04/"},{"title":"[프로그래머스] Lv2.타겟넘버","text":"출처: [코딩테스트 연습 타겟넘버] 문제n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다. 12345-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요. 제한 주어지는 숫자의 개수는 2개 이상 20개 이하입니다. 각 숫자는 1 이상 50 이하인 자연수입니다. 타겟 넘버는 1 이상 1000 이하인 자연수입니다. 입출력 numbers target return [1, 1, 1, 1, 1] 3 5 풀이- 소스코드123456789101112131415161718from collections import dequedef solution(numbers, target): answer = 0 queue = deque() queue.append((0, 0)) while queue: idx, total = queue.popleft() if idx == len(numbers): if total == target: answer += 1 else: num = numbers[idx] queue.append((idx + 1, total + num)) queue.append((idx + 1, total - num)) return answer","link":"/categories/Algorithm/Python/PROGRAMMERS-DFS,BFS-target_number-06-04/"},{"title":"[프로그래머스] Lv3.등굣길","text":"출처: [코딩테스트 연습 등굣길] 문제계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다. 아래 그림은 m = 4, n = 3 인 경우입니다. 가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다. 격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요. 제한 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다. m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다. 물에 잠긴 지역은 0개 이상 10개 이하입니다. 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다. 입출력 m n puddles return 4 3 [[2, 2]] 4 입출력 예 1 풀이- 소스코드1234567891011121314151617def solution(m, n, puddles): matrix = [[0 for _ in range(m + 1)] for _ in range(n + 1)] matrix[1][1] = 1 for i in range(1, n + 1): for j in range(1, m + 1): if i == 1 and j == 1: continue if [j, i] in puddles: continue else: matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1] return matrix[n][m] % 1000000007print(solution(4, 3, [[2, 2]]))","link":"/categories/Algorithm/Python/PROGRAMMERS-DP-road-06-04/"},{"title":"[프로그래머스] Lv1.완주하지 못한 선수","text":"출처: [코딩테스트 연습 완주하지 못한 선수] 문제수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 participant completion return [“leo”, “kiki”, “eden”] [“eden”, “kiki”] “leo” [“marina”, “josipa”, “nikola”, “vinko”, “filipa”] [“josipa”, “filipa”, “marina”, “nikola”] “vinko” [“mislav”, “stanko”, “mislav”, “ana”] [“stanko”, “ana”, “mislav”] “mislav” 입출력 예 1예제 #1“leo”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2“vinko”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3“mislav”는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 출처 소스코드1234567891011121314151617from collections import Counterdef solution(participant, completion): participant.sort() completion.sort() answer = Counter(participant) - Counter(completion) return list(answer)[0]# print(solution([&quot;marina&quot;, &quot;josipa&quot;, &quot;nikola&quot;, &quot;vinko&quot;, &quot;filipa&quot;], [&quot;josipa&quot;, &quot;filipa&quot;, &quot;marina&quot;, &quot;nikola&quot;]))'''collection 라이브러리 사용일반 dict는 빼기 불가,counter를 사용하면 key, value로 되고...카운터 객체이므로 빼기 가능마지막 리스트로 변환 후 0번째 출력--&gt; 탈락자는 한명이다''' 12345678910111213141516171819def solution(participant, completion): participant.sort() completion.sort() for p, c in zip(participant, completion): if p != c: return p return participant[-1]# print(solution([&quot;marina&quot;, &quot;josipa&quot;, &quot;nikola&quot;, &quot;vinko&quot;, &quot;filipa&quot;], [&quot;josipa&quot;, &quot;filipa&quot;, &quot;marina&quot;, &quot;nikola&quot;]))'''탈락자는 무조건 한명참여자 명단의 인덱스와 완주자 명단의 인덱스 값이 다르다면,그 때, 참여자는 완주자 명단에 없으므로, 반환----마지막까지 인덱스 값이 같다면, 참여자 명단 마지막 사람이 완주하지 못한 사람이다.'''","link":"/categories/Algorithm/Python/PROGRAMMERS-HASH-unfinished-06-04/"},{"title":"[백준] 7785번 회사에 있는 사람","text":"출처: [백준] 7785번 회사에 있는 사람 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 256 MB 13977 4901 3355 37.820% 문제상근이는 세계적인 소프트웨어 회사 기글에서 일한다. 이 회사의 가장 큰 특징은 자유로운 출퇴근 시간이다. 따라서, 직원들은 반드시 9시부터 6시까지 회사에 있지 않아도 된다. 각 직원은 자기가 원할 때 출근할 수 있고, 아무때나 퇴근할 수 있다. 상근이는 모든 사람의 출입카드 시스템의 로그를 가지고 있다. 이 로그는 어떤 사람이 회사에 들어왔는지, 나갔는지가 기록되어져 있다. 로그가 주어졌을 때, 현재 회사에 있는 모든 사람을 구하는 프로그램을 작성하시오. 입력첫째 줄에 로그에 기록된 출입 기록의 수 n이 주어진다. (2 ≤ n ≤ 106) 다음 n개의 줄에는 출입 기록이 순서대로 주어지며, 각 사람의 이름이 주어지고 “enter”나 “leave”가 주어진다. “enter”인 경우는 출근, “leave”인 경우는 퇴근이다. 회사에는 동명이인이 없으며, 대소문자가 다른 경우에는 다른 이름이다. 사람들의 이름은 알파벳 대소문자로 구성된 5글자 이하의 문자열이다. 출력현재 회사에 있는 사람의 이름을 사전 순의 역순으로 한 줄에 한 명씩 출력한다. 예제 입력 1123454Baha enterAskar enterBaha leaveArtem enter 예제 출력 112AskarArtem 출처 Contest &gt; KBTU Open &gt; KBTU Open 2008 E번 문제를 번역한 사람: baekjoon 빠진 조건을 찾은 사람: haja, lyzqm 데이터를 추가한 사람: jh05013 알고리즘 분류 자료 구조 문자열 해시를 사용한 집합과 맵 소스코드1234567891011121314151617181920import sysinput = sys.stdin.readlineN = int(input())exist = {}for i in range(N): name, action = (input().split()) exist[name] = actionexist = sorted(exist.items(), reverse=True)for i in range(len(exist)): if exist[i][1] == 'leave': continue else: print(exist[i][0])","link":"/categories/Algorithm/Python/BAEKJOON-7785-21-06-28/"},{"title":"[프로그래머스] 더 맵게","text":"출처: [코딩테스트 연습] 디스크 컨트롤러 문제매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다. 1섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요. 제한 scoville의 길이는 2 이상 1,000,000 이하입니다. K는 0 이상 1,000,000,000 이하입니다. scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다. 입출력 scoville K return [1, 2, 3, 9, 10, 12] 7 2 입출력 예 1 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12] 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13가진 음식의 스코빌 지수 = [13, 9, 10, 12] 모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다. 풀이 scoville리스트를 heaq구조로 바꿔주고, 조건에 맞게 두번의 heappop.. 위 계산을 다시 scoville에 넣어주고 answer카운트 증가–&gt; K 이상될때까지K이상이 될 수 없으면 return -1 소스코드123456789101112131415161718192021import heapqdef solution(scoville, K): answer = 0 # heap = [] # for num in scoville: # heapq.heappush(heap, num) heapq.heapify(scoville) while scoville[0] &lt; K: mix = heapq.heappop(scoville) + (heapq.heappop(scoville) * 2) heapq.heappush(scoville, mix) answer += 1 if len(scoville) == 1 and scoville[0] &lt; K: return -1 return answer# print(solution([1, 2, 3, 9, 10, 12], 7)) # 2","link":"/categories/Algorithm/Python/PROGRAMMERS-HEAP-More%20spicy-05-04/"},{"title":"[프로그래머스] 이중우선순위큐","text":"출처: [코딩테스트 연습 이중우선순위큐] 출처 문제이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다. 명령어 수신 탑(높이) I 숫자 큐에 주어진 숫자를 삽입합니다. D 1 큐에서 최댓값을 삭제합니다. D -1 큐에서 최솟값을 삭제합니다. 이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요. 제한 operations는 길이가 1 이상 1,000,000 이하인 문자열 배열입니다. operations의 원소는 큐가 수행할 연산을 나타냅니다. 원소는 “명령어 데이터” 형식으로 주어집니다.- 최댓값/최솟값을 삭제하는 연산에서 최댓값/최솟값이 둘 이상인 경우, 하나만 삭제합니다. 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시합니다. 입출력 operations return [“I 16”,”D 1”] [0,0] [“I 7”,”I 5”,”I -5”,”D -1”] [7,5] 입출력 예 116을 삽입 후 최댓값을 삭제합니다. 비어있으므로 [0,0]을 반환합니다.7,5,-5를 삽입 후 최솟값을 삭제합니다. 최대값 7, 최소값 5를 반환합니다. 풀이 조건 대로 시행 최대값은 heapq.nlargest() 이용 소스코드1234567891011121314151617181920212223import heapqdef solution(operations): answer = [] heapq.heapify(answer) for comm in operations: com, num = comm.split() if com == 'I': heapq.heappush(answer, int(num)) elif com == 'D': if not answer: continue else: if num == '1': answer.pop(answer.index(heapq.nlargest(1, answer)[0])) elif num == '-1': heapq.heappop(answer) if not answer: return [0, 0] else: return [heapq.nlargest(1, answer)[0], answer[0]]","link":"/categories/Algorithm/Python/PROGRAMMERS-HEAP-double_priority_queue-06-04/"},{"title":"[프로그래머스] [2019 카카오 개발자 겨울 인턴십] 크레인 인형뽑기 게임","text":"출처: [2019 카카오 개발자 겨울 인턴십] 크레인 인형뽑기 게임 문제게임개발자인 “죠르디”는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.“죠르디”는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다. 게임 화면은 “1 x 1” 크기의 칸들로 이루어진 “N x N” 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 “5 x 5” 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 “1 x 1” 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다. 만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다. 크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음) 게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요. 제한 board 배열은 2차원 배열로 크기는 “5 x 5” 이상 “30 x 30” 이하입니다. board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다. 0은 빈 칸을 나타냅니다. 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다. moves 배열의 크기는 1 이상 1,000 이하입니다. moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다. 입출력 board moves result [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] [1,5,3,5,1,2,1,4] 4 입출력 예 1인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다. 풀이- 소스코드1234567891011121314151617181920212223def solution(board, moves): N = len(board) # 보드의 길이 answer = 0 basket = [] for move in moves: for i in range(N): if board[i][move - 1] &gt; 0: # Move별로 맨 위에 있는 인형을 바구니에 넣고, 빈칸으로 전환 basket.append(board[i][move - 1]) board[i][move - 1] = 0 break if len(basket) &gt; 1: # 바구니가 2개이상일 때부터 if basket[-1] == basket[-2]: # 가장 최신에 들어온 것과 그 전에 들어온 것이 같으면 두개 삭제 basket.pop() basket.pop() answer += 2 return answerprint(solution([[0, 0, 0, 0, 0], [0, 0, 1, 0, 3], [0, 2, 5, 0, 1], [4, 2, 4, 4, 2], [3, 5, 1, 3, 1]], [1, 5, 3, 5, 1, 2, 1, 4]))","link":"/categories/Algorithm/Python/PROGRAMMERS-KAKAO-INTERN-2019-1_claw%20crane-21-07-24/"},{"title":"[프로그래머스] [2020 카카오 인턴십] 키패드 누르기","text":"출처: [2020 카카오 인턴십] 키패드 누르기 문제스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다. 이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.맨 처음 왼손 엄지손가락은 * 키패드에 오른손 엄지손가락은 # 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다. 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다. 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다. 오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다. 가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다. 순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요. 제한 numbers 배열의 크기는 1 이상 1,000 이하입니다. numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다. hand는 1&quot;left&quot; 또는 1&quot;right&quot; 입니다. &quot;left&quot;는 왼손잡이, &quot;right&quot;는 오른손잡이를 의미합니다. 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요. 입출력 numbers hand result [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] &quot;right&quot; &quot;LRLLLRLLRRL&quot; [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] &quot;left&quot; &quot;LRLLRRLLLRR&quot; [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] &quot;right&quot; &quot;LLRLLRLLRL&quot; 입출력 예 1순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다. 왼손 위치 오른손 위치 눌러야 할 숫자 사용한 손 설명 * # 1 L 1은 왼손으로 누릅니다. 1 # 3 R 3은 오른손으로 누릅니다. 1 3 4 L 4는 왼손으로 누릅니다. 4 3 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5 3 8 L 왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다. 8 3 2 R 왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다. 8 2 1 L 1은 왼손으로 누릅니다. 1 2 4 L 4는 왼손으로 누릅니다. 4 2 5 R 왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다. 4 5 9 R 9는 오른손으로 누릅니다. 4 9 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5 9 - - 따라서 &quot;LRLLLRLLRRL&quot;를 return 합니다. 입출력 예 2왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 &quot;LRLLRRLLLRR&quot;이 됩니다. 입출력 예 3오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 &quot;LLRLLRLLRL&quot;이 됩니다. 풀이 각 번호를 좌표로 만들고, 두 점 사이의 거리를 이용한다. 소스코드123456789101112131415161718192021222324252627282930313233343536def solution(numbers, hand): number_coord = [(3, 1), (0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)] left_hand = (3, 0) right_hand = (3, 2) answer = '' for number in numbers: if number in [1, 4, 7]: answer += 'L' left_hand = number_coord[number] elif number in [3, 6, 9]: answer += 'R' right_hand = number_coord[number] elif number in [2, 5, 8, 0]: # 다음 pos의 좌료와 현재 양손의 좌표사이의 거리 구하기 next_x, next_y = number_coord[number] left_x, left_y = left_hand right_x, right_y = right_hand # abs(x_h - x_n) + abs(y_h - y_n) left_distance = abs(next_x - left_x) + abs(next_y - left_y) right_distance = abs(next_x - right_x) + abs(next_y - right_y) if left_distance &lt; right_distance: answer += 'L' left_hand = number_coord[number] elif left_distance == right_distance: if hand == 'right': answer += 'R' right_hand = number_coord[number] else: answer += 'L' left_hand = number_coord[number] else: answer += 'R' right_hand = number_coord[number] return answer","link":"/categories/Algorithm/Python/PROGRAMMERS-KAKAO-INTERN-2020-1-21-04-15/"},{"title":"[프로그래머스] [2020 카카오 인턴] 수식 최대화","text":"출처: [2020 카카오 인턴] 수식 최대화 문제IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다. 예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다. 1&quot;100-200*300-500+20&quot; 일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * &gt; +,- 로 우선순위가 정의되어 있습니다.대회 규칙에 따라 + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + &gt; - &gt; * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.반면에 * &gt; + &gt; - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다. 참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요. 제한 expression은 길이가 3 이상 100 이하인 문자열입니다. expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자( 1+, -, * ) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다. 즉, &quot;402+-561*&quot;처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다. expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다. 즉, &quot;100-2145*458+12&quot;처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다. &quot;-56+100&quot;처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다. expression은 적어도 1개 이상의 연산자를 포함하고 있습니다. 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다. 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다. 입출력 expression result &quot;100-200*300-500+20&quot; 60420 &quot;50*6-3*2&quot; 300 입출력 예 1* &gt; + &gt; - 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.연산 순서는 아래와 같습니다.100-200*300-500+20= 100-(200*300)-500+20= 100-60000-(500+20)= (100-60000)-520= (-59900-520)= -60420따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다. 입출력 예 2- &gt; * 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)50*6-3*2= 50*(6-3)*2= (50*3)*2= 150*2= 300따라서, 우승 시 받을 수 있는 상금은 300 입니다. 풀이 식에서 사용 된 연산자 소스코드1234567891011121314151617181920212223242526272829303132from itertools import permutationsimport redef solution(expression): expressions = set(re.findall(&quot;\\D&quot;, expression)) prior = permutations(expressions) result = [] for op_prior in prior: temp = re.compile(&quot;(\\D)&quot;).split('' + expression) for exp in op_prior: while exp in temp: idx = temp.index(exp) temp = temp[:idx - 1] + [str(eval(''.join(temp[idx - 1:idx + 2])))] + temp[idx + 2:] result.append(abs(int(temp[0]))) return max(result)'''if __name__ == &quot;__main__&quot;: expression_list = [&quot;100-200*300-500+20&quot;, &quot;50*6-3*2&quot;] result_list = [60420, 300] length = len(result_list) for i in range(length): answer = solution(expression_list[i]) if answer == result_list[i]: print('{}번 정답입니다.'.format(i + 1)) else: print('{}번 실패입니다.'.format(i + 1)) print('{} != {}'.format(answer, result_list[i]))'''","link":"/categories/Algorithm/Python/PROGRAMMERS-KAKAO-INTERN-2020-2-21-04-15/"},{"title":"[프로그래머스] 문자열 내 마음대로 정렬하기","text":"출처: [코딩테스트 연습] 문자열 내 마음대로 정렬하기 문제문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [“sun”, “bed”, “car”]이고 n이 1이면 각 단어의 인덱스 1의 문자 “u”, “e”, “a”로 strings를 정렬합니다. 제한 strings는 길이 1 이상, 50이하인 배열입니다. strings의 원소는 소문자 알파벳으로 이루어져 있습니다. strings의 원소는 길이 1 이상, 100이하인 문자열입니다. 모든 strings의 원소의 길이는 n보다 큽니다. 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다. 입출력 strings n return [“sun”, “bed”, “car”] 1 [“car”, “bed”, “sun”] [“abce”, “abcd”, “cdx”] 2 [“abcd”, “abce”, “cdx”] 입출력 예 1“sun”, “bed”, “car”의 1번째 인덱스 값은 각각 “u”, “e”, “a” 입니다. 이를 기준으로 strings를 정렬하면 [“car”, “bed”, “sun”] 입니다. 입출력 예 2“abce”와 “abcd”, “cdx”의 2번째 인덱스 값은 “c”, “c”, “x”입니다. 따라서 정렬 후에는 “cdx”가 가장 뒤에 위치합니다. “abce”와 “abcd”는 사전순으로 정렬하면 “abcd”가 우선하므로, 답은 [“abcd”, “abce”, “cdx”] 입니다. 풀이- 소스코드123456789def solution(strings, n): strings.sort() answer = sorted(strings, key=lambda x: x[n]) return answerprint(solution([&quot;sun&quot;, &quot;bed&quot;, &quot;car&quot;], 1))print(solution([&quot;abce&quot;, &quot;abcd&quot;, &quot;cdx&quot;], 2))","link":"/categories/Algorithm/Python/PROGRAMMERS-Practice_Problem-String_free_Sort-07-24/"},{"title":"[프로그래머스] [2021 카카오 채용연계형 인턴십] 숫자 문자열과 영단어","text":"출처: [2021 카카오 채용연계형 인턴십] 숫자 문자열과 영단어 문제 네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다. 다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다. 1478 → “one4seveneight” 234567 → “23four5six7” 10203 → “1zerotwozero3” 이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요. 참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다. 숫자 영단어 0 zero 1 one 2 two 3 three 4 four 5 five 6 six 7 seven 8 eight 9 nine 제한 1 ≤ s의 길이 ≤ 50 s가 “zero” 또는 “0”으로 시작하는 경우는 주어지지 않습니다. return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다. 입출력 s result &quot;one4seveneight&quot; 1478 &quot;23four5six7&quot; 234567 &quot;2three45sixseven&quot; 234567 &quot;123&quot; 123 입출력 예 1 문제 예시와 같습니다. 입출력 예 2 문제 예시와 같습니다. 입출력 예 3 “three”는 3, “six”는 6, “seven”은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다. 입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다. 입출력 예 4 s에는 영단어로 바뀐 부분이 없습니다. 제한시간 안내 정확성 테스트 : 10초 풀이- 소스코드123456789def solution(s): convert_table = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9} answer = s for word, num in convert_table.items(): answer = answer.replace(word, str(num)) return int(answer)","link":"/categories/Algorithm/Python/PROGRAMMERS-KAKAO-INTERN-2021-1-21-07.17/"},{"title":"[프로그래머스] [Summer&#x2F;Winter Coding 2018] 스킬트리","text":"출처: [Summer/Winter Coding 2018] 스킬트리 문제선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다. 예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다. 위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다. 선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요. 제한 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다. 스킬 순서와 스킬트리는 문자열로 표기합니다. 예를 들어, C → B → D 라면 “CBD”로 표기합니다 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다. skill_trees는 길이 1 이상 20 이하인 배열입니다. skill_trees의 원소는 스킬을 나타내는 문자열입니다. skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다. 입출력 skill skill_trees return &quot;CBD&quot; [&quot;BACDE&quot;, &quot;CBADF&quot;, &quot;AECB&quot;, &quot;BDA&quot;] 2 입출력 예 1 “BACDE”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다. “CBADF”: 가능한 스킬트리입니다. “AECB”: 가능한 스킬트리입니다. “BDA”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다. 풀이- 소스코드1234567891011121314def solution(skill, skill_trees): answer = 0 for skills in skill_trees: skill_list = list(skill) for s in skills: if s in skill: if s != skill_list.pop(0): break else: answer += 1 return answer","link":"/categories/Algorithm/Python/PROGRAMMERS-SWC-2018-skill_tree-21-07-06/"},{"title":"[프로그래머스] Lv2.주식가격","text":"출처: [코딩테스트 연습 완주하지 못한 선수] 문제초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요. 제한 prices의 각 가격은 1 이상 10,000 이하인 자연수입니다. prices의 길이는 2 이상 100,000 이하입니다. 입출력 prices return [1, 2, 3, 2, 3] [4, 3, 1, 1, 0] 입출력 예 1 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다. 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다. 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다. 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다. 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다. 소스코드123456789101112def solution(prices): answer = [] for i in range(len(prices)): count = 0 for j in range(i + 1, len(prices)): count += 1 if prices[i] &gt; prices[j]: break answer.append(count) return answer","link":"/categories/Algorithm/Python/PROGRAMMERS-Stack,Queue-stockPrice-07-17/"},{"title":"[SWEA] 최빈수 구하기","text":"출처: [SWEA] 최빈수 구하기 소스코드12345678910111213141516171819202122import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): test_case = int(input()) score_list = list(map(int, input().split())) score_list.sort(reverse=True) students = {} for i in range(101): students[i] = 0 for score in score_list: students[score] += 1 max_value = max(students.values()) result=0 for key, value in students.items(): if value == max_value: result = key print(&quot;#{0} {1}&quot;.format(test_case, result)) # print(max(students.values()))","link":"/categories/Algorithm/Python/SWEA-1204-21-05-13/"},{"title":"[코드잇] 강남역 침수","text":"출처: [코드잇] 강남역 침수 풀이 소스코드1234567891011121314151617181920212223242526def trapping_rain(buildings): max_height = max(buildings) start_point = False current_height = 0 total = 0 for i in range(len(buildings) - 1): # 마지막은 스킵 if start_point == 0 and buildings[i] &gt; 0: start_point = 1 current_height = buildings[i] else: if buildings[i] == max_height: continue if buildings[i] &lt; current_height: total += current_height - buildings[i] else: current_height = buildings[i] return total# 테스트print(trapping_rain([3, 0, 0, 2, 0, 4]))print(trapping_rain([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))","link":"/categories/Algorithm/Python/%EC%BD%94%EB%93%9C%EC%9E%87-%EA%B0%95%EB%82%A8%EC%97%AD-%EC%B9%A8%EC%88%98-21-04-08/"},{"title":"[Ubuntu] Certbot을 이용한 인증서 발급하기","text":"노션에서 보기 이채현 💡 Certbot을 통해 무료로 서버인증서를 발급하고, 자동으로 갱신 가능 snapd 설치하기 (snapd 없는 경우)최신 버전의 우분투에는 snapd가 설치되어있는 것으로 알고 있음 1234# apt # snap# Ubuntusudo apt install snapdsudo reboot certbot 설치하기 (snap)123sudo snap install core; sudo snap refresh coresudo snap install --classic certbotsudo ln -s /snap/bin/certbot /usr/bin/certbot cloudflare plugin 설치하기123# dns cloudflaresudo snap set certbot trust-plugin-with-root=oksudo snap install certbot-dns-cloudflare cloudflare api token 넣기123456mkdir -p ~/.secrets/certbotvi ~/.secrets/certbot/cloudflare.ini----------------------------------# Cloudflare API token used by Certbotdns_cloudflare_api_token = IdgrE2pGEQxdq43kQPJ8*****************chmod 600 ~/.secrets/certbot/cloudflare.ini 자신의 도메인 인증서 등록하기123456789101112131415161718192021222324252627282930313233343536373839404142434445## *.4084.livesudo certbot certonly --dns-cloudflare \\\\ --dns-cloudflare-credentials ~/.secrets/certbot/cloudflare.ini \\\\ -d *.4084.live-----------------ubuntu@dev-project-app:~$ sudo certbot certonly --dns-cloudflare \\\\&gt; --dns-cloudflare-credentials ~/.secrets/certbot/cloudflare.ini \\\\&gt; -d *.4084.liveSaving debug log to /var/log/letsencrypt/letsencrypt.logEnter email address (used for urgent renewal and security notices) (Enter 'c' to cancel): ----@gmail.com- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Please read the Terms of Service at&lt;https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf&gt;. You mustagree in order to register with the ACME server. Do you agree?- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o: Y- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Would you be willing, once your first certificate is successfully issued, toshare your email address with the Electronic Frontier Foundation, a foundingpartner of the Let's Encrypt project and the non-profit organization thatdevelops Certbot? We'd like to send you email about our work encrypting the web,EFF news, campaigns, and ways to support digital freedom.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o: YAccount registered.Requesting a certificate for *.4084.liveWaiting 10 seconds for DNS changes to propagateSuccessfully received certificate.Certificate is saved at: /etc/letsencrypt/live/4084.live/fullchain.pemKey is saved at: /etc/letsencrypt/live/4084.live/privkey.pemThis certificate expires on 2022-02-26.These files will be updated when the certificate renews.Certbot has set up a scheduled task to automatically renew this certificate in the background.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -If you like Certbot, please consider supporting our work by: * Donating to ISRG / Let's Encrypt: &lt;https://letsencrypt.org/donate&gt; * Donating to EFF: &lt;https://eff.org/donate-le&gt;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 생성된 인증서 경로 /etc/letsencrypt/live/4084.live/fullchain.pem /etc/letsencrypt/live/4084.live/privkey.pem 인증서 갱신하기12345# (--dry-run)sudo certbot renew --dry-run#(xx )sudo certbot renew crontab을 이용하여 주기적으로 갱신(매주 일요일 2시 1분에 실행) 1234crontab -e-----------# cert renewal1 2 * * 0 sudo /usr/bin/certbot renew 참고링크 Let’s Encrypt (letsencrypt.org) https://certbot.eff.org/ User Guide — Certbot 1.15.0.dev0 documentation (eff.org) https://certbot-dns-cloudflare.readthedocs.io/en/stable/ User Guide — Certbot 1.15.0.dev0 documentation (eff.org) How to install SSL certificate for Nginx server in Amazon Linux | by Sagar Shrestha | Level Up Coding (gitconnected.com)","link":"/categories/DevOps/Ubuntu/UBUNTU-Certbot-21-11-28/"},{"title":"[Ubuntu] EC2 Ubuntu에 접속 후 초기 셋팅","text":"노션에서 보기 이채현 💡 키를 이용하여 생성한 EC2 Ubuntu 인스턴스에 접속해보자 (mac os 기준) 인스턴스를 생성할 때 키페어 생성하여 위치확인하기 키 페어 저장다운로드 한 키페어를 ~/.ssh 폴더 안에 위치시키고 권한을 600으로 변경한다 12cp ~/Downloads/{keypair-name.pem} ~/.ssh/AWSchmod 600 {keypair-name.pem} 접속1ssh -i ./{keypair-name.pem} ubuntu@{public ipv4 주소} 로그인 후패키지 업데이트12sudo apt updatesudo apt upgrade hostname 변경12sudo hostnamectl set-hostname {원하는 이름}# 재접속 타임존 변경1sudo timedatectl set-timezone Asia/Seoul 개인PC에서 간단히 접속하기ssh명령어를 이용하여 접속할 때에는 인증키의 위치를 계정명, 주소를 같이 입력해줘야하는 번거로움이 있다. 이를 개인pc의 인증서를 등록하여 인증서없이 바로 로그인해보자 id_rsa 키 생성하기 (개인-Mac)12cd ~/.sshssh-keygen 이후 ~/.ssh 폴더 내부에 생성 된 id_rsa(private) id_rsa.pub(public) 두개의 키를 확인할 수 있다.이 중 id_rsa.pub의 내용을 복사한다. authorized_keys 수정하기 (원격-Ubuntu)12vim ~/.ssh/authorized_keys위에서 복사한 id_rsa.pub 내용을 붙여넣고 저장한다.","link":"/categories/DevOps/Ubuntu/UBUNTU-Connect1-21-11-28/"},{"title":"[Git] git status 한글 깨짐 해결하기","text":"git status나 commit 할 때, 한글이름을 가지는 파일일 경우에 \\352\\271\\200\\ 이런식으로 파일명이 깨지는 경우가 있다. 위 사진처럼 한글이 깨진다면, 아래 코드 한줄을 입력한다. 1git config --global core.quotepath false 다시 확인해보면, 아래 사진과 같이 파일명이 잘 나오는 것을 볼 수 잇다.","link":"/categories/Programming/GIT/GITHUB-Korean-21-07-21/"},{"title":"[프로그래머스] 디스크 컨트롤러","text":"출처: [코딩테스트 연습] 디스크 컨트롤러 문제하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다. 예를들어 123- 0ms 시점에 3ms가 소요되는 A작업 요청- 1ms 시점에 9ms가 소요되는 B작업 요청- 2ms 시점에 6ms가 소요되는 C작업 요청 와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다. 한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다. 123- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms) 이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다. 하지만 A → C → B 순서대로 처리하면 123- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms) 이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다. 각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다) 제한 jobs의 길이는 1 이상 500 이하입니다. jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다. 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다. 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다. 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다. 입출력 jobs return [[0, 3], [1, 9], [2, 6]] 9 입출력 예 1문제에 주어진 예와 같습니다. 0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다. 1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다. 2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다. 풀이 우선순위 큐를 이용해서… 현재 시점에서 처리할 수 있는 작업들을 힙에 넣고, 하나를 뽑아 현재 시점과 총 대기시간을 구해주는 것을 모든 작업을 처리할 때까지 반복한다.힙에 push를 할 때는 작업의 소요 시간 기준으로 최소힙이 만들어져야 하기 때문에 jobs의 요소를 그대로 넣지 않고 [작업의 소요 시간, 작업이 요청되는 시점]으로 요소의 앞 뒤를 바꿔서 넣어준다.현재 시점에서 처리할 수 있는 작업인지를 판별하는 조건은 작업의 요청 시간이 바로 이전에 완료한 작업의 시작 시간(start)보다 크고 현재 시점(now)보다 작거나 같아야 한다.만약 현재 처리할 수 있는 작업이 없다면, 남아 있는 작업들의 요청 시간이 아직 오지 않은 것이기 때문에 현재 시점(now)을 하나 올려준다. 출처 소스코드12345678910111213141516171819202122232425import heapqdef solution(jobs): answer, now, i = 0, 0, 0 start = -1 heap = [] while i &lt; len(jobs): for j in jobs: if start &lt; j[0] &lt;= now: heapq.heappush(heap, [j[1], j[0]]) if len(heap) &gt; 0: current = heapq.heappop(heap) start = now now += current[0] answer += (now - current[1]) i += 1 else: now += 1 return int(answer / len(jobs))# print(solution([[0, 3], [1, 9], [2, 6]])) # 9","link":"/categories/Algorithm/Python/PROGRAMMERS-HEAP-disk_controller-05-04/"},{"title":"2021년 3월 13일 토요일 주간 IT 뉴스 - 인앱 결제 법 &quot;","text":"개요콘텐츠 개발사들은 보통 구글과 애플 자체 앱스토어에 앱을 등록하여 공급한다. 그리고 앱으로 얻는 수익 중 일부를 수수료로 각 스토어에 지불한다. 이는 구글과 애플이 앱 자체 결제를 막고, 자사 결제 수단만 사용할 수 있도록 했기 때문이다. 그렇기 때문에 구글과 애플이 수수료를 건들면, 개발사들은 그대로 영향을 받을 수밖에 없다. 위와 같은 문제로 전 세계적으로 구글 갑질 방지법이라 불리는 강제 인앱 결제 방지를 위한 법을 마련하는 움직임을 보이고, 우리나라 또한 법안을 발의하려고 하고 있다. 중소개발사: 구글, 애플의 수수료, 동등접근권에 의한 원스토어 어플등록à앱 관리비용 증가 ​ 전기통신사업법 개정안과 관련해 ‘동등접근권’: 일정 규모 이상의 사업자는 구글, 애플뿐만 아니라 원스토어와 같은 국내 앱 마켓에도 의무적으로 앱을 공급해야 한다는 내용이 있다. 대형개발사: 구글, 애플의 수수료à소비자에게 전가 ex) 카카오톡 자체 이모티콘샵(웹)에서 자체 결제수단을 이용하면 20% 할인해주는 쿠폰을 사용할 수 있다(거의 매달 지급). 이는 카카오톡 앱으로 구매할 경우 구글의 인앱 결제 정책으로 인해 30%의 수수료를 가져가니, 20% 웹 쿠폰을 이용하여 소비자가 웹으로 구매할 수 있도록 유도하는 것으로 알 수 있다. 결국 이런 대형 개발사들은 앱 마켓의 수수료를 소비자에게 전가하고 있다. 원스토어((통신 3사, 네이버)): 이때 국내 통신 3사와 네이버의 원스토어는 구글보다 수수료를 낮게 받아 홍보 효과를 가졌다. 국내 앱 마켓 시장 점유율을 18.4%까지 끌어올림 사실상 이 시점까지는 대형개발사들과 원스토어의 손해는 미미하고, 결국 손해는 중소개발자와 소비자에게 전가되고 있으며, 구글과 애플은 엄청난 이득을 보고 있다는 생각이 든다. 3월12일 “[단독] 마음 바뀐 원스토어, ‘구글 갑질 방지법’ 돌연 반대” (https://news.naver.com/main/read.nhn?mode=LSD&amp;mid=shm&amp;sid1=105&amp;oid=366&amp;aid=0000683520) 국내 원스토어는 인앱 결제 방지법에 돌연 반대 의사를 보인다. 이는 이 법안으로 인해 손해를 볼 수 있다는 결과가 나왔기 때문이다. 구글, 애플을 규제하기 시작하면 당연히 원스토어도 규제대상에 들어가기 때문에 지금까지 받던 수수료는 물론 점유율도 잃게 된다. 여기서 일부 언론은 국내 앱, 국내 플랫폼을 위한다는 취지로 법안을 발의하고 논의했는데 국내 업체까지도 죽이는 정책이 될 것이라고는 전혀 예상하지 못했다고 말한다. 물론 일부 국내 플랫폼 또한 제재에 들어가겠지만, 결국 소비자를 위한 법안이여야 하지않나… 생각이 든다. 인앱 결제 방지법이 통과되면, 국내 개발사들은 자사 앱에 자체 결제수단을 넣을 수 있고, 앱스토어에 지불하는 수수료가 최소화될 수 있다. 또한, 독과점 대기업의 횡포로 인한 소비자의 피해를 최소화 할 수 있을 것이다. 하지만, 앱 자체 결제수단으로 인해, 앱스토어의 수익은 감소하고 피해도 클 것이다. 그러니 국회, 개발사 등들은 무작정 법안을 발의, 지지, 혹은 문제가 된다고 반대를 하는 것이 아니라 적절한 타협점을 찾아야 하지 않겠냐는 생각이 든다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EC%A3%BC%EA%B0%84%20IT%EC%A0%95%EB%A6%AC/21-03-13-Weekly_IT_News/"},{"title":"[Git] 특정 Branch만 Clone하기","text":"Git을 사용하면서 브랜치 전체 Clone하지 않고, 특정 브랜치 하나만 사용해야할 경우가 있다. 하지만, 기본적으로 알고 있는 방법으로 git clone할 경우 Master가 바로 Clone됨으로, 특정 브랜치만 클론하는 방법을 알아보자 1234git clone -b &lt;branch명&gt; --single-branch &lt;저장소URL&gt;ex) git clone -b rpi-4.12.y --single-branch https://github.com/raspberrypi/linux","link":"/categories/Programming/GIT/GITHUB-Branch-21-07-26/"},{"title":"2021년 3월 27일 토요일 주간 IT 뉴스 - 메타버스","text":"개요이번 한 주간 메타버스에 관한 많은 기사들이 올라왔다. 메타버스라는 단어는 이번에 처음들어봤고, 흥미로운 이야기가 많았다. 또 한, 개인적으로 앞으로 이 분야의 발전이 기대된다.그래서 그동안 올라온 기사와 관련된 내용 정리와 내 생각을 정리해보았다. 메타버스란?메타버스는 가공·추상을 의미하는 ‘메타’(Meta)와 현실세계를 가리키는 ‘유니버스’(Universe)의 합성어로 ‘3차원(3D) 가상세계’를 일컫는 말이다. 사용자의 몸은 현실에 있지만 메타버스에 접속하면 무엇이든 현실처럼 누릴 수 있는 가상공간이 펼쳐진다. 쉽게 VR, AR 등등 기술의 확장판 같다. 그리고 기존의 단순 가상세계와도 구분된다. 플랫폼 제공자가 판매자, 사용자는 소비자의 역할만 하는 게 아니라 각각 서로 재화와 서비스를 사고팔 수 있다. 여기에 증강현실(AR)·확장현실(XR)·5세대(5G) 통신 같은 기술 발전이 더해져 가상과 현실 사이의 간극이 좁아지고 있다. 메타버스에 대한 관심최근 메타버스에 대한 관심이 급증한 것은 미국의 메타버스 게임 플랫폼 기업 로블록스가 지난 10일 미국 증시에 상장하면서다. 로블록스는 아바타를 꾸미고 친구들과 각종 경험을 즐길 수 있는 플랫폼을 제공해 메타버스 대장주로 꼽힌다. 해외 - 로블록스미국은 신종 코로나 바이러스 감염증(코로나19) 사태로 인한 거리두기로 집에서 게임하는 아이들이 증가하였고, 이에 로블록스에 접속하여 가상세계에서 친구들을 만나는 경우가 많아졌다. 로블록스의 월간 활성 이용자 수(MAU)는 약 1억5000만 명에 달하고, 이 중 3분의 1은 16세 미만이다. 미국 912세 어린이의 3분의 2가 로블록스를 하는 것으로 알려졌다. 즉 미국의 Z세대(1990년대 중반2000년대 초반 출생자) 중 절반 이상이 로블록스를 즐기는 것으로 알려졌다. 미국인 이든 가브론스키(20)는 ‘로블록스’가 무료로 제공하는 개발도구를 이용하여 만든 게임을 통해 지난달 4만9000달러(약 5500만원)를 벌었다. 즉 가상세계에서 누구나 플레이어가 될 수 있고 동시에 게임 개발자가 될 수 있다. 친구들과 프라이빗 룸을 만드는 소셜미디어(SNS) 기능도 있다. 엔터테인먼트 기능도 빼놓을 수 없다. 미국의 유명 래퍼 릴 나스 엑스가 지난해 11월 로블록스에서 개최한 가상 콘서트에는 이틀 동안 약 3300만 명이 몰렸다. 국내네이버의 가상 세계 플랫폼인 ‘제페토’는 10대들을 겨냥한 국내 대표적인 아바타 플랫폼으로 자리 잡아가고 있다. SK텔레콤은 지난해 혼합현실(MR) 서비스 컴퍼니를 신설하는 등 메타버스 서비스 확장에 박차를 가하고 있다. LG전자는 닌텐도의 스위치 게임 ‘모여봐요 동물의 숲’을 활용한 올레드(OLED·유기발광다이오드) TV 마케팅을 시작한다고 했으며, 동물의 숲에 ‘올레드 섬’을 만들고, 게이머들에게 스포츠와 영화·게임 컨셉트로 꾸며진 올레드 TV의 체험 기회를 제공한다. 기타일본 애니메이션 ‘소드아트온라인’, 영화 ‘레디 플레이어 원’ 등 이미 메타버스라는 개념을 포함한 미디어도 등장했었고, 글로벌 회계·컨설팅 그룹인 프라이스워터하우스쿠퍼스(PwC)는 메타버스의 기술적 근간을 형성하는 확장현실(XR) 시장이 2025년 537조원에서 2030년 1천700조원으로 성장할 것으로 내다봤다. 기술적 기대 VR, AR 등 기술, 5G네트워크, 클라우드 컴퓨팅 실제 이미지와 유사한, 고성능의 텍스쳐를 구현하기 위한 그래픽성능이 필요할 것이다. 하지만, 일반 사용자에게 고성능 그래픽 성능을 요구하는 것은 요즘 추세와 맞지 않다고 생각한다. 이에 현재 지속적으로 성장중인 ‘클라우드 스트리밍 게임’의 기술이 이용될 것이다.클라우드 컴퓨팅 기술의 발전으로 사용자가 고성능의 그래픽카드 없이 간단히 기기만 착용한 채, 고성능 클라우드 서버에 접속하여 스트리밍을 통해 메타버스 플랫폼 기술을 즐길 수 있을 것이다. 위와 동시에 5G 네트워크 기술 또한 기반이 될것이다. 사업적 기대 메타버스는 이를 구현할 기반 기술과 게임, 엔터, 교육, 의료 등의 영역에서 영향력을 확대해나가며 급성장할 것으로 예상 메타버스의 수익모델은 게임 아이템 판매에서 마케팅 솔루션 제공, 이커머스·콘서트 개최 등 점점 현실세계와 연계하는 쪽으로 진화하고 있다.이승환 소프트웨어정책연구소 지능데이터연구팀장은 “최근의 메타버스는 인공지능(AI)·XR·5G 등 신기술과 시너지를 내면서 현실과 가상의 경계를 허물어뜨리고 있다”며 “조만간 교육이나 의료 분야에도 적용될 것”이라고 내다봤다. 부정적 시선… 과연?반면 호기심이나 흥밋거리에 그칠 수 있다고 비관론도 있다. 코로나19로 반사이익을 얻었을 뿐 ‘대세’가 될 수 없다는 지적이다. 이미 2003년 미국의 린든랩은 ‘세컨드 라이프’라는 3D 가상세계 서비스를 선보였으나 실패했다. 국내에는 1998년 등장했던 사이버 가수 ‘아담’이 있다. 당시 앨범 판매량 20만여 장, 광고수익으로 5억여 원을 벌었으나 반짝인기에 그쳤다. 하지만, 과거에 비해 가격은 싸지고, 성능은 비약적으로 발전했다 .위에서 언급한 클라우드 스트리밍 기술은 PC와 모바일, 콘슬 등과 게임 플랫폼의 경계를 허물고 있다. 또한 메타버스를 지원하는 가상현실(VR)·AR 등 ‘몰입 기기’의 가격도 내려가고 있고, 몰입 기기의 평균 가격은 1991년 41만 달러(약 4억6000만원)에서 2020년 2만 달러(약 2200만원) 수준으로 감소했고, 10년 뒤에는 1700 달러(약 192만원)까지 하락할 전망이다. 그렇기 때문에 일반 소비자들도 쉽게 즐길 수 있는 수준이 되어가고 있다. 기타 추가 생각로블록스를 생각하면, 메타버스라는 기술의 성장 방향은 무궁무진한 것 같다. 기술이 충분히 뒷받친다면 저 개념은 현실세계 모든 분야에 적용할 수 있다고 생각한다. LG전자가 동물의 숲에서 하는 OLED광고처럼 사람들은 광고를 공간과 시간의 제약없이 체험할 수 있을 것이다. 콘서트나 연극 등과 같은 것 또한 충분히 집에서 즐길 수 있을 것이며, 실시간 스포츠경기를 실제 경기장에 있는 것과 같은 느낌을 받으며 관람할 수 있을 것이다. 가상현실을 이용한 심리치료 또한 충분히 가능하며… 메타버스가 여러 기술과 복합적으로 작용하면 지금 우리가 생활하는 현실은 크게 바뀔 것으로 추측한다. 기사 출처출처: 중앙일보 반짝 유행 vs 1700조 성장···요즘 난리난 메타버스 미래는 42조원 가치 ‘로블록스’…게임 만들고 친구와 즐겨","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EC%A3%BC%EA%B0%84%20IT%EC%A0%95%EB%A6%AC/21-03-27-Weekly_IT_News/"},{"title":"2021년 4월 3일 토요일 주간 IT 뉴스 - IT업계 노동조합 형성 움직임 &quot;","text":"개요이번 한 주 IT뉴스 정리의 주제는 최근 IT업계들이 노동조합. 노조를 형성하는 움직임이 보이는 것에 대해 기사와 관련된 내용 정리와 나의 생각을 간략히 적어보았다. 2021년 3월 31일 수요일 IT뉴스 추가적으로 우리나라의 주요 노동조합은 특정 정치적 성향을 띄고 있다. 그렇기 때문에 이번 주제에 대해 매우 심도있게 생각하면 글에 정치적 성향이 묻어나올 수 있기 때문에 정치적 성향을 완전히 빼고 학생, 취준생 입장에서 바라보는 것들 위주로 적을 것이다. (모두의 생각을 존중하자구~) IT업계의 노동조합 왜 이슈?일반적으로 노동조합은 회사에 기여한다기 보다는 근로자의 근무환경과 복지를 좋게 하는 것에 목적이 있다고 보면 된다. IT부문은 업의 특성상 노조가 별로 없었다. 크게 세가지 정도의 이유를 뽑자면, IT업계 특유의 개인주의적 성향 민주노총 관계자는 “IT업종 종사자들 스스로 벤처 기업문화가 일반 기업과 다르다는 인식을 하고 있어 노조에 대한 관심이 상대적으로 적다”라고 지적한다. 상당수의 노동자들이 조직적 협력보다는 개별 경쟁으로 임금 및 처우개선을 추구하는 전략을 채택하고 있다. 하청업체에서 근무할 바에 내가 직접 따서 일하고 만다는 인식때문에 프리랜서가 많음 대부분 계약에서 팀 단위로 지정된 프로젝트 장소로 파견돼 업무 수행 고용안정성이 낮아 이직이 잦고, 노조가입에 대한 인식이 낮음 다수의 근로자들이 본인을 자영업자나 준전문직으로 인식하고 있어 단체가 아닌 개별적으로 연봉과 직업 환경을 이직을 통해 바꾸려 하는 태도를 가지고 있음 좋은 근무 환경 일반적으로 높은 수준의 임금, 잘 갖춰진 복지, 사측과의 원활한 의사소통과 직원 의사 반영이 잘 되면 노조가 잘 안생긴고 생각하며, 노조는 임금이든 뭐든 직원들의 불만을 가질 때 생긴다. 자유로운 근무환경도 영향을 미친다. 대외적으로 IT업계는 창의성을 높이고, 생산성을 높이고, 실용적이고 효율적이고, 합리적인 조직문화 어쩌구 하면서 대내외적으로 좋은 문화를 갖추기 위해 노력하는 모습을 보여주려는 기업이 많다. 건설업과 비슷한 업무 구조 건설은 원청에서 발주를 하면 하청을 받고, 또 그 업체가 하청을 주고, 그 업체가 또 하청을 준다. 인력시장의 노가다꾼들이 이렇게 만들어진 공사판으로 간다. 새벽같이 나와서 하루벌어 일당 챙겨가는 사람에게는 소속이 없고, 그래서 소속감도 없다. 개발자도도 비슷하다. 소위 SI라고 불리는 산업에 종사하는 개발자들은 다단계 하도급의 구조에서 근무하고 있다. 차이점이 있다면 더울 때 시원한 곳에서, 추울때 따듯한 곳에서 책상 앞에 앉아 일한다는 것. 하지만 일거리 자체는 어쨌거나 무언가를 만들고, 유지하고 보수하는 일이다. 그 재료가 시멘트나 벽돌이 아니고 도구가 삽이 아닐 뿐이다. 생각해서 구조를 짜고, 키보드로 열심히 빌딩하지만 형태적으로는 유사한 측면이 있다. 회사에 오래 붙어있어야 소속감이라는 것도 생긴다. 노조도 회사에 애정이 있어야 한다. 파편으로 쪼개져 힘들게 일만하고 있는 상황, 사측에 대항하는 ‘우리’가 흐릿하게 느껴지는 상황이라면 탈출이 훨씬 빠른 방법이다. 출처 이렇게, ‘3N’이라 불리는 국내 톱3 게임사 넥슨·넷마블·엔씨소프트만 하더라도 임직원들의 평균 근속년수가 4~6년에 불과할 정도로 이직이 잦아 똘똘뭉쳐 노조를 만들 동력이 적었다. 판교에 있는 IT 기업들은 대체로 규모가 작거나 회사 역사가 오래되지 않아서 노조가 만들어지기 어려운 측면도 있었다. 2018년에서야 주 52시간 근무제가 도입되면서 ‘판교의 등대’라 불릴 정도로 야근이 많았던 기업들 중심으로 ‘노조 붐’이 일었지만 네이버·카카오·넥슨·안랩·스마일게이트·엑스엘게임즈 등 노조가 실제 설립된 곳은 손으로 꼽을 정도였다. IT업계의 노동조합 설립 봄바람 ​ - 전국민주노동조합총연맹(민주노총) 정보기술(IT) 업계에 노동조합 설립 봄바람이 불고 있다. 코로나19 사태가 ‘IT업계 호황→개발자 부족→연봉 인상→연봉·성과급 충분치 않은 직원 불만 토로’를 촉발했는데 이것이 이제는 노조 설립으로까지 이어지는 것이다. 봄바람처럼 살살 불기 시작한 노조 설립 기조가 강풍으로 변하고 있다. 30일 업계에 따르면 중견 게임회사인 ‘웹젠’ 일부 직원들이 노조 설립을 준비하고 있다. 웹젠은 최근 임직원들의 평균 연봉을 2000만원씩 올렸는데 이것이 일부 개발자나 퍼블리싱(게임 유통) 사업부에 집중되면서 내부 불만이 생겼다. 웹젠의 한 직원은 “주변에서는 연봉이 2000만원이나 올랐느냐며 부러워하는데 실제로는 그렇지 않아서 괴롭다”고 말했다. 즉, 언론을 통해 나온 정보와 실제는 다르다는 것이다. 위에 직원이 한 말처럼 일부 직원들은 주변사람들이 대수롭지 않게, 부러워하며 말하는 것들이 스트레스가 될 수도 있을 것같다. 이에 앞서 지난 25일에는 ‘카카오뱅크’에 인터넷은행 최초로 노조가 설립됐고, 지난 23일 소프트웨어 업체 ‘한글과컴퓨터’에도 2004년 해산된 이후 17년 만에 노조가 재설립됐다는 소식이 알려졌다. LG전자에서도 지난달 25일 사무직 중심의 제3노조가 만들어져 3000명이 넘는 조합원을 모았다. 하지만 지난해 IT 업체들이 호황을 맞았음에도 성과급 분배와 연봉 인상에 있어서 불합리한 대우를 받았다고 생각한 직원들을 중심으로 노조를 설립하자는 움직임이 일어났다. SK텔레콤이나 SK하이닉스 등의 대기업에서도 성과급 논란이 있었지만 결국 노조가 앞장서서 회사와 싸우니 어느 정도 추가 보상을 얻어냈던 것도 이번 노조 설립 바람에 영향을 미쳤다. 업계 관계자는 “모처럼의 기회를 놓치면 안 된다는 분위기가 팽배하기 때문에 노조 설립 소식이 계속될 것”이라고 말했다. 실제 위 기사에 아래와 같은 댓글이 있다. “IT근로자들 매트릭스 영화의 인간 배터리처럼 일한다.드라마의 스마트한 개발자를 연상하면 안된다…대다수는 일명 코딩삽진을한다, 발추처 한마디, 또는 책임자, 총괄의 단 몇마디에 애버랜드를 제주도에 만들었다가 부산으로 옮기는 심정으로 코딩 삽질을 한다. … 시간으로 보나 스트레스, 업무강도 등을 볼때 대다수의 개발자들이 혹사당하고 있다. 또한 소규모 벤처나 스타트업들이 장미빛 미래를 이야기하며. 열정페이를 종용한다…. 하지만 성공했을때 제 2의 도약을 빌미로 약속은 또 미루어지고, 개발자는 지쳐서 떨어져나간다” 출처 내가 IT 관련 분야에 관심을 가진지 중2 때부터…. 벌써 10년째이다. 10년 동안 이 분야 내에서도 관심을 가지고 좋아했던 건 여러 번 바뀌었다. 그래도 ‘IT업계? 에서 일할 거야’라는 생각으로 지금까지 왔고, 이제 곧 졸업을 앞두고 취업 준비를 하고 있다. 여러 번의 아르바이트와 군대 내에서 일을 하다 보면 조직 전체와 직원들은 언제나 마찰이 있었다. 하지만 어차피 애착도 별로 없고 지나갈 일이라는 생각하며 내 몸만 지켰다. 그런데 10년 동안 좋아하던 분야로 취업을 하여 일을 했을 때, 내 생각은 어떻게 변할까? 지금 생각은 내가 좋아하는 기업에 들어간다면 뼈를 묻겠다는 심정으로 일할 것 같은데…남들이 보기에 어찌 됐든, 나는 내가 원하는 기업에 들어가 일할 수 있으면 좋을 것 같다.고등학생 땐, 대학에 들어가면 만족할 줄 알았지…군인일 땐, 전역하면 편할 줄 알았지..지금은 취업만 하면 다 될 것 같다……. 어찌 되었든 노동조합이 형성되는 분위기인데, 어느 조직이든 한쪽에서 일방적으로 의견을 쏟아내지 말고 상대의 의견을 서로 경청하면 이미 잘하고 있는 IT업계 분위기에 악영향은 없을 것 같다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EC%A3%BC%EA%B0%84%20IT%EC%A0%95%EB%A6%AC/21-04-03-Weekly_IT_News/"},{"title":"2021년 4월 17일 토요일 주간 IT 뉴스 - 네이버와 카카오 &quot;","text":"개요이번 한 주간에 네이버와 카카오의 분야를 막론하고 몸집 불리는 소식에 대한 기사들을 많이 읽었다. 이 두 SW회사는 무슨 플랫폼에 인수와 투자를 하고 있는지 간단히 정리해보자. 이커머스네이버는 지난해 10월 패션 플랫폼 스타트업 브랜디에 100억원 규모 투자를 했다. 2014년 12월 설립된 브랜디는 여성 패션 플랫폼 ‘브랜디’, 남성패션 플랫폼 ‘하이버’를 비롯해 상품포장, 배송, 고객 응대까지 처리해주는 올인원 풀필먼트(통합물류대행) 패션 서비스 ‘헬피’를 운영하고 있다. 네이버는 브랜디 투자를 계기로 동대문 패션 클러스터 활성화에 자사 역량을 접목하고 도소매상 온라인 판로 개척, 풀필먼트, 정보기술(IT) 인프라 제공 등에서 영향력을 확대하고 있다. 카카오는 최근 ‘카카오스타일’을 운영하는 카카오커머스의 스타일 사업부문을 인적분할해 패션 플랫폼 ‘지그재그’를 운영하는 크로키닷컴과 합병한다고 밝혔다. 올 7월 출범하는 합병 법인은 카카오 자회사로 편입되고 대표는 크로키닷컴 서정훈 대표가 맡는다. 합병 법인은 지그재그가 보유한 빅데이터와 카카오의 기술력·사업 역량 등을 결합해 경쟁력 있는 사업 기반을 갖추고 신규 사업기회를 발굴해나갈 예정이다. 크로키닷컴이 2015년 출시한 지그재그는 4000곳이 넘는 온라인 쇼핑몰과 패션 브랜드를 모아서 제공하는 모바일 서비스로, 올해 거래액 1조원 규모가 예상될 만큼 성장성이 유망한 플랫폼으로 평가받는다. 합병법인은 글로벌도 넘보고 있습니다. 카카오는 ‘내수용 기업’이라는 꼬리표를 떼지 못하고 있습니다. 카카오 배재현 수석부사장(CIO)은 “카카오가 보유한 글로벌 콘텐츠·팬덤의 영향력과 시너지를 통해 향후 물류 접근성이 용이한 일본, 중국 등 아시아 지역으로 사업을 확장, 글로벌 패션 플랫폼으로 거듭나길 기대한다”고 말했습니다. 기대대로 사업이 흘러간다면 카카오의 숙원사업, ‘해외 공략’이 가능해지는 것 뿐만 아니라 한계가 있어 보이던 커머스 사업의 판을 카톡이 아니라 글로벌로 넓힐 수 있다. 업계 관계자는 “플랫폼 인수와 투자로 많은 돈이 오가고 있는데 패션만큼 유행과 트렌드에 민감한 분야도 없다”면서 “지금 자리를 잡은 플랫폼을 잘 끌고 가기 위해선 지속적 투자와 디자이너 발굴이 더욱 중요하다”고 말했다. 카카오·네이버 ‘패션’에 거액 투자한 이유…이커머스 성장 : 네이버 뉴스 (naver.com) [넘버스]지그재그 품은 카카오, 해외로 가는 ‘신의 한 수’ 될까 : 네이버 뉴스 (naver.com) 콘텐츠국내 콘텐트 강자 네이버와 카카오가 차례로 북미 웹툰·웹소설 플랫폼을 인수하며 본격 지식재산권(IP) 전쟁에 나섰다. 글로벌 진출을 염원하던 두 기업이 콘텐트를 앞세워 세계 최대 엔터테인먼트&amp;미디어(E&amp;M) 시장인 미국에서 맞붙는 모양새다. 네이버와 카카오가 북미시장에서 검증을 마친 IP 플랫폼을 사들이고 있다. 국내 IP로 글로벌 히트를 친 ‘스위트홈(네이버웹툰·넷플릭스)’, ‘승리호(카카오엔터테인먼트·넷플릭스)’를 넘어 마블이나 트와일라잇처럼 세계 시장에서 통할 ‘글로벌 IP’를 발굴하려는 시도다. 네이버는 지난 1월 세계 최대 웹소설 플랫폼 ‘왓패드’를 약 6533억원에 인수했다. 왓패드엔 글로벌 독자 9000만 명, 500만 명의 창작자, 10억편의 작품이 있다. 네이버의 목표는 왓패드에서 ‘똘똘한’ IP를 발굴하고, 영상 자회사 스튜디오N과 시너지 확대다. 카카오는 최근 북미 웹소설 플랫폼 ‘래디쉬’와 웹툰 플랫폼 인수를 추진 중이다. 래디쉬 인수가는 약 4000억원으로 추정된다. 월 사용자가 70만명으로 왓패드에 비해 소규모지만 높은 수익성으로 월 매출 30억원에 달하는 알짜 플랫폼이다. 또 다른 북미 웹툰 플랫폼 ‘타파스 미디어’ 지분도 40%가량 보유 중이다. 두 회사 인수기업의 면면을 보면 전략의 차이가 보인다. 왓패드는 웹소설계의 유튜브다. 아마추어 작가가 자유롭게 작품을 올리고, 독자에게 선택을 많이 받으면 히트작이 된다. 대부분 무료 작품이란 점까지, 네이버 도전만화와 비슷하다. 누구나 들어올 수 있게 판을 깔고 소비자 선택을 지켜보는 네이버의 플랫폼 전략과 닮았다. 네이버가 여기에 광고, 미리보기, IP 사업 등 그간 쌓아온 수익화 노하우를 어떻게 이식할지가 관건이다. 반면 래디쉬는 프로페셔널 작가군단이 데이터 기반으로 ‘히트작’만 골라쓴다. 창업 당시부터 카카오의 ‘기다리면 무료’ 모델을 벤치마킹했다. 인기 많은 작품일수록 연재횟수를 빠르게 늘리는 등 ‘미리보기’에 기꺼이 지갑을 여는 코어 팬덤을 구축하는 데 능하다. 자체 IP(오리지널)에 투자하고 콘텐트 값을 받는 넷플릭스와 유사하다. 양질의 지식재산권(IP) 확보를 위해 IT 업계를 중심으로 ‘IP 전쟁’이 거센 가운데, 국내 웹소설 플랫폼 ‘문피아’ 인수를 놓고 네이버, 카카오, 엔씨소프트의 3파전이 펼쳐질 전망이다. 지난 2002년 인터넷 커뮤니티로 출발한 문피아는 무협소설 콘텐츠에서 강점을 나타내고 있는 웹소설 플랫폼이다. 네이버는 문피아 인수를 위해 국내 한 사모펀드와 컨소시엄을 꾸린 상태다. 이들은 문피아를 지배하고 있는 특수목적법인(문피아투자목적회사)의 지분 확보를 추진하고 있다. 문피아의 기업가치는 3000억원을 상회하는 것으로 알려졌다. 이번 문피아 인수전에는 카카오와 엔씨소프트도 관심을 두고 있는 것으로 전해진다. 특히 엔씨소프트는 현재 문피아의 3대 주주(지분율 6%)로 콜옵션을 행사할 수 있어 강력한 인수 후보군 중 한 곳으로 꼽힌다. 엔씨소프트는 지난해 콘텐츠 자회사 클렙을 설립하고 게임 외 엔터테인먼트 부문 등 콘텐츠 사업에 도전장을 던진 상태다. 국내 콘텐츠 업계 관계자는 “엔씨소프트도 IP 비즈니스 확장을 위해 문피아 인수 희망 의지를 강력하게 드러내고 있다고 전해진다”면서도 “다만 웹 콘텐츠 사업이 약해 네이버와 카카오로 인수가 기울 것이라는 의견이 지배적이다”고 말했다. 플랫폼에 모여든 창작자와 사용자가 많으면 많을수록, 플랫폼 수익도 늘어난다는 걸 누구보다 잘 안다. 어느 쪽이든 콘텐트와 사용자가 많을수록 플랫폼 이익도 커진다. [단독] 카카오, 북미 최초웹툰 타파스 인수…美서 네이버와 격돌 - 매일경제 (mk.co.kr) 북미서 웹툰 전쟁…유튜브식 네이버, 넷플릭스식 카카오? : 네이버 뉴스 (naver.com) 웹소설 플랫폼 ‘문피아’ 잡아라…네이버·카카오·엔씨 ‘3파전’ : 네이버 뉴스 (naver.com) 스타트업 인수네이버와 카카오가 유망 스타트업을 인수해 정보기술(IT) 서비스 경쟁력을 높이고 있다. 네이버는 인재 확보를 위해 스타트업을 사들이고 있다. 인수(acquisition)와 고용(hire)의 합성어인 ‘애크하이어(acqhire)’로 불린다. 네이버는 지난해 컴퓨터 비전 스타트업 비닷두(V.DO)를 인수했다. 비닷두 출신은 네이버웹툰의 콘텐츠 경쟁력을 강화하기 위해 여러 웹툰 관련 기술을 고도화하고 있다.네이버가 2017년 인수한 AI 스타트업 컴퍼니AI도 비슷한 사례다. 컴퍼니AI는 서비스가 아닌 연구형 스타트업이다. 딥러닝 알고리즘과 기계 독해, 자연어 이해, 대화 모델 연구 등의 다양한 기술을 확보했다. 컴퍼니AI 출신 개발자들은 네이버의 AI 플랫폼인 ‘클로바’의 대화형 엔진을 개발하는 데 중요한 역할을 하고 있다. 카카오엔터프라이즈는 클라우드 기반의 라이브 스트리밍 플랫폼인 ‘카카오 i 커넥트 라이브’를 최근 내놨다. 1인 방송, 실시간 온라인 방송, 화상 회의, 웨비나, 라이브커머스까지 모든 생중계 동영상을 쉽게 유통할 수 있는 플랫폼이다. 카카오엔터프라이즈가 지난해 인수한 스타트업인 리모트몬스터의 기술을 활용했다.카카오페이는 2019년 보험 중개 판매 스타트업 인바이유도 인수했다. 인바이유는 국내외 대형 보험사와 재보험사와 제휴해 다양한 보험 상품을 온라인으로 판매했다. 카카오페이 보험 서비스의 교두보 역할을 맡았다. 네이버·카카오 新사업 질주…비결은 M&amp;A ‘스타트업 군단’ : 네이버 뉴스 (naver.com)","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EC%A3%BC%EA%B0%84%20IT%EC%A0%95%EB%A6%AC/21-04-17-Weekly_IT_News/"},{"title":"[Spring Boot] Ajax 사용하는 이유","text":"회원가입 시 Ajax를 사용하는 이유요청에 대한 응답을 HTML이 아닌 Data(JSON)로 받기 위해서클라이언트 (브라우저)는 서버에 요청을 하고, 서버는 클라이언트에게 응답한다. 클라이언트가 서버에게 화면을 요청하면, 서버가 .html로 응답하여 브라우저는 그 html 파일을 읽는다. 메인화면에서 회원가입 수행을 요청하면, 서버는 DB에 회원가입을 수행하고 완료하면 다시 메인화면으로 돌아올 것이고, 결국 html로 응답해줘야하는데… 그 클라이언트가 꼭 브라우저인 것은 아니다. 앱일 경우, html를 반환해주면 이해하지 못한다. 그래서 Data만 반환해주고, 화면을 앱안에서 자체적으로 띄운다. ➡ 브라우저를 위한 서버, 앱을 위한 서버 두개를 따로 만들어야하지만, 차라리, Data를 반환해주는 서버 하나를 만들면 되지 않을까… 서버는 브라우저/앱에게 정상이라는 Data를 반환해준다. 브라우저는 다시 서버에서 request를 보내 html파일을 반환하게 한다. 앱은 자체적으로 화면이동을 한다. 그래서 Data를 Ajax를 사용한다. 비동기 통신을 하기 위해서보통 일을 수행할 때 1, 2, 3, 4, 5, … 순서대로 실행-종료,실행-종료… 절차적으로 수행한다. 그리고 1: 화면에 그림(내장), 2: 연산, 3: 그림 다운로드(외장), 4: 그림을 그림, 5: 화면에 그림(내장) 이라는 상황일 때, 1,2번이 수행되고, 3번 다운로드하는 10초 pending동안 앱은 멈춰있을 것이다.. 10초 다운로드가 끝나면 4,5번이 수행된다. 이 결과 UX가 나빠진다. 프로그램을 사용하고 싶지 않을 듯 비동기 통신은 절차적으로 일을 수행하는데, 일의 순서에 상관없이 수행한다. 1,2 수행하고, 3번을 비동기 처리하고 4번은 3번이 수행되어야 동작할 수 있기때문에, 5번을 수행하고 있는다. 3번 다운로드하는 동안 4번은 3번을 기다리고, 5번 그림 그리기 수행 5번 수행중 3번이 완료되면 4번으로 콜백한다. 4번이 완료되면 5번 멈췄던 지점부터 다시 시작한다. 5번이 끝난 후에 3번이 완료되면 4번으로 돌아간다. ➡ 비동기라고 한다.","link":"/categories/Programming/SpringBoot/SPRINGBOOT-AJAX-21-07-21/"},{"title":"2021년 4월 24일 토요일 주간 IT 뉴스 - 클라우드 게임&quot;","text":"개요요즘 코인열풍이 불고 있다. 그 와중에 중국에서는 거대한 암호화폐 채굴장을 만들어 채굴사업을 한다는 이야기도 있다. 채굴기에 필요한 고성능의 그래픽카드가 이곳에 쓰이고, 이 때문에 고성능 게임을 위해 그래픽카드를 구매하려고하는 게이머들의 슬픈 이야기도 들리기도 한다. 내 주변에서도 이번에 컴퓨터를 새로 구매하는데 그래픽카드가 너무 비싸 망설여진다고 하는 사람이 있었다. 천장 뚫는 그래픽 카드 값에··· 클라우드 게임에 눈 돌리는 게이머게임 ‘포트나이트’ 이용자 이모(35)씨는 지난 달 그래픽 카드(GPU)를 교체하려다 비싼 가격에 깜짝 놀랐다. 지난해 60만 원 가량이었던 엔비디아의 RTX 3070이 160만 원대까지 올랐기 때문이다. 울며 겨자먹기로 구매하려고 해도 물건이 없어 어려움을 겪던 차에 클라우드 플랫폼 ‘지포스 나우’를 통해 게임을 즐길 수 있다는 이야기를 듣고 클라우드 게임으로 갈아탔다. 전세계적으로 반도체 품귀 현상이 장기화되고 가상화폐 채굴 열풍으로 인한 사재기가 벌어지면서 PC의 성능을 좌우하는 그래픽 카드 칩셋(GPU) 가격이 천정부지로 올라가고 있다. 이에 등골이 휜 게임 이용자들이 기기의 성능이 낮아도 얼마든지 게임을 즐길 수 있는 클라우드 게임 시장으로 눈길을 돌리고 있다. 22일 업계에 따르면 올 들어 그래픽 카드 칩셋 가격이 매달 평균 20%이상 상승하며 게임 이용자들을 곤혹스럽게 하고 있다. 용량이 큰 대규모 다중접속역할게임(MMORPG)을 끊김 없이 즐기려면 고성능 그래픽카드를 필요한데 가격이 상한선 없이 올라가고 있기 때문이다. 대표적인 칩셋 공급사인 엔비디아의 RTX3080의 경우 지난 2월에만 해도 155만 원에 구매할 수 있었지만 한 달만인 지난 달 둘째주에는 220만 원으로 41%가 뛰었다. RTX3090은 같은 기간 252만 원에서 300만 원대로 올라갔다. 문제는 이 같은 돈 주고도 GPU를 구하기가 힘들다는 것이다. 가상화폐 채굴 열풍으로 대규모 GPU 사재기가 벌어졌기 때문이다. 비트코인 채굴 업체인 라이엇 블록체인은 이달 초 채굴기 4만 2,000대를 구매하는 계약을 체결했다고 밝혔다. 다나와 관계자는 “암호화폐 채굴 열풍으로 최근 그래픽카드의 수요·공급에 불균형이 커졌다”며 “고사양 그래픽 카드를 구하기 힘들다보니 게임 이용자들 사이에서는 상대적으로 가격 등락폭이 적은 GTX 1660 등 이전 시리즈 칩셋 인기가 높아지고 있다”고 설명했다. 고사양 그래픽 카드를 구하기 힘들어진 유저들은 발 빠르게 클라우드 게임으로 이동하고 있다. 클라우드 게임은 플랫폼 자체에서 PC게임을 이용할 수 있어 기기의 사양이나 종류에 상관 없이 고사양 그래픽을 구현할 수 있다. 게임 서버만 마련해 두면 시간·장소·기기에 상관없이 게임을 끊김 없이 즐길 수 있다. 특히 몇 시간씩 걸리는 게임 다운로드나 수시로 진행하는 업데이트 등을 사용자가 직접 하지 않아도 언제든 이용할 수 있다. 실제 클라우드 게임 시장은 빠르게 성장하고 있다. 글로벌 시장 조사 업체 뉴주는 클라우드 게임 시장이 올해 14억 달러(1조5,634억 원), 오는 2023년 51억4,000만 달러(5조7,413억 원)로 커질 것으로 내다봤다. 업계 관계자는 “그래픽 카드를 주기적으로 교체해줘야 하는 부담에 클라우드 게임으로 넘어오는 이용자가 꾸준히 늘어나고 있다”며 “최근에는 클라우드 게임의 지연(Latency) 문제가 획기적으로 개선되면서 그 흐름이 더 빨라지고 있다”고 전했다. ——-이하 생략 지포스나우로 클라우드 게임을 할 수 있다라는 소식은 꽤 오래전부터 알고 있었다. 하지만 그 땐 사람들이 얼마나 사용할까? 라고 생각만 했다. 클라우드 컴퓨팅 수업을 들으면서 fat/thin client 관련된 내용에서 서버단에서 모든 기능이 돌아가고 클라이언트에는 그냥 가볍게 볼 수 있는 개념을 듣고, 클라우드 게임도 이런 것이겠구나라고 생각했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EC%A3%BC%EA%B0%84%20IT%EC%A0%95%EB%A6%AC/21-04-24-Weekly_IT_News/"},{"title":"[Spring Boot] 블로그 프로젝트 기본 세팅하기","text":"기본 셋팅프로그램Windows 10 ----------------- IntelliJ : 코드작성 Docker - MySQL MySQL Workbench Postman 의존성 추가springboot devtools lombok spring data JPA mysql driver spring security spring web ​ OAuth2 client는 직접구현해보기 1234567891011121314implementation 'org.springframework.boot:spring-boot-starter-data-jpa'implementation 'org.springframework.boot:spring-boot-starter-security'implementation 'org.springframework.boot:spring-boot-starter-web'compileOnly 'org.projectlombok:lombok'developmentOnly 'org.springframework.boot:spring-boot-devtools'runtimeOnly 'mysql:mysql-connector-java'annotationProcessor 'org.projectlombok:lombok'testImplementation 'org.springframework.boot:spring-boot-starter-test'testImplementation 'org.springframework.security:spring-security-test'/** 추가 라이브러리 **/implementation &quot;org.springframework.security:spring-security-taglibs&quot; // 시큐리티 태그 라이브러리implementation &quot;org.apache.tomcat.embed:tomcat-embed-jasper&quot; // JSP 템플릿 엔진implementation 'javax.servlet:jstl' // JSTL","link":"/categories/Programming/SpringBoot/SPRINGBOOT-BlogProject1-21-07-09/"},{"title":"[Spring Boot] 데이터베이스 격리수준: Database Isolation Level","text":"트랜잭션일이 처리되기 위한 가장 작은 단위 트랜잭션들이 모여 하나의 트랜잭션을 이룰 수 있고, 서비스가 된다. → 하나의 작업을 수행하기 위해 필요한 데이터베이스의 연산들을 모아놓은 것 DB 격리수준 오라클 기본 격리수준 (Read Committed) READ COMMIT T1: 트랜잭션 시작 → Update문 (테이블 내의 정보 수정 - 222.Busan -&gt; 222.Jeju) T2: T1이 Update하는 동안 그 부분을 Select를 하면 T2는 수정되기 전의 정보를 Select한다. 222.Busan (Undo영역 수정 전) ------------------------- T1: Update한 것을 Commit (Undo영역이 수정 됨) T2: T1이 commit하기 전에는 수정하기 전 정보를 Select하게 되고, Commit 이후에 Select하면 수정 된 정보를 볼 수 있다. 222.Jeju (Undo영역 수정 됨) READ COMMIT 정합성 문제 T2는 트랜잭션을 실행하지않고, Select만 한다. Busan이 나오다가 갑자기 Jeju가 나와버렸다. 만약에, T2입장에서 T1과 비슷한 시기에 트랜잭션을 실행하고, Select를 계속 한다. 그리고 마지막에 그 Select한 결과들을 모아 Insert연산을 하고 Commit을 한다면... 중간에 데이터가 변경되어 결과가 예상과 달라져버리면 문제가 된다. 이런 문제는 금전적인 처리에서 주로 발생한다. 총 3번 각각 만원씩 Select를 할려고 했는데, 마지막 Select에서 2만원이 나오면, 예상은 3만원 Insert를 하려고 했는데, 4만원이 Insert - Commit이 되어버린다. → 정합성이 깨진다 = 부정합, 똑같은 Select에서 다른 것이 나왔을 때➡ PHANTOM READ(데이터가 보였다 안보였다), 아에 결과가 없을 때이를 해결하기 위해 REPEATABLE READ방식을 사용해야한다. MySQL 기본 격리수준 (Repeatable Read 이상) –&gt; 부정합 발생 X transaction Id부여 T2가 먼저 Transaction 시작(Id=10) 222를 Select하면 Busan T1이 Transaction 시작 (Id=12) 222.Busan --&gt; Jeju upate commit 하지만 T2입장에서는 아직 자신의 Transaction이 종료되지 않았기 때문에, 항상 동일한 결과를 보여준다. 그래서 시작했을 때는 Busan이 나왔으므로, 끝까지 Busan이 나온다. 자신의 Transaction Id보다 작은 Undo로그를 보고 select한다. Spring에서는CRUDC(Insert), U(Update), D(Delete) --&gt; commit이 필요하므로 @Transactional 붙인다. R(Select)는 보통 붙이지 않는데, 정합성을 위해 꼭 @Transactional을 붙여서 트랜잭션을 타게 해준다.","link":"/categories/Programming/SpringBoot/SPRINGBOOT-DB-Isolation-21-07-22/"},{"title":"[Spring Boot] 데이터베이스 Select 하는 법과 에러체크","text":"데이터베이스의 데이터를 Select할 때 잘못 된 인수가 들어가면 어떻게 해야할까 데이터베이스 Select하기User table을 select하기에 앞서, UserRepository라는 인터페이스 파일을 새로 만들고, 그 UserRepository는 JpaRepository를 상속하고 있다. 123// 자동으로 bean등록이 된다. --&gt; @Repository 생략가능public interface UserRepository extends JpaRepository&lt;User, Integer&gt; {} 그리고 select 기능을 넣어줄 클래스파일에 DI를 해주고, User의 객체를 return 받을 수 있게, 메소드를 받들어주고, 주소를 넣어준다. 1234567891011121314@RestControllerpublic class DummyControllerTest { @Autowired // 의존성주입(DI) private UserRepository userRepository; // {id} 주소로 파라미터를 전달 받을 수 있음. // http://localhost:8000/blog/dummy/user/3 @GetMapping(&quot;/dummy/user/{id}&quot;) public User detail(@PathVariable int id) { User user = userRepository.findById(id) ... return user; } 이 때, 만약 id부분에 DB에 없는 값이 들어가면 어떻게 해야할까… 라는 생각이 들 수 있다. 이 경우, user가 null이 되고, 결국 null값을 반환해주므로 프로그램에 문제가 생길 수 있다. 그래서 findById() 는 Optional로 User객체를 감싸서 반환해준다. 이후 우리가 null인지 아닌지 판단해서 사용하면 된다. findById().orElseGet()id값이 유효하면 그대로 user를 반환해주면 되지만, 유효하지 않을 경우 orElseGet을 타서 user에 User()빈 객체를 넣어줄 것이다. 이건 그냥 null과 다르다 orElseGet()에 넣을 수 있는 파라미터는 Supplier의 타입(인터페이스)이고, 이 타입의 Generic부분에 ?가 되어있는데 익명 객체를 넣어준다. 그리고 함수 get을 Override 해준다. (인터페이스는 new할 수 없기 때문에, 익명 클래스를 만들어줘야한다. ) 1234567User user = userRepository.findById(id).orElseGet(new Supplier&lt;User&gt;() { // 데이터베이스에 값이 없는 경우 orElseGet을 타서 user에서 User()...빈 객체를 넣어줌,null이 아님 @Override public User get() { return new User(); }}); findById().orElseThrow()하지만 findByID()에서 만약 id가 null일 경우 IllegalArgumentException 를 throw하라고 적혀있다. 123456User user = userRepository.findById(id).orElseThrow(new Supplier&lt;IllegalArgumentException&gt;() { @Override public IllegalArgumentException get() { return new IllegalArgumentException(&quot;해당 유저는 없습니다. id: &quot; + id); }}); or 람다식을 이용해서…123User user = userRepository.findById(id).orElseThrow(()-&gt;{ return new IllegalArgumentException(&quot;해당 유저는 없습니다. id: &quot; + id);}); 결과 Spring에는 AOP라는 기능이 있다. 만약 Illegal이 있을경우, 에러를 가로채서 에러페이지로 넘어갈 수 있게 만들 수 있을 것이다. 추가요청: 웹브라우저 user 객체: 자바 오브젝트 @RestController: html파일이 아닌 data를 리턴해주는 controller 이 경우 웹브라우저가 이해할 수 있는 데이터 (Json)으로 변환해줘야하는데, SpringBoot는 MessageConter가 자바 오브젝트가 리턴될 시 자동으로 Jackson라이브러리를 호출해서 user 오브젝트를 Json으로 변환해서 브라우저에게 전달한다.","link":"/categories/Programming/SpringBoot/SPRINGBOOT-DB-Select-21-07-18/"},{"title":"2021년 4월 10일 토요일 주간 IT 뉴스 - LG전자 MC사업본부 &quot;","text":"개요이번 한 주 IT뉴스 정리의 주제는 LG전자의 모바일커뮤니케이션 사업부의 철수이다. IT뉴스] 매일 30분 IT 뉴스 21-04-04뉴스 원문 LG전자 스마트폰 사업 철수LG전자가 스마트폰 사업을 접는다는 소식은 지난 1월말에 공식화했다. 올해 1월 롤러블폰이 CES2021에 등장하면서 많은 기대를 했지만, 지난 1월 20일 권봉석 LG전자 사장은 “모바일 사업 관련해 현재·미래의 경쟁력을 냉정하게 판단해 최선의 선택을 해야 할 시점에 이르렀다”면서 “현재 모든 가능성을 열어두고 사업 운영 방향을 면밀히 검토하고 있다”고 사업 철수를 공식화했다. 초기만해도 매각이냐 철수냐 많은 말이 있었지만, 결국 사업 철수로 가닥이 잡혔고, 4월 5일 서울 여의도 본사에서 이사회를 열고 휴대전화 사업을 담당하는 MC사업부의 생산 및 판매를 종료하기로 결정했다고 공식 발표했다. 하지만, 사업은 없어져도 사람은 남는 법, 3700여명 사업부 인력을 ‘어떻게, 잘’ 배치할 것인지는 또 다른 중요한 숙제이다. 사업의 ‘완전 철수’가 기정사실화된 가운데, 3700여명에 달하는 인력 재배치 문제와 핵심 기술과 특허권의 활용 방향성은 공개된 바 없다. LG그룹 계열사 분위기도 어수선합니다. 핵심 개발 업무를 제외한 이들은 업무가 겹칠 수밖에 없기 때문입니다. 업계 한 관계자는 “LG전자 MC사업본부 내 인력 상당수가 개발자가 아닌 사무직이라고 들었다. 기존 계열사 임직원들 역시 인력 대이동과 관련 걱정이 많다”고 토로합니다. 왜?과거 ‘프라다폰’, ‘초콜릿폰’, ‘샤인폰’ 등 블랙라벨 시리즈를 성공시킨 LG전자의 휴대폰 사업이 침체된 데는 2010년으로 접어들 무렵 경영진의 사업 판단 오류가 주효했습니다. 애플이 2007년 iOS 기반의 아이폰을 출시하며 스마트폰 혁명을 주도할 때도 LG전자는 과거 피처폰의 영광에 안주했습니다. 스트래티지애널리틱스(SA)에 따르면 작년 3분기 말 기준 국내 삼성전자 시장점유율(MS)은 70%를 넘은 반면 LG전자는 9%대로 감소했습니다. 이후공식발표 이후 LG전자의 입장은 “휴대전화 사업을 종료하더라도 모바일 기술의 연구개발은 지속한다. 6G 이동통신, 카메라, 소프트웨어 등 핵심 모바일 기술에 집중하겠다”라고 밝혔다. MC사업부 직원 또한 LG 계열회사 등으로 재배치될 계획이다라고 밝히기만 했다. 이외에는 LG전자가 휴대폰 사업을 철수키로 결정하면서 LG 임직원들의 ‘아이폰’ 갈아타기에 속도가 붙고 있다고 한다. 지금까진 애사심 차원에서 ‘LG폰’을 썼지만 이젠 LG 계열사의 주요 고객사인 애플이 생산하는 ‘아이폰’을 쓰는 것이 회사에 도움이 될 것이란 판단에서다. 그동안 업계 관계자는 “임직원들도 LG전자 스마트폰이 좋다기 보다 내부 분위기상 어쩔 수 없이 썼다는 얘기들이 많았다”며 “사업 철수가 확정된 후에는 한 LG 계열사에서 올 들어 팀원 절반 가까이가 ‘아이폰’으로 교체했다는 말이 들릴 정도로 ‘아이폰’을 선호하는 분위기가 급속도로 형성됐다”고 말했다. LG전자가 스마트폰 사업을 접는다는 소식을 듣고 참 여러생각이 들었다. 국내에서 먼저 사업을 접었던 팬택 스카이도 갑자기 생각났다. 10년전만해도 우리나라에는 삼성,LG, 팬택(스카이) 피쳐폰, 스마트폰을 사용하는 사람들이 많았다. 그리고 내 첫번째 스마트폰은 팬택의 제품이였고, 그와 동시에 팬택이 망해가는 것을 같이 봤다. 그 이후 스마트폰은 안드로이드와 iOS 사이에서 나는 안드로이드를 선택했고, 삼성 스마트폰을 구매했다. LG제품 또한 다양하고 신기한 것들이 많았지만, 그 기술에 완벽함이 삼성 스마트폰에 비해 떨어져보였다. 그 땐 잘 몰랐지만, 그냥 그렇게 보였다. 하지만 국내 시장 점유율 뿐만 아니라 세계 시장 점유율도 어느정도 있었던 것 같았다. 중국 기업들이 들어오기전까지…뭐 어쨋든…LG는 세계 최초의 타이틀은 꽤 있었지만, 뭔가 자꾸 부족했다. 최근에 나온 윙… 새로운 폼펙터.. 신기했다. 하지만 그게 다였다. 그렇게 LG전자는 사업을 접기로 했고, LG스마트폰을 사용한 적은 없지만 아쉬웠다. 이젠 국내에서 메이저급으로 스마트폰을 생산하던 기업들 중 삼성만 남았기 때문이다. 그리고 피쳐폰시장에서 국내에서 압도적이었던 그 사업부가 망한게…핀란드의 노키아의 길을 밟는구나.. 기업을 유지하고 성장하게 하는 건 경영진의 혜안일 수도 있지만, 그곳에서 일하는 직원들이 있기에 가능한 것이지만, 그 기업의 향후 존폐여부를 결정짓는 것은 경영진의 (이하생략) 어느것이든 영원한 승자는 없다. 현실에 안주하지말고 계속 움직이자.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EC%A3%BC%EA%B0%84%20IT%EC%A0%95%EB%A6%AC/21-04-10-Weekly_IT_News/"},{"title":"2021년 3월 20일 토요일 주간 IT 뉴스 - 넷플릭스와 OTT","text":"넷플릭스는…?한 주간 넷플리스와 관련 된 OTT에 대한 많은 기사들을 보았다. 가장 기억에 남은 기사는 넷플릭스의 비밀번호 공유를 통한 ‘몰래시청’ 단속에 관한 기사였고, 다른 기사들과 관련하여 넷플릭스의 상황과 생각을 내 입맛대로 정리해보았다. 넷플릭스 콘텐츠 무단시청 방지 기능 적용과 평가14일 CNN 등 외신에 따르면 넷플릭스는 최근 콘텐츠 무단시청 방지 기능의 시험 적용에 착수했다. 비밀번호 공유가 의심될 경우 해당 계정 소유자의 문자 메시지나 이메일로 코드를 전송해 본인 확인을 요청하는 기능을테스트하는 것이다. 본인 확인이 이뤄지지 않으면 접속이 중단된다. 즉 유료 가입자의 계정 비밀번호 하나를 여려 명이 공유해 사용하는 것을 막겠다는 취지이다. 이에 일부 사용자들은 ‘형제도 같이 살지 않으면 가족이 아닌 건가, 이참에 ‘디즈니+ 나 아마존 프라임으로옮기겠다’는 반응을 보이며 반발이 거세지고 있다. 기사 출처: “이참에 디즈니+로 갈래”…’넷플릭스’에 뿔난 전세계 이용자들 넷플릭스 과거 가격인상 때는 어땠나?과거 시장을 독주하고 있는 넷플릭스는 가격을 인상을 하여도, 다른 OTT에 비해 구독해지율이 낮았으며, 여론의 큰 반응이 없었다. 이는 넷플릭스가 코로나19로 침체된 경기 속에서 가격 저항에 대한 우려에도 불구하고가격인상을 단행한 데에는 기존 구독자들은 1~2달러 정도로 자신들에게 등돌리지 않을 것이라는 자신감이 자리하고 있었기 때문으로 추측한다. 구독 해지율은 낮지만, (현 상황) 사람들은 계정을 공유함에서 볼 수 있는 것은 멤버십 가입 비용이 혼자 사용하기에 비효율적이거나 비싸다는 것이다. 넷플릭스 측은 “구독자에게 더 좋은 콘텐츠를 제공하기 위해 구독료 인상을 결정했다”고 밝혔지만, 이후 넷플릭스가 디즈니+와 아마존프라임과 같은 OTT사업자들의 추격에 초조해지자 지나친 탐욕을 부리는 것이고이용자 규제 강화조치는 오히려 그들을 궁지로 내몰 고 있는 것이라는 합리적인 추측을 할 수 있다. 이후 넷플릭스는 과연?국내 OTT시장 점유율은 넷플릭스가 1위이며, 넷플릭스 멤버십 가입하는 연령층 또한 전 연령층으로 확대되는 등 사실상 국내 OTT시장을 석권한 듯 보인다. 하지만 이는 대한민국에 한정되어 있으며, 글로벌시장은 입지가다소 좁아지고 있다는 평을 받고 있다. 기사 출처: 국내 OTT 시장 접수한 넷플릭스, 글로벌 사정은 다르다? 이는 글로벌시장에 미디어 공룡기업이라 평가되는 디즈니가 ‘디즈니+’로 스트리밍 시장에 진출하였기 때문이다. 디즈니는 오랜 업력으로 전세계인의 눈과 귀를 사로잡은 IP(지적재산권)을 다수 보유하고 있지만, 넷플리스는그렇지 못하다. 또한 디즈니의 대부분의 콘텐츠는 이미 아이부터 어른까지 전 연련층의 사랑을 받고 있으며 검증되었지만, 넷플릭스의 대부분의 인기콘텐츠는 ‘청소년관람불가’등급으로 대조적이다. 과연 디즈니+가 한국시장에 들어오면 넷플릭스의 점유율은 어떻게 될까. 한국에서 많은 사랑을 받는 마블시리즈 및 디즈니에 속한 애니메이션, 영화 국내OTT는 물론 넷플릭스에서 볼 수 없었다.하지만 마블, 픽사, 폭스 등을 소유한 디즈니의 OTT서비스가 국내에서 정식으로 런칭되면 시장의 판이 뒤엎어질 것 같다. 이런 상황 속 넷플릭스는 아직도 스스로 자신감에 가득차 공격적인 행보를 이어가고 있는 것으로 보인다.앞으로 소비자의 선택지는 점점 늘어날 것이고, 자신에게 맞는 더 합리적인 서비스를 찾을 것이다.현재 넷플릭스처럼 말도 안되게 가격인상 그리고 이용자를 규제하는 것은 자신의 지위와 권력을 이용하여 횡포를 부리는 것으로 생각이 든다.내가 넷플릭스 입장에서 봤을 때… 아니 서비스를 제공하는 입장에서 계정을 공유해서 여려명이 시청하는 것은 물론 수익이나 데이터수집 측면이든 뭐든 거슬릴 것이다.하지만 방법이 틀린 것 같다. 내가 생각하는 올바른 방법 혹은 해결방안은 4학년1학기 기술경영 팀프로젝트를 통해 다룰 예정이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EC%A3%BC%EA%B0%84%20IT%EC%A0%95%EB%A6%AC/21-03-20-Weekly_IT_News/"},{"title":"[Spring Boot] IntelliJ에서 Live Reload 설정하기","text":"Live Reload Live Reload라는 기능은 Spring Boot로 개발하면서 자바 소스를 수정하고 저장하면 자동으로 재시작을 해주는 기능이다. 1. spring-boot-devtools 의존성 추가하기1developmentOnly 'org.springframework.boot:spring-boot-devtools' 2. application.yml에 추가하기123456789spring: devtools: livereload: # view단이 바뀌었을 때 자동으로 리로드 설정 enabled: true restart: # 컨트롤러,모델단(classpath에 있는 파일)이 바뀌었을 때 프로젝트 재시작 설정 enabled: false freemarker: cache: false 3. Intelli J 설정 수정하기Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; 에 Build project automatically 활성화 4. registry 수정하기Find Action (Ctrl + Shift + A) –&gt; “registry” 검색 –&gt; compiler.automake.allow.when.app.running Value 체크","link":"/categories/Programming/SpringBoot/SPRINGBOOT-IntelliJ-21-07-16/"},{"title":"[Spring Boot] IntelliJ로 Spring Boot 시작하기","text":"인텔리제이 설치하기 설치페이지에서 IntelliJ 유료버전인 Ultimate와 무료버전인 Community 두 가지 버전 중 선택하여 설치한다.유료버전은 학생 인증을 통하여 무료로 사용할 수 있다. 다음글을 참고하자 인텔리제이에서 프로젝트 생성하기 New Project 버튼을 클릭한다. 프로젝트 유형은 Gradle을 선택한다.이름과 디렉토리 위치를 지정하고 GroupId와 ArtifactId를 설정한다. ArtifactId는 프로젝트 이름이 된다. Spring Boot 버전을 선택한다.초기에 프로젝트를 생성한 후 셋팅하고 싶은 의존성(Dependencies)을 선택한다. Spring Boot DevTools, Spring Web, Mustache Finish를 선택하면, 아래와 같이 프로젝트가 생성된다. 스프링 부트 프로젝트 설명 plugins에서 io.spring.dependency-management 플러그인은 스프링 부트의 의존성들을 관리해 주는 플러그인이다. repositories는 각종 의존성 들을 어떤 원격저장소에서 받을지 정한다. 기본적으로 mavenCentral을 많이 사용하지만, 최근에는 라이브러리 업로드 난이도 때문에 jcenter도 많이 사용한다. mavenCentral은 이전부터 많이 사용하는 저장소지만, 본인이 만든 라이브러리를 업로드하기 위해서 많은 과정과 설정이 필요하기 때문에 개발자들이 직접 만든 라이브러리의 공유가 점점 안 되는 상황이 발생했다. 최근에 나온 jcenter는 이런 문제점을 개선하여 라이브러리 업로드를 간단하게 하였다. 또한, 여기서 한 걸음 더 나아가 jcenter에 라이브러리를 업로드하면 mavenCentral에도 업로드될 수 있도록 자동화를 할 수 있다. 그래서 개발자들의 라이브러리가 점점 jcenter로 이동하고 있다. dependencies는 프로젝트 개발에 필요한 의존성들을 선언하는 곳이다.아까 설정한 라이브러리가 선언되어있다. 스프링 부트 프로젝트 시작하기 프로젝트 폴더 내 src&gt;main&gt;java&gt;com.***.*** 안에 가장 기본이 되는 .java파일이 있는데 이를 실행한다. 위와 같이 정상적으로 실행되었다면, 웹 브라우저에서 localhost:8080으로 접속한다. 참고 추후 작성 글…인텔리제이 학생인증, vscode로 실행하기, maven/gradle 차이점, live reload사용하기, mustache","link":"/categories/Programming/SpringBoot/SPRINGBOOT-IntelliJ-21-06-23/"},{"title":"[Spring Boot] 데이터베이스 Update 하는 법","text":"데이터베이스 Update하기웹 브라우저에서 회원 수정을 하는 경우를 생각하며, @PutMapping을 이용해서 주소를 만들어줬다. 이때 적은 주소는 @GetMapping의 주소와 동일한데, 스프링부트에서는 알아서 Get, Put을 구별해준다. 첫 번째 방법 (Save함수 사용)주소에서 id를 받아온다. 이 id는 데이터베이스에 저장 된 id값을 불러오기 위함이다. 그리고 @ReqeustBody를 이용하여 Json 데이터를 요청하여, 이를 JavaObject로 변환한다. SpringBoot에서는 MessageConverter가 Jackson 라이브러리를 사용하여 자동적으로 변환해준다. 12345678910111213141516// email, password@PutMapping(&quot;/dummy/user/{id}&quot;)public User upadteUser(@PathVariable int id, @RequestBody User requestUser) { // Json 데이터를 요청 =&gt; Java Object(MessageConverter의 Jackson라이브러리로 변환해서 받음 User user = userRepository.findById(id).orElseThrow(() -&gt; { return new IllegalArgumentException(&quot;수정에 실패하였습니다.&quot;); }); user.setPassword(requestUser.getPassword()); user.setEmail(requestUser.getEmail()); // save함수는 id를 전달하지 않으면 insert를 해주고, // save함수는 id를 전달하면 해당 id에 대한 데이터가 있으면 update를 해주고 // save함수는 id를 전달하면 해당 id에 대한 데이터가 없으면 insert를 한다. userRepository.save(user); return null;} Select 때와 마찬가지로, 잘못 된 (없는) id값을 받았을 때를 방지하기 위해 IllegalArgumentException을 throw 할 수 있도록 한다. 정상적인 user객체에 수정하고자 했던 데이터(password와 email)을 set으로 수정해준다. 그리고 save함수를 이용하여 update해준다. Save 함수, save 함수를 사용할 때id를 전달하지 않으면 insert를 해주고, id를 전달하고, 해당 id에 대한 데이터가 있으면 update를 해준다. id를 전달하지만, 해당 id에 대한 데이터가 없으면 insert를 해준다. 두 번째 방법@Transactional라는 annotaion을 사용해보자. 1234567891011121314// email, password@Transactional@PutMapping(&quot;/dummy/user/{id}&quot;)public User upadteUser(@PathVariable int id, @RequestBody User requestUser) { // Json 데이터를 요청 =&gt; Java Object(MessageConverter의 Jackson라이브러리로) 변환해서 받음 User user = userRepository.findById(id).orElseThrow(() -&gt; { return new IllegalArgumentException(&quot;수정에 실패하였습니다.&quot;); }); user.setPassword(requestUser.getPassword()); user.setEmail(requestUser.getEmail()); // 더티체킹 return user;} 첫 번째 방법과 크게 다른 것은 없지만, @Transactional을 이용하면, Save함수를 사용하지 않아도 된다. 이를 Dirty Checking (더티체킹) 이라고 한다. updateUser라는 함수가 실행될 때, Transaction이 실행되고, return이 될때 Transaction이 자동으로 종료되며, 자동 commit이 된다. 영속성 컨텍스트와 더티체킹에 대해서 공부해보자! 영속성 컨텍스트","link":"/categories/Programming/SpringBoot/SPRINGBOOT-DB-Update-21-07-18/"},{"title":"[Spring Boot] JPA 즉시 로딩과 지연 로딩(FetchType.EAGER or LAZY)","text":"블로그 프로젝트 진행 중 FetchType.LAZY와 EAGER이란 것이 나왔다. 하나의 게시물을 눌렀을 때, 화면에 필수적으로 나타나야 하는 것은 작성자 제목 내용 위 3가지가 있었고 있었고, 댓글은 바로 보여지는 경우와 접혀있다가 눌렀을 때 보이는 경우로 나눌 수 있었다. JPA의 기본 패치 전략- @ManyToOne, @OneToOne: 즉시로딩(FetchType.EAGER) - @OneToMany, @ManyToMany : 지연로딩(FetchType.LAZY) JPA의 기본 패치 전략으로 인해 ManyToOne은 EAGER, OneToMany는 LAZY로 되어있다. 123456789101112131415161718192021222324252627public class Board { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) // auto_increment private int id; @Column(nullable = false, length = 100) private String title; @Lob // 대용량 데이터 private String content; // 섬머노트 라이브러리 &lt;html&gt;태그가 섞여서 디자인이 됨. @ColumnDefault(&quot;0&quot;) private int count; // 조회수 @ManyToOne(fetch = FetchType.EAGER) // Many = Board, One = User ==&gt; 한명의 유저는 여러개의 보드를 쓸 수 있다. @JoinColumn(name = &quot;userId&quot;) private User user; // DB는 object를 저장할 수 없어서 Foreign key를 사용하지만, 자바는 오브젝트를 저장할 수 있다. @OneToMany(mappedBy = &quot;board&quot;, fetch = FetchType.LAZY) // 하나의 게시물은 여러개의 답변을 가질 수 있다. // mappedBy 연관관계의 주인이 아니다. (FK가 아니다) DB에 컬럼 생성X private List&lt;Reply&gt; reply; @CreationTimestamp private Timestamp createDate;} 1. 댓글이 바로 보이는 경우즉시로딩 fetch = FetchType.EAGER을 사용하면 된다. 2. 댓글을 접어놓았을 경우지연로딩 fetch = FetchType.LAZY를 사용하면 된다. 나는 댓글을 바로 Load할 것이기 때문에 답변 부분의 OneToMany JPA의 기본패치 전략 LAZY를 즉시로딩 EAGER로 바꿔줄 것이다. 123@OneToMany(mappedBy = &quot;board&quot;, fetch = FetchType.EAGER) // 하나의 게시물은 여러개의 답변을 가질 수 있다.// mappedBy 연관관계의 주인이 아니다. (FK가 아니다) DB에 컬럼 생성Xprivate List&lt;Reply&gt; reply;","link":"/categories/Programming/SpringBoot/SPRINGBOOT-JPA-21-07-16/"},{"title":"[Spring Boot] 스프링부트 기초개념-스프링이란","text":"","link":"/categories/Programming/SpringBoot/SPRINGBOOT-Study1-21-06-29/"},{"title":"[Spring Boot] JAVA 오버로딩과 오버라이딩","text":"자바의 Overloading &amp; Overriding자바에서 다형성을 지원하는 방법으로 메서드를 오버로딩, 오버라이딩을 할 수 있다. 오버로딩(Overloading): 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 것을 의미한다. 리턴값만을 다르게 갖게 작성할 수 없다. =&gt; 오버로딩은 기존에 없던 새로운 메서드를 정의하는 것 오버라이딩(Overriding): 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용 하는 것을 의미한다. 상위클래스의 메서드를 하위 클래스에서 재정의하는 것이다. 메서드의 이름, 파라미터의 갯수, 타입이 동일해야 하며, 주로 상위 클래스의 동작을 상속받은 하위 클래스에서 변경하기 위해 사용된다. =&gt; 오버라이딩은 상속 받은 메서드의 내용만 변경하는 것","link":"/categories/Programming/SpringBoot/SPRINGBOOT-JAVA-Override-21-07-19/"},{"title":"[Spring Boot] 스프링부트 기초개념-JPA란","text":"","link":"/categories/Programming/SpringBoot/SPRINGBOOT-Study2-21-07-27/"},{"title":"[Spring Boot] 스프링부트 기초개념-Spring의 동작원리1","text":"","link":"/categories/Programming/SpringBoot/SPRINGBOOT-Study3-21-07-28/"},{"title":"2021년 3월 8일 월요일 IT뉴스","text":"1. 네이버 후불결제 ‘고작 30만원’에 신용카드사 긴장한 까닭네이버 후불결제 ‘고작 30만원’에 신용카드사 긴장한 까닭 네이버는 4월부터 네이버페이 포인트 등으로 제품을 구매할 때 부족한 현금은 후불 형식으로 상환하도록 할 수 있게 됐으며, 이를 네이버파이낸셜의 금융·재테크 서비스로도 이어붙일 수도 있다. 금융권 관계자는 “머지않아 네이버페이의 한도가 늘어날 것이기 때문에 기존 카드사와의 차별성은 사라졌다”며 “카드사들은 여신전문금융업법이 족쇄처럼 붙어 마케팅, 가맹점 수수료율, 여신한도 등 규제를 받아 신규 사업을 할 수 없지만 핀테크 회사들은 자유롭게 활동하고 있다”고 지적했다. 2. ‘갤럭시워치4’ 바늘 없이 혈당 측정한다‘갤럭시워치4’ 바늘 없이 혈당 측정한다 혈압·심전도·산소포화도에 이어 혈당 측정 기능을 탑재한 삼성전자 차기 스마트워치가 2분기 중 출시될 것이란 관측이 나왔다. 앞서 삼성전자는 미국 매사추세츠공대(MIT) 연구팀과 공동으로 라만 분광법에 기반을 둔 비침습 혈당 측정 기술 연구 결과를 국제 학술지 ‘사이언스 어드밴시스’에 게재한 바 있다. 라만 분광법은 레이저 빛이 특정 물질에 조사돼 산란할 때 물질 분자의 고유 진동에 의해 나오는 파장을 이용하는 분석법이다. 3. ‘무료 SW 다운로드 하려다’…악성코드·프로그램 ‘주의’‘무료 SW 다운로드 하려다’…악성코드·프로그램 ‘주의’ 안랩은 개발 SW 불법 설치파일로 사용자를 유도해 악성코드와 PUP 파일을 동시 유포하는 사례를 발견했다며, 사용자가 해당 파일을 내려받아 실행하면 프로그램 설치 창이 나타나고 사용자가 ‘다운로드하고 저장’을 누르면 크랙 파일과 함께 악성코드와 ‘가비지 클리너(Garbage Cleaner)’라는 PUP 프로그램이 함께 설치된다. 이번 공격으로 설치된 악성코드는 감염 PC 내 사용자 계정정보를 탈취해 공격자에게 전송한다. 함께 설치된 가비지 클리너는 사용자 PC의 임시파일을 삭제하는 도구로 유료 라이선스 구입을 지속 유도한다. 4. &lt; ICT &gt;구르다 멈춘 韓 롤러블폰… ‘최초’ 타이틀 中에 뺏길라&lt; ICT &gt;구르다 멈춘 韓 롤러블폰… ‘최초’ 타이틀 中에 뺏길라 기술력에서 앞서가던 LG전자가 스마트폰 사업 철수 가능성으로 세계 최초 ‘롤러블(Rollable·돌돌 말리는)폰’ 출시 타이틀이 중국 업체에 넘어갈 가능성이 갈수록 커지고 있다. 삼성전자의 롤러블폰 출시 가능성도 속속 제기되지만, 실제 상용화까지는 적지 않은 시간이 소요될 전망이며, 삼성전자는 ‘최초’ 타이틀에 집착하기보다는 당분간은 상대적 우위를 점하고 있는 폴더블폰 시장에 더 집중한다는 방침이다. 5. 상장 앞둔 ‘야놀자’ 창업자, 전 직원에 주식 천만원어치씩 쏜다(종합)상장 앞둔 ‘야놀자’ 창업자, 전 직원에 주식 천만원어치씩 쏜다(종합) 글로벌 여가 플랫폼 기업인 야놀자의 두 창업자가 전 직원에 일괄적으로 각 1000만원어치의 주식을 쏘기로 했다. 올해 상장을 앞두고 기업 가치평가가 상승에 대한 기대감이 높은 가운데 직원들을 격려하는 것은 물론 성장의 과실을 장기적으로 나누기 위한 차원이라는 설명이다. 6. 국민의힘 과방위 위원, “구글, 수수료 15% 이하로 인하하라”국민의힘 과방위 위원, “구글, 수수료 15% 이하로 인하하라” 과학기술방송정보통신위원회 위원들은 8일 성명을 통해 “국내 앱마켓시장 점유율 63%의 압도적인 지위를 차지하고 있는 구글이 지난해 발표한 인앱결제 수수료 30% 부과는 국내 콘텐츠 개발사와 소비자들에 대한 부담이 너무 과도하다는 점을 깊이 공감한다”고 밝혔으며, “국내 앱 생태계의 상생과 발전이 무엇보다 중요하다는 차원에서 구글이 가까운 시일 내 대·중소기업 규모에 관계없이 일률적으로 15% 이하 수준으로 수수료를 인하할 것을 강력히 촉구한다”고 강조했다. 이들은 “과기부 실태조사 결과 국내 대기업의 50%는 구글의 30% 수수료를 콘텐츠 가격에 전가할 계획이라는 점에서 확인되었듯이 중소 앱 개발사뿐만 아니라 네이버·카카오 등 국내 플랫폼에 등록된 콘텐츠에 책정되는 수수료 부담이 그대로 소비자의 부담으로 돌아갈 것이 예상된다”고 밝혔다. 7. 인앱결제법 외면하는 야당…속 타는 콘텐츠 개발사인앱결제법 외면하는 야당…속 타는 콘텐츠 개발사 국회 과학기술정보방송통신위원회에서 입법을 논의 중인 인앱결제 강제 방지법이 해를 넘겨 난항을 겪고 있고, 과방위 소속 의원들이 앞다퉈 전기통신사업법 개정안을 내놓으며 구글과 같은 앱마켓 사업자의 갑질을 막으려 했지만, 야당인 국민의힘이 번번이 반대 목소리를 내는 탓에 국내 디지털콘텐츠 업계의 우려가 커지고 있다. 업계 한 관계자는 “글로벌 시장을 대상으로 국경이 없는 사업을 하는 구글에 특정 국가에서만 수수료를 바꾸라는 요구는 ICT 시장에 대한 무지와 무관심을 드러낸 것”이라며 “기업에 특정 수수료를 명시해 강요하는 것은 공산주의 국가에서나 가능한 일이 아니냐”고 비판했다. 인앱 결제 방지법 - 일명 구글 갑질 방지법..글 및 애플의 인앱결제 대신 다른 결제 시스템을 이용하더라도 불이익을 줄 수 없도록 하는 법안해외 사례 문제를 보면 구글의 자국 시장에서 주 별로 인앱결제 수단을 강요할 수 없는 법안이 잇달아 추진되고 있고, 애리조나 주 하원에서는 법안이 통과하기도 했다. 실제 입법 사례는 외면하면서 오히려 전례가 없는 수수료율 강제를 논하고 있다는 지적이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-08-IT_News/"},{"title":"[Spring Boot] 스프링부트 기초개념-Spring의 동작원리2","text":"","link":"/categories/Programming/SpringBoot/SPRINGBOOT-Study4-21-07-31/"},{"title":"2021년 3월 10일 수요일 IT뉴스","text":"1. ‘1등 없는 로또’에 10년 헛돈…넥슨 발 ‘사기’ 논란에 게임업계 초긴장‘1등 없는 로또’에 10년 헛돈…넥슨 발 ‘사기’ 논란에 게임업계 초긴장 10일 넥슨을 포함한 게임업체 관계자들과 이용자들 말을 들어보면, 메이플스토리 게임 이용자들이 확률형 아이템 구매를 통해 달성하도록 설계돼 있는 등급 중 일부는 실제로는 달성 불가능하고, 너무 강한 아이템이 나와 게임성을 해칠 것을 우려해 일부러 막았다고 해명했지만, 문제는 이를 사전에 이용자들에게 알리지 않았다는 점이다. 게임업체들은 이용자들을 상대로 ‘사행 행위’를 조장하거나 ‘사기 행위’를 벌인 것으로 간주돼 게임시장에 대한 규제가 강화될까 조심스러워하는 모습이 역력하며, 한 대형 게임업체 임원은 “국내 게임업체들이 게임자율정책기구를 중심으로 가이드라인을 만들어 유료 아이템의 확률을 공개하는 등 개선 노력을 해왔지만, 일부 업체들이 일부 아이템의 확률을 공개하지 않거나 공개된 확률 수치가 이용자들 체감 수준과는 달라 논란이 돼 왔는데, 법 개정 등을 통해 충분히 해결될 수 있다”고 강조했다. 하지만 컴플리트 가챠 등 사행성 논란을 키우는 사업 모델의 철회 가능성에 대해서는 한결같이 입을 다물고 있다. 컴플리트 가챠(이중 뽑기): 확률형 상품에 확률형 상품을 더하는 형태의 사업 모델이다. 예를 들어 5개의 일반 아이템을 획득해 영웅 아이템을 만들 수 있게 하면서 일반 아이템 각각은 물론 5개를 다 구했을 때 영웅 아이템으로 만들어지는지도 확률형으로 설계돼 있다. 2. 구글, 국내 유튜버에도 ‘미국 세금’ 물린다구글, 국내 유튜버에도 ‘미국 세금’ 물린다 연 5억 수입이 넘는 유튜버들의 소득 신고 의무화 법이 국회에서 발의된 가운데, 구글 유튜브는 지난 9일 “올해 말(이르면 2021년 6월)부터 구글이 의무적으로 미국 외 지역 크리에이터의 지급액에서 미국 세금을 공제한다”며 “적용 대상인 크리에이터들은 올 5월31일까지 세금 정보를 제출해야 한다”고 공지했다. 미국 월별 수입(광고 조회, 유튜브 프리미엄, 슈퍼챗, 슈퍼스티커, 채널 멤버십을 통해 미국 내 시청자로부터 창출한 수익)에 미국 세금이 적용되기 때문에 미국 외 지역 유튜버들은 미국에서 발생되는 수익 중 일부를 세금으로 내게 되며, 국내 유튜버들도 마찬가지로, 기존 수입이 줄어들 가능성이 커졌다. 3. 자체 칩 만드는 아마존·구글…삼성·ARM , 웃는 이유는? [IT클로즈업]자체 칩 만드는 아마존·구글…삼성·ARM , 웃는 이유는? [IT클로즈업] 중앙처리장치(CPU)·그래픽처리장치(GPU) 의존도를 낮추기 위해서 서버 업체가 인텔 AMD 엔비디아 대안을 찾기 시작했고, 자체 시스템반도체 개발에 나섰다. 새로 시스템반도체에 진출한 업체는 설계(팹리스)만 하는 업체이며, 실제 제품을 구현하려면 반도체 수탁생산(파운드리) 업체가 필요하기 때문에 TSMC에 비해 생산능력(캐파)에 여유가 있는 삼성전자에게 유리한 소식이다. 시스템 반도체: 정보(데이터)를 저장하는 메모리 반도체와 달리 중앙처리장치(CPU)처럼 데이터를 해석 · 계산 · 처리하는 비메모리 반도체 4. KT “양자암호 활용 일반 스마트폰 간 통화 도청방지 기술 개발”KT “양자암호 활용 일반 스마트폰 간 통화 도청방지 기술 개발” KT가 개발한 양자암호 기술을 적용하면 특수 제작된 단말을 이용하지 않더라도 일반 스마트폰으로 비화 통신을 이용할 수 있다. KT는 양자난수 생성기(QRNG)와 양자키 분배 시스템(QKD)을 결합한 기술로 보안성을 강화했고, 이 기술을 이용해 기존 비화 통신 사용 기관 외 민간 기업도 기밀 유출 방지 용도로 비화 통신을 활용할 수 있게 됐다고 설명했다.. 비화통신 - 정보 내용을 감추기 위하여 전송 신호를 변신하여 송수신하는 통신. 양자키 분배시스템 - 통신망의 데이터 송신부와 수신부에서 양자 암호키를 동시에 생성·분배하는 시스템 5. KT, 인공지능 119 신고 접수 시스템 개발한다KT, 인공지능 119 신고 접수 시스템 개발한다 KT AI 보이스봇 기술을 이용해 개발할 ‘AI 119 신고 접수 시스템’은 대형재난 등으로 119 신고가 폭주할 시, AI가 신고 접수를 받아 1차로 상황을 판단하게 된고, 이때 AI가 신고내용을 자동으로 식별해 긴급상황은 119 상황실로, 단순 민원은 정부 민원 안내 콜센터(110번)로 자동 연결한다. 또한 부산지역 사투리 등 현지 음성학습을 통해 언어모델을 구축하고 AI 엔진의 성능을 고도화 한다는 계획이다. 6. [커머스 격변기]’네이버‧이마트‧CJ vs 쿠팡‘, 이커머스 전쟁 죽기 아니면 살기[커머스 격변기]’네이버‧이마트‧CJ vs 쿠팡‘, 이커머스 전쟁 죽기 아니면 살기 10일 업계에 따르면 네이버와 이마트는 약 2500억원 규모의 지분 교환을 통해 협업을 추진한다는 내용이 알려지며 사실상 국내 이커머스 시장 경쟁은 ‘네이버‧이마트‧CJ’ 대 쿠팡의 구도가 만들어질 것이라는 관측이 늘고 있다. 국내 이커머스 시장 점유율 1위의 네이버를 중심으로 택배 1위 CJ대한통운, 오프라인 할인점 1위 이마트가 협력하는 구조다. 지분교환은 단순 사업제휴보다 훨씬 더 강력한 형태의 동맹으로 평가 받는다. 지분교환을 두고 ‘혈맹’이라고 표현이 나올 정도다. 교환 주식 수가 적더라도 상대 기업에 대한 지배력을 확보하기 때문에 쉽게 결정할 수 있는 사안은 아니다. 범 현대가 기업들처럼 오너일가가 친척이나 형제 관계일 때 지분교환을 하는 경우가 많다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-10-IT_News/"},{"title":"2021년 3월 9일 화요일 IT뉴스","text":"2021.03.09.​ 1. 카카오페이, 펀드·대출 서비스 ‘순항’…더 아쉬운 마이데이터 보류카카오페이, 펀드·대출 서비스 ‘순항’…더 아쉬운 마이데이터 보류 카카오페이가 펀드 상품 구성을 다양화하는 것은 물론 보험사들에게 신용대출을 받을 수 있도록 연결해주는 다리역할까지 빠르게 기능을 추가하고 있는 등의 증권과 보험 등 전금융 부문에서 적극적으로 영역을 넓히고 있다. 카카오페이가 종합금융플랫폼이 되기까지 몇 걸음 안남은 상황이다보니 최근 금융위원회로부터 마이데이터 허가를 받지 못한 점이 더 속이 쓰린 상황이며, 이에 따라 카카오페이는 지난달 5일부터 Δ자산관리 서비스 중 은행, 카드, 투자, 보험, 대출, 현금영수증 통합조회 Δ금융리포트 서비스 중 은행, 카드, 현금영수증, 투자 기반 정보제공 Δ버킷리스트 서비스 중 카드, 현금영수증 정보 기반 부스터 기능 Δ영수증 서비스 중 오늘의 이용내역 Δ내보험관리 서비스 중 보험가입 내역 조회 일부 기능 등을 중단했다. 마이데이터는 은행, 보험사, 카드사 등 기존 금융회사와 관공서, 병원 등에 흩어진 개인신용정보를 기반으로 맞춤형 금융상품과 서비스를 추천 및 개발할 수 있는 사업이다. 지난해 8월 시행된 개정 신용정보법에 따라 마이데이터 사업이 허가제로 전환되면서 기존 사업자도 지난달부터 허가를 받아야 한다. 2. 스타링크 위성 인터넷, 움직이는 자동차에도 제공될까스타링크 위성 인터넷, 움직이는 자동차에도 제공될까 스페이스X는 현재까지 스타링크의 위성 인터넷은 인터넷 연결이 어려운 지역을 중심으로 초고속 인터넷 서비스를 제공하는 것을 목표로 해왔으며, 지난 금요일 미국 FCC에 자동차, 트럭, 선박, 항공기에 스타링크 인터넷 단말기를 설치해 인터넷 서비스를 제공할 수 있도록 요청하는 라이선스 인증 요청 서류를 제출했다. 스페이스X가 광대역 인터넷 서비스를 차량까지 확대해 전 세계 통신 시장의 몇 %를 확보할 수 있다면 회사의 매출이 크게 늘어날 수도 있을 전망이라고 외신들은 전했다. 3. 카카오·네이트 되는데…네이버뉴스에선 유튜브를 볼 수 없다카카오·네이트 되는데…네이버뉴스에선 유튜브를 볼 수 없다 지난 2019년 2월 네이버는 “뉴스 내 유튜브 영상이 재생되지 않는 경우가 있는데 민원이 네이버로 향한다”며 “우리가 타사 플랫폼 문제에 대해 일일이 조치를 취할 이유가 없으니 네이버TV 등을 이용해 이용자들의 불편함이 없게 해달라”고 하면서 자체 포털에서 노출되는 뉴스에서 유튜브 영상 삽입을 제한했다. 실제 네이버가 ‘기술적인 이유’ 때문이 아니라 ‘자사 플랫폼을 우대’하려는 이해관계에서 유튜브 영상을 제한한 것이라면 공정거래법 위반 소지가 있다는 지적이 나오고 있지만, 네이버 관계자는 “네이버는 다른 포털에 비해 뉴스 트래픽이 훨씬 많이 발생하고 그만큼 민원도 많이 들어온다”며 “순수하게 이용자 불편 차원에서 접근한 것이지 ‘네이버TV 키우기’와는 아무 관련이 없다”고 했다. 4. 자본소득에 관심…주식·암호화폐 앱 사용자 1011만 명자본소득에 관심…주식·암호화폐 앱 사용자 1011만 명 와이즈앱·와이즈리테일이 한국인 만 10세 이상 Android와 iOS 스마트폰 사용자를 표본조사한 결과, 지난 2월 한 달 동안 사용자가 많은 상위 10개 주식/암호화폐 앱을 1번 이상 이용한 사람은 1,011만 명으로 조사됐으며, 사용자 1,011만 명 중 10대는 2.4%, 20대는 17.4%, 30대 23.0%, 40대 32.0%, 50대 이상이 25.1%였다. 특히, 작년 11월부터 매달 주식/가상화폐 앱 사용자가 급증했고, 키움증권 영웅문S는 작년 11월에는 사용자가 208만 명에서 올 2월에는 323만 명으로 55% 증가 삼성증권 mPOP은 작년 11월에는 사용자가 132만 명에서 올 2월에는 184만 명으로 39% 증가 업비트(가상화폐앱)는 작년 11월에는 사용자가 63만 명에서 올 2월에는 166만 명으로 163% 증가 5. “개발자 20년이면 치킨집행” 컴공과 기피현상 불렀다“개발자 20년이면 치킨집행” 컴공과 기피현상 불렀다 서울대 컴퓨터공학과는 2006년부터 2011년까지 5년간 매번 미달 사태를 겪었고, 카이스트 전산학과는 2004년 이후 7년간 단 한 번도 학과 정원 50명을 채우지 못했고, 이후 주요 IT기업의 개발자들에 대한 처우가 막노동에 비견될 정도로 좋지 못하고 휴일없는 프로젝트로 혹사 논란까지 일어나 ‘개발자 20년이면 결국 치킨집행’이라는 자조까지 나돌면서 SW 전공 기피현상을 심화시켰다. 업계에서는 같은 개발자라해도 개발수준과 경력에 따라 처우, 업무강도가 천차만별이라는 것이라는 지적이 있으며, 실제 최근 네카라쿠배당토(네이버·카카오·라인·쿠팡·배달의민족·당근마켓·토스) 등 주요 IT기업이 선점경쟁을 벌이는 인력들은 대부분 10년차 이상으로 각종 모바일 프로젝트나 신 서비스 구축을 경험한 팀장급이다. 나머지 대다수 일반 IT서비스 개발자들은 여전히 단순 코딩업무를 반복하며 야근과 밤샘에 시달린다는 후문이다. –&gt; 요즘 연봉을 올리면서 개발자를 영입하려는 기업들은 많고, 개발자는 부족하다고 하나….사실 기업들이 영입하려는 개발자는 상위1%이며, 나머지 개발자들은 기업에서 원하는 만큼의 기술과 실력이 부족하여 SW아카데미를 통해 직접 키워 개발자 수요를 채우고 있는 것 같다. 결론은 단순코딩이 아니라 문제 해결능력을 기르고 트렌드에 맞춰 기술을 쌓아야 취업에 도움이 된다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-09-IT_News/"},{"title":"[Spring Boot] IntelliJ 학생인증, Ultimate 무료설치하기","text":"인텔리제이 학생인증IntelliJ IDEA는 두가지 버전이 있습니다. 무료버전인 Community와 유료버전인 Ultimate. 저는 학생이기 때문에 학생인증을 받아 Ultimate 버전을 사용해보도록 하겠습니다. 1. JetBrains의 학생인증 사이트 접속하기접속링크 Apply now 버튼을 클릭합니다. 2. 정보 입력 및 회원 가입인증을 위해 아래 사진과 같은 폼에 정보를 입력합니다. 제출 후에는 아래 사진과 같은 이메일을 받을 수 있습니다. 링크를 클릭 후 진행 및 회원 가입하면","link":"/categories/Programming/SpringBoot/SPRINGBOOT-IntelliJ-21-06-29/"},{"title":"2021년 3월 11일 목요일 IT뉴스","text":"2021.03.11.​ 1. 정부, AI데이터 150종 구축···다음달 6일부터 접수정부, AI데이터 150종 구축···다음달 6일부터 접수 과기정통부가 인공지능(AI) 강국 코리아 달성을 위해 2925억원을 투입해 AI학습용 데이터 150종을 구축하기로 했으며, AI 개발에 필수인 양질의 인공지능 학습용 데이터를 대규모로 구축 및 개방하는 ‘인공지능 학습용 데이터 사업’ 공모를 12일부터 시작한다고 밝혔다. 올해 구축하는 인공지능 학습용 데이터 150종은 6대 핵심분야(음성·자연어, 비전(영상·이미지), 헬스케어, 교통·물류, 농·축·수산, 재난·안전·환경)의 지정 공모과제 130종과 자유 공모과제 20종(지역 과제 10종, 자유 과제 10종)이다. 2. 쿠팡 공모가 주당 35달러·기업가치 72조원…알리바바 이후 최대쿠팡 공모가 주당 35달러·기업가치 72조원…알리바바 이후 최대 미국 뉴욕증권거래소(NYSE)에 상장하는 쿠팡의 주식 공모가가 35달러(약 3만9862원)로 정해졌다고 월스트리트저널(WSJ) 등 외신이 10일(이하 현지시간) 전했다. 쿠팡은 이번에 총 1억2000만주를 공모하여 이에 따라 42억달러(약 4조8000억원)에 이르는 자본을 조달할 수 있게 됐고, 공모가 기준 쿠팡의 기업가치는 630억달러(약 71조8000억원)에 육박하게 된다. 3. [이슈IN]‘힘겨루기’ 이긴 스포티파이, 카카오엔터 음원 얻었다[이슈IN]‘힘겨루기’ 이긴 스포티파이, 카카오엔터 음원 얻었다 스포티파이·카카오엔터테인먼트(이하 카카오엔터·구 카카오M)는 “글로벌 음원 라이센싱 재계약에 대한 협의를 마쳤다”고 밝혔고, 한국을 포함한 전세계 스포티파이 서비스에서 카카오엔터가 유통하는 국내 가수들의 음원을 들을 수 있게 됐다. 포티파이는 “카카오 측 아티스트의 음악을 전 세계의 팬 그리고 170개국 3억4500만명 이상의 스포티파이 청취자에게 다시 제공할 수 있게 됐다”면서 “앞으로도 아티스트, 레이블 및 권리자 단체와의 협업을 통해 한국의 음원 스트리밍 생태계에 긍정적인 영향을 가져올 수 있도록 지속적으로 노력하겠다”고 전했다. 4. NHN, 2025년 연매출 1조원 목표…글로벌 진출 가속화NHN, 2025년 연매출 1조원 목표…글로벌 진출 가속화 NHN이 오는 2025년까지 연매출 1조원 달성 목표로 “기술 선도, 글로벌 네트워크 구축 등을 비전으로 삼고 국내를 넘어 세계 클라우드 시장의 리더로서 성장하겠다”며 “이를 위해 ‘NHN 클라우드’ 서비스로 새롭게 시작한다”고 강조했다. NHN은 지난 2014년 처음 클라우드 서비스를 시작, 현재 120여개 인프라와 플랫폼 상품을 제공하고 있고 금융·공공을 포함한 커머스 산업군에서 3천여개 이상 고객을 확보했으며, 지난해 클라우드 전체 매출은 1천600억원을 달성했다. 5. “돈 내면 복호화 보장”···랜섬웨어, 신종 사업화“돈 내면 복호화 보장”···랜섬웨어, 신종 사업화 10일 경찰청과 보안업계에 따르면 랜섬웨어 수익성이 높아지면서 랜섬웨어가 급격히 산업화하는 것으로 파악됐고, 새로운 랜섬웨어 공격 조직도 급증했다. 랜섬웨어는 피해자가 금전을 지불하더라도 복호화 키를 건네주지 않는 등 단기성 갈취 성격이 짙었고, 최근에는 수익성 강화를 위해 금전 지불 시 반드시 복호화를 진행하는 식으로 수법이 진화했다. 복호화 보장 없이는 피해자가 금전을 지불하지 않는다는 심리를 노린 것이다. 6. “코로나에 ‘홈트’ 열풍” 스마트워치 판매 늘었다…1위는 애플“코로나에 ‘홈트’ 열풍” 스마트워치 판매 늘었다…1위는 애플 지난해 스마트워치·밴드로 구성된 웨어러블 기기 시장이 신종 코로나바이러스 감염증(코로나19)으로 인해 외부 활동이 어려워졌음에도 판매가 늘어난 것으로 나타났는데, 이는 코로나19로 홈 피트니스 수요가 늘어나고, 건강에 대한 관심이 높아지면서 해당 시장이 커진 것으로 분석된다. 지난해 국내에서 판매된 스마트워치는 91만2천대로 전년보다 3만대 정도 증가했으며, 스마트밴드는 261만8천대로 전년보다 11만대 정도 감소했고, 이는 밴드의 수요가 스마트워치로 옮겨간 것으로 분석됐다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-11-IT_News/"},{"title":"2021년 3월 14일 일요일 IT뉴스","text":"1. “이참에 디즈니+로 갈래” 넷플릭스에 뿔난 전세계 이용자들“이참에 디즈니+로 갈래” 넷플릭스에 뿔난 전세계 이용자들 넷플릭스가 유료 가입자의 계정 비밀번호 하나를 여러 명이 공유해 사용하는 것을 막겠다는 취지로 비밀번호 공유를 통한 ‘몰래 시청’을 단속하기로 하자 전세계 넷플리스 사용자들의 반발이 거세지고 있으며, 일부 사용자들은 이참에 ‘디즈니+나 아마존프라임으로 옮기겠다’는 반응을 보였다. 한 영국의 트위터 이용자는 “넷플릭스가 경쟁에 초조해지자 지나친 탐욕을 부리고 있다”며 “가격을 올리면서 이용자 규제를 강화하는 조치는 오히려 그들을 궁지로 내몰 것”이라고 반발했다. 2. 갤럭시폰 부팅 시 ‘삼성 로고’ 먼저 뜬다갤럭시폰 부팅 시 ‘삼성 로고’ 먼저 뜬다 삼성전자에 따르면 올해 출시되는 제품부터 전원이 켜질 때 모델명 대신 ‘SAMSUMG(삼성)’ ‘SAMSUNG GALAXY(삼성 갤럭시)’ 로고를 표시하는 방식을 적용하여 브랜드 강화 전략을 내세웠다. 기존 갤럭시S20를 쓰는 사용자는 스마트폰을 부팅하면 화면에 ‘삼성 갤럭시S20 5G’라는 모델명이 먼저 표시된 뒤 ‘삼성’ 로고가 뜬다. 3. ‘붙였다 떼었다’…카카오, 멜론 분사..대표는 이진수 카카오엔터 대표‘붙였다 떼었다’…카카오, 멜론 분사..대표는 이진수 카카오엔터 대표 멜론은 2004년 SK텔레콤이 만든뒤 2013년 홍콩 사모펀드인 스타인베스트에 매각됐다가 2016년 카카오에 1조8700억원에 인수됐었고, 이후 카카오M에 있다가 2018년 9월 카카오가 카카오M과 합병하면서 다시 카카오로 넘어갔다. 하지만, 2년 반만에 다시 멜론컴퍼니로 분할되며 카카오 관계자는 글로벌 1위 음원 서비스인 스포티파이의 국내 진출이 본격화된 시점에서 “멜론이 더 적극적으로 시장 확대에 나서야 할 시점이라 판단해 멜론 사업부를 물적 분할하기로 결정했다”고 말했다. 4. [장기자의 비사이드IT]롤러블이 폴더블보다 좋은 이유[장기자의 비사이드IT]롤러블이 폴더블보다 좋은 이유 대화면 폴더블폰은 접어서 한 손으로 잡을 수 있도록 만들었지만 기존 스마트폰에 비해서는 어쩔 수 없이 두껍고 무거우며, 접히는 부분의 화면 주름 역시 많이 개선됐지만 아직도 ‘거슬린다’는 지적도 꾸준히 나오고 있다. 최근 롤러블(말리는)폰에 대한 관심이 높아지는 것은 폴더블폰의 이런 불편함을 해소해 줄 수 있을 것으로 보기 때문이고, 폴더블폰에 비해 훨씬 얇고 가벼울 뿐 아니라, 화면 주름 문제도 해결될 것이란 기대입니다. 5. 마켓컬리 야놀자 쏘카…’넥스트 쿠팡’ 후보는마켓컬리 야놀자 쏘카…’넥스트 쿠팡’ 후보는 마켓컬리 운영사인 컬리의 김슬아 대표는 최근 사내 공지를 통해 연내 상장 계획을 밝혔으며, 마켓컬리는 해외 IPO만을 고집하지 않고 국내외 시장 모두 살피며 어느 곳이든 가능성을 열어둔다는 입장이지만, 미국 월스트리트저널은 김 대표가 쿠팡처럼 뉴욕증시에 상장하는 것을 염두에 두고 있다고 보도했다. 숙박 플랫폼 야놀자 역시 올해 IPO를 앞두고 있으며, 코로나19 장기화로 해외여행 수요가 국내로 흡수되면서 야놀자에겐 기회가 됐고, 특히 동종업계의 에어비앤비가 지난해 미국 나스닥에 상장하면서 기업가치가 120조원까지 불어나 야놀자에 대한 상장 기대감도 높아지고 있다. 마켓컬리: 마켓컬리는 지난 2015년 ‘저렴한 가격’ 위주의 이커머스 시장에서 프리미엄 상품과 주문 다음날 아침에 바로 배달하는 새벽배송을 내세워 급성장했다. 그동안 이커머스 업계의 약점으로 꼽힌 신선식품 배송을 산지직송 방식으로 하루만에 배달하면서 짧은 시간에 급성장할 수 있었다. 6. “떡볶이 먹고 살쪘다고 별점테러” 배달앱 리뷰 악몽 호소하는 사장님“떡볶이 먹고 살쪘다고 별점테러” 배달앱 리뷰 악몽 호소하는 사장님 배달앱 별점 평가란이 주문의 주요 척도가 되면서 후기 하나하나에 신경 쓸 수밖에 없기 때문에, 자영업자들이 배달앱 악성 리뷰와 이유 없는 별점 테러에 고충을 호소하고 있다. 배달의민족은 최근 악성 리뷰에 대해 자영업자가 요청하면 30일 동안 게시를 중단하는 시스템을 운영하고 있으며, 요기요도 ‘클린 리뷰’ 시스템을 도입해 악용 사례 차단에 나섰지만 수개월이 지난 지금도 여전히 악성 리뷰 문제는 끊이지 않고 있다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-14-IT_News/"},{"title":"2021년 3월 12일 금요일 IT뉴스","text":"1. 공유킥보드 씽씽, 채용 대폭 늘린다…직·간접 1000명 규모공유킥보드 씽씽, 채용 대폭 늘린다…직·간접 1000명 규모 공유킥보드 업체 ‘씽씽’이 인력 채용 규모를 늘리는 등 사업 확장에 나선다. 씽씽은 “올해 운영 지역을 100곳 이상 늘리고 킥보드도 더 확보하기로 했다”며 “운영자와 개발자를 대폭 증원하는 차원에서 채용 규모를 확대했다”고 말했으며, “공유킥보드 사업이 성장 추세에 있는 만큼 사업을 확장, 다각화하면서 양질의 일자리 창출에 기여할 것”이라고 강조했다. 2. 웹드 제작사 ‘플레이리스트’, 250억 투자 유치웹드 제작사 ‘플레이리스트’, 250억 투자 유치 종합 콘텐츠 스튜디오 플레이리스트가 벤처캐피털(VC) IMM인베스먼트 등으로부터 250억원 규모의 투자를 유치했다. 윤원기 IMM인베스트먼트 상무는 “플레이리스트는 국내 OTT 성장에 따라 급변하고 있는 시장에서 다수의 흥행 콘텐츠를 제작한 노하우가 있다”며 “콘텐츠 주요 소비 세대의 문화와 취향을 반영한 IP 제작은 물론, 글로벌 OTT 채널을 기반으로 한 K-콘텐츠 제작사로 성장할 것”이라고 밝혔다. 플레이리스트: 2017년 네이버 자회사 네이버웹툰과 스노우가 공동 출자해 설립한 종합 콘텐츠 스튜디오이며, 글로벌 누적 조회 31억뷰를 기록했으며 전 세계 구독자 1400만명을 확보했다. 3. 쿠팡 이어 마켓컬리도 상장 추진…WSJ “연내 美 상장 검토”(종합)쿠팡 이어 마켓컬리도 상장 추진…WSJ “연내 美 상장 검토”(종합) 쿠팡이 미국 증시에 성공적으로 상장한 가운데 켓컬리 운영사 컬리에 따르면 김슬아 대표는 최근 팀장급 이상 직원들을 대상으로 연내 상장 추진 계획을 공유했다. 미국 월스트리트저널(WSJ)는 마켓컬리 내부 자료를 인용해 마켓컬리 이용자의 재이용률이 60%로 업계 평균치(29%)보다 훨씬 높다고 전했으며, 또 세계에서 다섯 번째로 큰 한국의 온라인 쇼핑 시장은 올해 규모가 1천160억달러로 작년보다 11% 성장할 것으로 예상된다며 한국 온라인 시장의 강점으로 자체 물류 시스템을 통한 안정적인 배송 등을 꼽았다. 4. “쿠팡 너무 부럽다” 커머스 1위 네이버는 왜 못한 대접을 받을까 [IT선빵!]“쿠팡 너무 부럽다” 커머스 1위 네이버는 왜 못한 대접을 받을까 [IT선빵!] 증권업계는 올 한해 쿠팡의 거래금액이 33조원에 달할 것으로 전망하고 있고, 상장 첫날, 쿠팡은 약 95조원의 시가총액으로 장을 마쳤기 때문에, 쿠팡은 거래액 기준 약 3배의 몸값으로 거래되고 있다고 할 수 있다. 네이버는는 올해 약 35조원의 거래액을 기록할 것으로 전망되고 있으며, 네이버의 전날 종가 기준 시가총액은 약 61조원이지만, 증권업계보고서를 이용하여, 이커머스 비중만 고려하면 즉, 거래액은 35조원이고 몸값은 20조원으로, 약 0.6배의 멀티플이 반영돼 쿠팡의 5분의 1 수준이다. 쿠팡은 상장 첫날 주가가 40% 이상 급등했으며, 한국 코스피로 치면 네이버(61조원), LG화학(66조원)을 훌쩍 뛰어넘고 SK하이닉스(100조원)와 어깨를 나란히 하는 기업이 되었고, 현대차와 비교하면 시가총액이 2배 가량이나 크다. 5. [단독] 마음 바뀐 원스토어, ‘구글 갑질 방지법’ 돌연 반대[단독] 마음 바뀐 원스토어, ‘구글 갑질 방지법’ 돌연 반대 ‘구글 갑질 방지법’, ‘구글 인앱결제 강제 방지법’이라고 불리는 전기통신사업법 개정안과 관련해 국산 애플리케이션(앱) 마켓인 원스토어가 반대한다는 의사를 표명한 것으로 확인됐다. 구글과 애플 ‘때리기’로 시작된 인앱결제 논란이 부메랑이 돼 자신들을 옥죄는 규제로 돌아올 것이라는 우려에서다. 6. 네카당(네이버·카카오·당근마켓)도 믿고 맡기는 코딩 테스트 솔루션 [신무경의 Let IT Go]네카당(네이버·카카오·당근마켓)도 믿고 맡기는 코딩 테스트 솔루션 [신무경의 Let IT Go] ―카카오도, 네이버도 개발자 채용 시험을 볼 때 그렙을 활용한다고 들었는데요. 왜 그들이 그렙을 쓰는 건가요.$$온라인으로 개발자 코딩 시험을 치를 때 한 번에 1만 명 씩 몰리게 되면 시스템이 불안정해질 수 있는데 저희는 안정적으로 해내고 있습니다. 그 다음으로는 채용의 편의성이지요. 기존에는 해당 기업들이 직접 코딩 문제를 출제했었는데요. 채용 때마다 코딩 문제 만드는데 리소스를 투입하는 게 낭비라 느낀 것 같습니다. 저희가 가진 개발자 코딩 테스트 솔루션은 해외에서도 레퍼런스를 찾아볼 수 없어요.$$―경쟁사 대비 그렙의 강점이 무엇인가요.$$‘데브 매칭’이라고 해서 개발자 채용을 원하는 30~40군데 기업들과 프로그래머스 시험에 응시하는 구직자들을 매칭해주는 서비스를 제공하고 있습니다. 응시자들은 프로그래머스에서 성적을 받은 뒤 참여 기업 중 5곳을 지원할 수 있어요. 당근마켓, 뱅크샐러드 등이 데브 매칭에 들어오기도 했죠. 이 밖에 고무적인 부분은 프로그래머스에 프로필을 등록한 개발자들이 검색을 통해 채용되는 사례들이 늘어난다는 점이에요.$$ 그렙은 개발자의 코딩 실력을 검증할 수 있는 평가 플랫폼을 구축해 사업화하고 있는 스타트업이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-12-IT_News/"},{"title":"2021년 3월 21일 일요일 IT뉴스","text":"1. 반짝 유행 vs 1700조 성장···요즘 난리난 메타버스 미래는반짝 유행 vs 1700조 성장···요즘 난리난 메타버스 미래는 전문가들은 메타버스가 여러 기술이 복합적으로 작용해 사회적 파급력을 가질 수 있다는 점에서 하나의 ‘혁명’이 될 수 있다고 분석한다. 예를 들어 게임이 아닌 업무나 생계 활동 등 일상생활이 메타버스 안에서 가능해지는 것이며, 수익모델 역시 게임 아이템 판매→마케팅 솔루션 제공→이커머스·콘서트 개최 등 점점 현실세계와 연계되는 쪽으로 진화하고 있다. 기술 혁신으로 메타버스를 지원하는 가상현실(VR)·AR 등 ‘몰입 기기’의 가격도 내려가고 있고, 몰입 기기의 평균 가격은 1991년 41만 달러(약 4억6000만원)에서 2020년 2만 달러(약 2200만원) 수준으로 감소했고, 10년 뒤에는 1700 달러(약 192만원)까지 하락할 전망이다. 메타버스는 가공·추상을 의미하는 ‘메타’(Meta)와 현실세계를 가리키는 ‘유니버스’(Universe)의 합성어로 ‘3차원(3D) 가상세계’를 일컫는 말이다. 사용자의 몸은 현실에 있지만 메타버스에 접속하면 무엇이든 현실처럼 누릴 수 있는 가상공간이 펼쳐진다. 기존의 단순 가상세계와도 구분된다. 플랫폼 제공자가 판매자, 사용자는 소비자의 역할만 하는 게 아니라 각각 서로 재화와 서비스를 사고팔 수 있다. 여기에 증강현실(AR)·확장현실(XR)·5세대(5G) 통신 같은 기술 발전이 더해져 가상과 현실 사이의 간극이 좁아지고 있다. 2. 한은 “美 빅테크 반독점규제 더 강화될 것”한은 “美 빅테크 반독점규제 더 강화될 것” 미국에서 구글·마이크로소프트·애플·페이스북·아마존 등 빅테크(Big Tech) 기업의 시장지배력이 확대되면서 반독점규제 강도도 높아지고 있으며, 바이든 행정부와 미국 민주당이 빅테크에 대한 반독점규제를 더욱 강화할 것으로 예상되는 가운데 우리나라에 직간접적인 영향을 미칠 수 있다는 분석이 나왔다. 빅테크 기업의 시장지배력이 커지면서 자유 시장 경제를 훼손하고 있다는 비판이 고조됐고 규제 필요성도 제기됐으며, 기술혁신의 주역이었지만 이제는 진입장벽을 구축하고 신생기업을 위협하는 등 부작용을 낳고 있다는 것이다. 빅뱅크는 대형은행을 의미하며, 주로 1금융권 은행이다. 빅테크(Big tech)란 대형정보기술 기업을 뜻하는 말로, 국내의 네이버와 카카오 등 온라인 플랫폼 제공사업을 핵심으로, 금융시장 등에 진출한 기업을 지칭하는 뜻입니다. 최근에는 엄청난 양의 정보를 가진 ‘대형 정보기술 기업’들이, 이 정보를 통해 그동안 금융시장을 꽉 잡고 있었던 ‘대형은행’의 영역에 진입하고 있다. 핀테크(Fin Tech)는 금융의 Finance와 기술의 Technology의 앞부분을 따서 만든 단어입니다.금융과 정보기술의 융합, 즉 금융회사가 주도하는 금융기술서비스입니다.금융회사가 주체가 되기 때문에 높은 신뢰도와 금융에 대한 노하우가 있는 것이 특징입니다. 테크핀(Tech Fin)은 핀테크와 반대로 IT 기업이 주도하는 금융 서비스를 의미합니다. 즉 기술기반의 기업이 제공하는 금융 서비스를 하는 것을 의미하며, IT 기업이 주체가 되기 때문에 기술 경쟁력을 가지고 있다는 특징 결국 빅뱅크는 핀테크를 하고, 빅테크는 테크핀을 하는 것이다. 3. 소셜미디어의 미래가 ‘음성’에 달렸다는 이유소셜미디어의 미래가 ‘음성’에 달렸다는 이유 8조원 회사 된 게이머들 채팅앱 ‘디스코드’, 2020년 가장 뜨거운 앱으로 떠오른 ‘클럽하우스’를 보면 왜 ‘음성’이 소셜미디어의 미래를 좌우할 것이라는 분석이 나오는지 알 수 있다. 그리고 클럽하우스와 디스코드가 부상하면서 ‘초크’(오디오 기반 비공개 소셜 네트워킹 앱), ‘스푼’(한국에서 창업한 글로벌 오디오 라이브 스트리밍 플랫폼), ‘카푸치노’(가까운 지인들과 녹음 된 음성을 공유할 수 있는 서비스) 등과 같은 오디오 기반 앱들도 투자자들의 관심을 받고 있으며, 페이스북, 트위터, 텔레그램 등도 경쟁적으로 음성 채팅 기능을 추가하고 있다. 4. 테슬라 자율주행기능 ‘오토파일럿’ 연이어 사고‥완전한 자율주행 아직 멀었나테슬라 자율주행기능 ‘오토파일럿’ 연이어 사고‥완전한 자율주행 아직 멀었나 미국 미시건주 디트로이트시에서 테슬라 자율주행차의 오토파일럿 오작동이 주요원인으로 꼽히는 교통사고가 일주일 사이 두 번 발생했고, 과거 자율주행차 사고와 어디에 책임을 물을 것인지 등 과실치사 논쟁에 다시 불이 붙을 것으로 보인다. 인공지능에 의해 피해를 입었음에도 그를 법적으로 책임지게 할 법과 제도 마련은 아직도 멀게 느껴진다는 목소리가 커지고 있으며, 단지 자율주행만 해당되는 문제는 아닌 무인 드론, 에어택시 등 첨단기술과 결합해 진화하는 교통 시스템에 맞춰 윤리에 기반한 판단 기준을 정립하자는 주장은 더욱 거세지고 있다. 5. ‘인공지능 특허는 ‘급증’…데이터 활용은 ‘답답’인공지능 특허는 ‘급증’…데이터 활용은 ‘답답’ 우리나라의 인공지능 특허는 매년 큰 폭으로 증가하고 있지만, 인공지능의 기반인 데이터의 수집과 활용에는 제약이 많아 연구자들의 발목을 잡고 있습니다. 한국전자통신연구원은 AI 전문 인력을 현재 644명에서 2023년에는 천 명으로 늘리겠다는 계획을 발표했지만, 늘어나는 AI 전문가들이 제 역할을 하려면 양질의 데이터가 필수적이고, 전문가들은 데이터의 상업적인 활용은 강력하게 규제하되, 연구 목적에 한해서는 엄격한 관리하에 데이터를 취합하고 활용할 수 있는 길을 열어 줘야 한다고 지적합니다. 6. 네이버, 지난해 매출 25% R&amp;D에 썼다…국내 기업 중 최고 수준네이버, 지난해 매출 25% R&amp;D에 썼다…국내 기업 중 최고 수준 네이버의 사업보고서에 따르면 지난해 R&amp;D 투자액은 전년(2019년)보다 늘어 2365억원 늘어 사상 최대 규모를 기록했으며, 영업이익(1조2153억원)보다도 많았다. 네이버는 이런 투자를 통해 지난해 딥러닝 기반 동영상 인코딩 최적화, 브이라이브 가상현실(VR) 플랫폼 개발 등 46개 과제의 기술 개발을 마쳤으며, 네이버 자체 블록체인 플랫폼, 얼굴 인식 기술, 다국어 처리 연구 등 133개 과제가 진행 중이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-21-IT_News/"},{"title":"2021년 3월 18일 목요일 IT뉴스","text":"1. [단독]카카오T, 렌터카 중개도 한다…현대캐피탈 ‘딜카’인수[단독]카카오T, 렌터카 중개도 한다…현대캐피탈 ‘딜카’인수 카카오T를 운영하는 카카오모빌리티가 현대캐피탈의 렌터카 중개 서비스 ‘딜카’를 인수하기로 하면서 대리운전·택시 등 카카오T 기존 서비스에 렌터카까지 추가되면 카카오T의 모빌리티(MaaS) 플랫폼 경쟁력이 더 강력해질 전망이다. 딜카는 현재 전국 중소 렌터카 업체 280곳과 제휴관계이며 향후 카카오모빌리티는 제휴를 더 늘리고, 카카오T 플랫폼에 딜카의 렌터카 중개 서비스를 탑재하는 방향을 검토 중이다 MaaS는 사용자가 이동해야할 상황에서 필요한 거의 모든 이동수단을 앱 하나로 해결해주는 서비스다. 보통 모빌리티 서비스의 사업모델은 운전자와 차량 소유자에 따라 크게 4가지로 나뉜다. 남의 차를 남이 운전(택시 호출), 남의 차를 내가 운전(차량공유·렌터카), 내 차를 내가 운전(내비게이션), 내 차를 남이 운전(대리운전)할 때 필요한 서비스다. 2. ‘불안한 1위’ 삼성…갤럭시A 밀리면 답 없다‘불안한 1위’ 삼성…갤럭시A 밀리면 답 없다 “사업하는 입장에서 시장점유율은 생명이고, 수익은 인격이다.” 2년 전인 2019년 8월 고동진 삼성전자 IM(IT·모바일)부문장 사장이 미국 뉴욕에서 진행된 기자간담회에서 언급한 말이며, 글로벌 스마트폰 시장에서 생명과 인격을 모두 지켜내겠다고 약속했다. 플래그십 모델인 ‘갤럭시S’, ‘갤럭시노트’ 등 플래그십 제품에 한해서만 진행하던 글로벌 언팩 무대에 보급형 모델인 ‘갤럭시A’를 주인공으로 세웠고, 이는 삼성전자의 시장 점유율이 심상치 않기 때문으로 보인다. 3. ‘5G 특허’ 칼 빼든 화웨이, 누가 긴장하고 있을까‘5G 특허’ 칼 빼든 화웨이, 누가 긴장하고 있을까 미국의 강한 압박을 받고 있던 화웨이가 결국 앞으로 5G 특허권 사용료를 받겠다고 선언하면서 스마트폰업계를 긴장시켰다. 화웨이는 5G 특허권 최다 보유업체이고, 건수로만 3천건을 웃돌며 지난 해 유럽통신표준화기구(ETSI)가 발표한 자료에 따르면 화웨이는 5G 필수표준특허(SEP)도 302건을 갖고 있으며 이는 전체 5G 필수표준특허의 19%에 해당된다. 4. 페이코로 소비하던 2030세대…”마이데이터로 ‘금융 둥지’ 틀 것”페이코로 소비하던 2030세대…”마이데이터로 ‘금융 둥지’ 틀 것” 본인신용정보관리업(마이데이터) 허가를 획득한 NHN페이코는 2030세대에 특화된 종합 마이데이터 관리 플랫폼을 목표로 하고 있다. NHN페이코 관계자는 “자체 데이터센터(IDC) 내 금융존을 별도로 구축할 만큼 인프라 보안도 철저하게 관리하고 있다”며 “오랜 기간 게임 및 콘텐츠 사업과 결제 서비스를 지원하면서 자체 FDS 시스템을 확립해 이상거래에 대한 탐지 수준도 매우 높은 편”이라고 설명했다. 5. 포밸류소프트, ‘마이데이터 제공 플랫폼’ 개발 완료포밸류소프트, ‘마이데이터 제공 플랫폼’ 개발 완료 포밸류소프트의 마이데이터 제공 플랫폼은 데이터 보유기관이 개인으로부터 신용정보 제공 요청을 받을 경우, 정보주체의 정보 전송요구권에 따라 개인 신용정보를 제공하는 시스템으로 ▲마이데이터 인증 ▲업권별 표준 API 지원 ▲거래모니터링 ▲API 관리·운영 서비스 등 관리포탈을 기본으로 제공한다 김준영 포밸류소프트 대표는 “마이데이터 사업자의 본허가가 확정되고 사업자간 개인 신용정보를 활용한 서비스 경쟁이 심화될 것”이라며 “마이데이터 시스템의 빠른 구축과 데이터 활용 서비스 제공은 신규 고객 선점 및 기존 고객 이탈 방지에 큰 도움이 될 것”이라고 말했다. 6. 50대 꼰대 IT 기자의 ‘알고리즘 뉴스 편집’ 유감50대 꼰대 IT 기자의 ‘알고리즘 뉴스 편집’ 유감 AI와 알고리즘은 이제 포털 뉴스를 규정하는 단어로 자리 잡았고 니콜라스 네그로폰테가 1990년대말 던졌던 ‘나만을 위한 신문(The Daily Me)’이란 개념이 현실 속에서 구현되는 것 같다. 그런데 뉴스에 불어닥친 데이터 혁명은 부작용도 꽤 있는데, ‘평균 회귀’가 대표적이고 대기업 발표나 정부 정책들이 주요 기사로 취급되며, 반면 개별 언론사가 발굴한 ‘뜻밖의 기사’들은 AI 알고리즘에선 제대로 대접받지 못하게 된다. 평균회귀: 일반적으로 두 변수간 상관이 아주 크지 않을 경우, 한 변수에서 극단치를 보인 사례가 다른 변수에서는 덜 극단적인, 즉 평균에 가까운 값을 보이는 통계적 성질이 있다.= 극단적이거나 이례적인 결과는 많은 자료를 토대로 할 때 결국 평균에 가깝게 되돌아오는 경향을 보인다는 개념을 의미한다","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-18-IT_News/"},{"title":"2021년 3월 16일 화요일 IT뉴스","text":"​ 1. 지난해 데이터산업 규모 19.3조…데이터경제 가속화지난해 데이터산업 규모 19.3조…데이터경제 가속화 지난해 데이터산업 시장규모는 전년 대비 14.3% 증가한 19조2736억원으로 예상됐고, 대분류로 보면 데이터 판매 및 제공 서비스업이 9조3752억원으로 가장 큰 매출 비중(48.6%)을 차지했으며 데이터 구축·컨설팅 서비스업이 7조44361억원(38.6%), 데이터 처리·관리 솔루션 개발·공급업이 2조4623억원(12.8%) 순으로 나타났다. 향후 5년간 현재 직무별 인력과 추가로 필요한 인력의 차이를 나타낸 인력 부족률은 데이터 과학자(31.4%)가 가장 높고 데이터 분석가·데이터 개발자(14.5%), 데이터 컨설턴트(10.8%) 순인 것으로 분석됐다. 데이터 판매 및 제공 서비스업(데이터 서비스): 데이터 판매, 정보제공 서비스, 소셜데이터 분석정보 제공 등… 데이터 구축 컨설팅업: DB설계/구축, 데이터 이행, DB성능 개선 컨설팅, 데이터 분석/활용 컨설팅 등… 데이터 처리 및 관리 솔루션 개발 공급업(데이터 솔루션): 데이터 수집, DBMS(데이터베이스 관리 시스템), 데이터 분석(정형/비정형, 실시간 등 데이터 분석), 데이터 관리, 데이터 보안, 등.. 2. SK텔레콤, AI·클라우드 활용 소상공인 지원SK텔레콤, AI·클라우드 활용 소상공인 지원 SK텔레콤은 KFA(한국프랜차이즈산업협회) 회원사에 상권 특성·입점매력도를 분석해주는 상권 분석 솔루션 ‘맵틱스(Maptics)’와 AI상담기능 등으로 고객 접점을 확대할 수 있는 ‘AI 컨택센터(AI Contact Center)’ 서비스를 제공한다. 이용익 SK텔레콤 클라우드 사업개발 담당은 “SK텔레콤 데이터 기반 고객분석 역량과 AI· 클라우드 기반 고객상담 서비스를 제공할 것”이라며 “중소기업과 소상공인의 디지털 경영활동을 지원해 ESG 경영에 앞장설 것”이라고 말했다. ‘맵틱스’는 SK텔레콤 빅데이터를 기반으로 지역 상권특성과 시간대별 유동인구, 상주 인구의 관심사 등 종합적 분석 서비스를 제공한다. AI 알고리즘을 통해 매장 최적 입지 선정을 지원하는 기능을 제공한다. ESG(ESG 경영): ‘Environment’, ‘Social’, ‘Governance’의 머리글자를 딴 단어로 기업 활동에 친환경, 사회적 책임 경영, 지배구조 개선 등 투명 경영을 고려해야 지속 가능한 발전을 할 수 있다는 철학을 담고 있다. 3. 비대면 업무 많아지자 기업 정보보호 예산도 늘었다비대면 업무 많아지자 기업 정보보호 예산도 늘었다 과학기술정보통신부와 한국정보보호산업협회는 정보보호 예산을 편성하고 있다고 응답한 기업이 2019년 32.3%에서 2020년 61.8%로 29.5%포인트나 늘었고, 정보보호 서비스를 이용하는 기업도 2019년 42.5%에서 2020년 69.5%로 27%포인트 증가했다라는 2020년 정보보호 실태조사 결과를 16일 발표했다. 기업들은 네트워크 보안, 시스템 보안, CCTV, 생체인식 등 인증보안 제품을 이용했고, 정보보호 서비스로는 인증서 서비스, 유지관리, 교육훈련, 보안관제 등 서비스를 이용한 것으로 나타났으며, 과기정통부 손승현 정보보호네트워크정책관은 “기업들의 정보보호 예산 수립률이 증가한 점은 긍정적으로 평가할 만하다”며 “비대면 업무환경이 일상화되는 상황에서 기업과 국민들이 정보보호에 많은 관심을 가져주셨으면 한다”고 말했다. 4. 폭스바겐의 이 한마디, 한국 전기차 배터리에서 벗어나겠다?[퓨처클립]폭스바겐의 이 한마디, 한국 전기차 배터리에서 벗어나겠다?[퓨처클립] 폭스바겐은 유럽에 40GWh 규모 공장 6곳을 건설해 총 240GWh 규모의 생산능력(1년 동안 전기차 960만대를 생산할 수 있는 규모)을 갖출 계획이며, 2025년부터 배터리를 직접 생산할 계획이라고 밝혔다. 이외에 폭스바겐은 2023년 자사 전기차에 탑재할 새로운 셀을 선보이며 이 셀은 파우치형 또는 원통형이 아닌 각형이 될 전망이고, 중국 CATL과 폭스바겐 자체 투자기업인 노쓰볼트가 납품할 것으로 알려졌으며, LG에너지솔루션과 SK이노베이션의 배터리는 서플라이 체인에서 제외될 가능성이 커졌다. 서플라이 체인: 공급사슬(supply chain), 공급망은 기업의 공급사슬은 원재료를 획득하고, 이 원재료를 중간재나 최종재로 변환하고, 최종제품을 고객에게 유통시키기 위한 조직 및 비즈니스 프로세스의 네트워크다. 5. “현 위치에서 계속 업무 봐라”…LG폰 사업 운명은?“현 위치에서 계속 업무 봐라”…LG폰 사업 운명은? 스마트폰을 포함한 모바일 사업 전반을 원점에서 재검토하고 있는 LG전자가 최근 모바일커뮤니케이션(MC) 사업본부 내부 직원들에게 “하던 일 계속 하라”라는 메시지를 전달한 것으로 16일 전해졌다. 따라서 “현재 위치에서 하고 있던 일을 계속하라”는 내부 메시지는 일단 인력에 대한 타 부서 이동이나 전환 배치가 당분간 예정되어 있지 않다는 뜻으로 모바일 사업 운영 방향에 대한 최종 결론이 더 길어지거나, 당분간 사업 명맥을 유지하면서 다른 출구를 찾으려는 의미로 해석된다. ■ LG전자 MC사업본부 현황= 2020년 사업보고서에 따르면 LG전자 임직원 수(기간제근로자 제외)는 총 3만8천883명이다. 이중 MC 사업본부 인력은 3천719명으로 전체 인력의 약 9.5% 정도다. H&amp;A사업본부(1만283명), VS사업본부(4천390명) 다음으로 많다. MC사업본부 인력은 과거 5천6천명 수준이었다. 23년 전부터 체질개선을 통한 타 부서 이동과 전환배치로 인력이 절반 가까이 줄었다. 6. “뭐, 두배 준다고?” 금융권 IT인재 유치 난리났네“뭐, 두배 준다고?” 금융권 IT인재 유치 난리났네 카카오뱅크는 올해도 세자릿수 채용을 진행하기 지난 1월부터 부문별로 경력 개발자 공개 채용을 잇따라 진행하고 있고, 올해 출범 예정인 토스뱅크(가칭) 운영사 비바리퍼블리카 역시 대규모 채용을 진행하고 있으며, 정규직 입사자에게는 1억원 가치의 스톡옵션과 전 직장 연봉의 1.5배를 주는 보상정책을 적용한다. 네이버파이낸셜은 개발자 초임을 5000만원까지 인상하고 경력이 하루만 돼도 개발 분야 지원을 받고 있으며, 업계에서는 개발 역량과 금융에 대한 이해도를 고루 갖춘 인재가 귀하다고 입을 모은다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-16-IT_News/"},{"title":"2021년 3월 17일 수요일 IT뉴스","text":"1. 넷플릭스, 2월 역대 최고…’결제금액 725억원·결제자수 501만명’넷플릭스, 2월 역대 최고…’결제금액 725억원·결제자수 501만명’ 앱/리테일 분석 서비스 와이즈앱·와이즈리테일은 올해 2월 넷플릭스의 결제 금액과 유료 결제자 수가 각각 725억원, 501만명으로 역대 최대치로 추정된다고 17일 발표했다. 지난 1년간 결제자가 전연령층으로 확대되어 20대가 31.9%(160만 명), 30대가 27.4%(138만 명), 40대가 21.4%(108만 명), 50대 이상이 19.1%(95만 명)로 변화했다. 2. 애플 ‘아이폰’, 지난해 화웨이 꺾고 2위…1위는 삼성애플 ‘아이폰’, 지난해 화웨이 꺾고 2위…1위는 삼성 지난해 스마트폰 시장에서 미국의 제재로 스마트폰 사업이 축소된 화웨이가 2위였던 시장 점유율이 떨어져 3위였던 애플과 순위가 바뀌었고, 삼성전자는 1위 자리를 유지했지만, 점유율이 19%로 전년(20%)보다 떨어지면서 애플과의 격차가 줄어들었다. 삼성전자는 유럽과 중남미(LATAM), 중동아프리카(MEA) 지역에서 시장 점유율 1위를 차지했고, 유럽에서는 32% 점유율로 2위인 애플(23%)을 따돌렸으며, 중남미에서는 41% 독보적인 점유율을 차지했고, 중동아프리카에서는 화웨이(12%)를 제치고 21% 점유율로 1위를 기록했다. 3. 바이두, 中 첫 로보택시 유료화…상용화 시동바이두, 中 첫 로보택시 유료화…상용화 시동 16일 중국 언론 둥팡차이푸에 따르면 중국 창저우시의 지능네트워크 자동차도로테스트 및 시범운영관리업무팀이 바이두의 ‘아폴로’에 대해 첫 ‘무(無)운전자 자율주행 차량 테스트 통지서’와 ‘자율주행 시범운영 통지서’를 발행했다. 바이두는 지난해 여름 창저우에서 처음 자율주행 자동차 도로주행 테스트를 시작했으며, 이번 허가를 받기 위해 올해 3월 초까지 총 52만3085km(약 32만5030마일)을 테스트했고, 바이두는 창저우 이외 베이징, 후난성 창사 등에서도 무인 자율주행 테스트를 하고 있다. 자율주행 시범운영 통지서는 도시의 개방된 도로에서 상용 지불서비스 테스트가 가능한 면허 4. [1일IT템]이베이코리아 인수전에 유력 후보 카카오 불참 이유는?[1일IT템]이베이코리아 인수전에 유력 후보 카카오 불참 이유는? 17일 관련업계에 따르면 이베이코리아 인수 예비입찰에는 롯데그룹, 신세계그룹, SK텔레콤, MBK파트너스 등이 참여한 것으로 알려졌으며, 카카오는 유력 인수 후보로 거론됐지만 결국 불참했다. 카카오가 이베이코리아 인수전에 불참한 이유로는 거래액 산정 방식이 꼽히고 있는데 이는 이베이코리아의 경우 네이버를 통해 해당 사이트로 들어가 상품을 사는 경우가 많고, 이러한 과정을 밟아 이용자가 상품을 구매하면 네이버와 이베이코리아에 동시에 거래액으로 잡히게 되기 때문에 결국 이용자가 이베이코리아에서 상품을 구매했더라도 네이버는 일종의 플랫폼 수수료 명목으로 매출을 올리는 셈이다. 5. “카카오게임즈, 일괄 연봉인상 없다”…모두가 ‘예스’할때 ‘노’ 외친 남궁훈“카카오게임즈, 일괄 연봉인상 없다”…모두가 ‘예스’할때 ‘노’ 외친 남궁훈 17일 업계에 따르면 남궁훈 카카오게임즈 대표는 지난 16일 사내 메신저를 통해 “올해 일괄적인 연봉인상은 없다”고 공지했으며, 지난 2월부터 진행된 연봉 인상 경쟁서 공식적으로 불참을 선언한 게임사는 카카오게임즈가 처음이다. 남궁훈 대표는 이날 ‘일괄 연봉 인상은 없다’고 밝히면서도 ‘직원 달래기’에도 신중을 기하는 모습이었다. 6. 네이버, 지난해 한진칼에 86억원 투자…항공업계 첫 투자, 왜?네이버, 지난해 한진칼에 86억원 투자…항공업계 첫 투자, 왜? 16일 네이버가 공개한 사업보고서에 따르면 네이버는 지난해 12월21일 85억7300만원을 들여 한진그룹 지주사인 한진칼 지분 0.24%를 확보했다. 회사 측은 “업무 제휴 및 파트너십 강화 차원에서의 출자”라고 설명했고, 구체적으로 네이버와 대한항공은 ‘이용자 경험 증진’을 목표로 Δ대한항공이 보유한 항공서비스 사업 기반과 노하우 Δ네이버의 인공지능(AI)기술과 네이버 클라우드 플랫폼(NCP), 페이, 콘텐츠 서비스 등 디지털 역량을 서로 연계해 다양한 분야에서 이용자 편의성을 향상하고 새로운 가치를 만들어 가기로 했으며, 대한항공은 네이버의 AI 기술과 플랫폼을 이용해 항공권 발권부터 체크인, 탑승까지 이어지는 서비스 흐름을 간편화하고 항공기 기내에서 네이버의 다양한 콘텐츠 서비스가 제공될 수 있도록 준비한다. 7. 라인, 개인정보 관리 미흡으로 日서 도마 위에 올라라인, 개인정보 관리 미흡으로 日서 도마 위에 올라 라인은 서비스에 사용되는 인공지능(AI)이나 시스템의 운용에 사용되는 사내 툴 등의 개발을 중국 상하이에 위치한 관련 회사에 위탁하고 있었는데, 이곳의 중국인 직원 4명이 2018년 8월부터 적어도 32차례에 걸쳐 이용자 이름, 전화번호, 메일 주소 등이 저장된 일본 서버에 접속했다는 것, 이들은 또 라인 이용자들이 주고받은 메시지나 사진 등에도 접속할 수 있었던 것으로 알려졌다. 아사히는 “사회 모든 서비스에 침투하는 라인은 ‘사회 인프라’ 그 자체고, 국민의 70%가 사용하며, 그 안에서 방대한 프라이버시 정보가 교환되고 있다”며 “자신의 개인정보가 해외에 노출된 상태라는 사실을 알게 되면 이용자들은 불안감을 갖게 된다고 했으며 국가가 인터넷을 감시하고 정부에 대한 정보제공을 의무화하는 체제인 중국이라면 더욱더 그렇다”고 꼬집었다.를 고루 갖춘 인재가 귀하다고 입을 모은다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-17-IT_News/"},{"title":"2021년 3월 22일 월요일 IT뉴스","text":"1. ‘실탄’ 두둑한데 이베이 인수전서 발뺀 카카오…’요기요’ 가나요‘실탄’ 두둑한데 이베이 인수전서 발뺀 카카오…’요기요’ 가나요 커머스 업계의 판도를 바꿔놓을 이베이코리아 인수전에서 가장 유력한 후보로 거론된 카카오가 결국 발을 빼면서 또 다른 매물인 배달 플랫폼 ‘요기요’ 인수전에 참전할지 관심이 모아지고 있다. 카카오의 자금력이 충분한 데다, 카카오톡과의 연동을 통해 생활 밀착형 서비스를 중심으로 사업을 확대하고 있는 만큼 필요성만 놓고 보면 충분히 인수를 타진할 수 있다는 평가가 많지만, 요기요 매각에 나선 딜리버리히어로코리아가 1위 배달 플랫폼 ‘배달의 민족’의 새 주인이 된 상황에서 강력한 경쟁자가 될 수 있는 카카오에 매물을 넘기지 않을 것이라는 시각도 많다. 2. [위클리 스마트] 크래프톤 ‘연봉 2천만원 인상’ 그늘엔…’공짜 야근’ 포괄임금제[위클리 스마트] 크래프톤 ‘연봉 2천만원 인상’ 그늘엔…’공짜 야근’ 포괄임금제 크래프톤은 지난해 1~3분기 누적 매출 1조2천370억원, 영업익 6천813억원을 올렸다. 이는 2019년 같은 기간보다 각각 1.78배, 4.27배로 늘어났으며, 개발자는 2천만원, 비개발자는 1천500만원씩 연봉을 올리는 등 직원 대우에서도 이제 ‘3N’에 버금가는 대형 게임사로 자리 잡았다. 그러나 크래프톤은 안팎의 질타에도 유독 포괄임금제를 고수하고 있지만, 파격적인 연봉 인상에 묻혀 포괄임금제에 대한 볼멘소리는 당분간 잦아들지도 모른다. 포괄임금제는 연장근로수당을 비롯한 법정수당을 실제 근로시간에 상관없이 기본급에 포함해 지급하거나, 기본급 외 수당을 시간별로 계산해 주지 않고 정액으로 일괄 지급하는 방식을 말한다. 3. “삼성 갤버즈 프로, 난청환자 일상 대화에 도움”“삼성 갤버즈 프로, 난청환자 일상 대화에 도움” 삼성전자와 삼성서울병원이 공동 진행한 연구 결과에 따르면, 갤럭시 버즈 프로의 주변 소리 듣기 기능이 경도 및 중도 난청 환자들의 듣기 능력 향상에 도움을 줄 수 있는 것으로 나타났고, 이와 관련된 내용은 지난 18일 국제 이비인후과 전문 학술지 ‘CEO(Clinical and Experimental Otorhinolaryngology)’에 게재됐다. 삼성서울병원 이비인후과 문일준 교수는 “인구가 급속히 고령화됨에 따라 2050년에는 10명 중 1명이 난청으로 어려움을 겪을 것으로 전망되지만, 가격 부담 등으로 청각 재활을 필요로 하는 난청 환자들 중 실제 보청기 사용률은 상대적으로 낮을 것”이라며 “이번 연구의 초기 발견은 매우 유용하며, 일상 생활에서 도움을 받을 수 있는 ‘갤럭시 버즈 프로’와 같은 대체 장치를 알려줄 수 있게 됐다”고 말했다. 4. 42조원 가치 ‘로블록스’…게임 만들고 친구와 즐겨42조원 가치 ‘로블록스’…게임 만들고 친구와 즐겨 미국의 게임 플랫폼 ‘로블록스(roblox)’가 3월 10일(현지시각) 뉴욕증권거래소에 상장했다. 기준가 45달러에서 시작한 로블록스 주가는 이날 54.44% 오른 69.5달러로 거래를 마쳤고, 기업 가치(시가 총액)는 371억달러(약 42조원)로 뛰었다. 거리 두기로 집에서 게임하는 아이들이 늘어난 덕분에 신종 코로나 바이러스 감염증(코로나19) 사태가 로블록스 성장에 날개를 달아준것이며, 로블록스의 월간 활성 이용자 수(MAU)는 약 1억5000만 명에 달하고, 이 중 3분의 1은 16세 미만이고, 미국 9~12세 어린이의 3분의 2가 로블록스를 하는 것으로 알려졌다. 로블록스는 사용자가 레고 블록처럼 생긴 자신의 아바타를 이용해 3차원(3D) 입체 가상세계에서 다양한 게임을 즐길 수 있는 플랫폼이다. 사용자가 직접 게임을 만들어 로블록스 플랫폼에 올릴 수 있다. 친구들과 프라이빗 룸을 만드는 소셜미디어(SNS) 기능도 있다. 엔터테인먼트 기능도 빼놓을 수 없다. 미국의 유명 래퍼 릴 나스 엑스가 지난해 11월 로블록스에서 개최한 가상 콘서트에는 이틀 동안 약 3300만 명이 몰렸다. 5. 中 샤오미, 전기차 시장 진출 확정中 샤오미, 전기차 시장 진출 확정 중국 언론 36kr에 따르면 샤오미가 전기차 시장 진출을 확정하고, 이르면 이달 늦어도 내달까지 정식 프로젝트에 착수키로 했으며, 책임자를 선정하고 협력사도 물색하고 있다. 이미 세계 스마트폰 시장 3위에 올라있는 샤오미가 중국에서 인지도를 바탕으로 자동차를 만들 경우 브랜드면에서 강점을 가질 수 있단 판단도 있다. 또 샤오미는 이미 전동킥보드 등 분야에서 모빌리티 사업을 하고 있다. 6. 삼성전자, 전국 400개 초·중학교 교사·학생 대상 소프트웨어 교육삼성전자, 전국 400개 초·중학교 교사·학생 대상 소프트웨어 교육 2013년부터 국내 소프트웨어 교육 저변 확대와 미래인재 양성을 위해 실시하고 있는 ‘삼성 주니어 SW 아카데미’는 올해부터 교육 현장의 수요를 반영해 AI 교육을 실시한다. 이밖에도 삼성전자는 ‘함께가요 미래로! Enabling People’이라는 CSR 비전 아래 ▲삼성 주니어 SW 아카데미 ▲삼성청년SW아카데미 ▲삼성 드림클래스 ▲삼성 스마트스쿨 등 청소년 교육 중심의 사회공헌 활동과 상생 활동을 펼치고 있다. CSR: 기업의 사회적 책임(Corporate Social Responsibility) 기업이 생산 및 영업활동을 하면서 환경경영, 윤리경영, 사회 공헌과 노동자를 비롯한 지역사회 등 사회 전체에 이익을 동시에 추구하며, 그에 따라 의사 결정 및 활동을 하는 것을 말한다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-22-IT_News/"},{"title":"2021년 3월 19일 금요일 IT뉴스","text":"1. “손가락 하나로 가상환경 제어”…페이스북, 차세대 AR글래스 비전 제시“손가락 하나로 가상환경 제어”…페이스북, 차세대 AR글래스 비전 제시 18일 페이스북 리얼리티 랩스(FRL) 연구진은 향후 출시될 차세대 AR글래스의 비전을 컨텍스트 인식 인공지능(AI) 기반의 AR 인터페이스와 디바이스(AR글래스), 그리고 운동신경 신호를 디지털로 변환하는 근전도(EMG) 기반의 손목형 웨어러블 디바이스를 연동한 일상이 가능해질 것이라고 설명했다. 마이크 쉬롭퍼 페이스북 최고기술책임자(CTO)는 실제 상용 시점에 대해 “지금은 초기 연구의 피크 단계”라며 “우선 통제된 환경 내에서 개인이 어떤 느낌을 받을 수 있는지 경험을 증명한 다음 이를 수백만명이 사용할 수 있을 만한 상품으로 제조·판매하기까지는 수년이 걸릴 것”이라고 말했다. 2. 무료서비스로 기반 닦은 플랫폼…”익숙해졌으니 돈 내”무료서비스로 기반 닦은 플랫폼…”익숙해졌으니 돈 내” 모빌리티 서비스인 카카오T(배차 콜 유료 멤버십 도입)와 T맵(데이터 무료 종료)이 유료화 논란에 휩싸였고, 교육현장에서 쓰이는 화상회의 앱 줌(Zoom)의 유료 정책 도입 움직임등 ICT(정보통신기술) 플랫폼 서비스의 잇단 유료화로 곳곳에서 잡음이 터져나오고 있다. 온라인 커뮤니티에선 “무료서비스를 미끼로 고객 데이터를 수집해 유료화 기반을 닦은 뒤 사실상 강제 과금에 나서는 건 소비자 선택권을 되레 침해하는 것”이란 말이 나왔으며, IT 플랫폼사들이 가입자 편익이나 서비스 강화보단 수익모델 발굴에만 매달리는 게 아니냐는 비판이다. 3. 통신3사, 오늘부터 주총 스타트… ‘신사업’ 눈길통신3사, 오늘부터 주총 스타트… ‘신사업’ 눈길 19일 LG유플러스를 시작으로 국내 이동통신 3사가 정기 주주총회를 개최하며, 올해 주총에서 각사는 비대면 시대에 맞춰 사업구조 개편과 신사업 강화 등을 주요 안건으로 내세우며 기업가치 높이기에 나선다. SK텔레콤은 사업·투자회사로 분할하는 방식으로 중간지주사 전환을 추진할 가능성이 높으며,중간지주사 전환을 통해 SK하이닉스를 SK㈜의 손자회사에서 자회사로 끌어올려 사업 운신의 폭을 넓히고, 투자회사는 자회사 상장 등으로 정보통신기술(ICT) 전문기업으로 가치를 높일 수 있기 때문이다. 4. IT 강국의 민낯··· ‘물리보안’에 여전히 크게 밀리는 정보보안, 왜?IT 강국의 민낯··· ‘물리보안’에 여전히 크게 밀리는 정보보안, 왜? 글로벌 정보보호산업 시장 동향과 달리 물리보안 시장 규모가 큰 이유로 업계 관계자는 ▲제조업이 중심인 산업 특성 ▲높은 자영업자 비율 ▲소프트웨어(SW) 유료 이용에 대한 인식 부족 ▲공공 사업 저가 수주 등을 꼽았다. 정보보안산업은 정부 사업의 영향을 받을 수밖에 없는 분야인데, 미국의 경우 연방정부가 정보보안의 최대 고객이고 시장의 50%가량을 정부 사업에 의존하지만, 반면 국내의 경우 정보보안 사업은 들이는 수고에 비해 비용이 턱없이 적은 경우가 다수다. 5. ‘클럽하우스’ 등장한 저커버그 “애플 횡포 심하다”‘클럽하우스’ 등장한 저커버그 “애플 횡포 심하다” 저커버그가 문제 제기한 것은 애플 iOS14에 적용된 개인정보 추적 제한 기능인데, 애플은 iOS14부터 ‘옵트아웃’ 방식으로 돼 있던 개인정보 수집 동의 절차를 ‘옵트인’으로 바꿨다. iOS14에 적용된 정책은 자기 정보에 대한 소비자의 주권을 보장해주는 효과가 있지만 이용자 데이터를 기반으로 광고 비즈니스를 하는 기업들은 큰 타격을 받을 수밖에 없다. 옵트아웃은 동의하지 않는다는 의사 표시를 하지 않는 한 동의한 것으로 간주하는 것을 의미한다. 반면 ‘옵트인’은 이용자가 동의한다고 의사 표시한 이용자에 한해 개인정보를 추적할 수 있다. 6. [OTT온에어] ‘K-OTT’ 디즈니도 버텨낼까…통합·제휴 亞 공략해야[OTT온에어] ‘K-OTT’ 디즈니도 버텨낼까…통합·제휴 亞 공략해야 국내 OTT 플랫폼 통합을 통한 대형화와 ‘아시아 OTT 콘텐츠 제작 허브’역할을 바탕으로 아시아 시장을 공략해 글로벌 OTT 공룡들의 파죽지세 공세에 버텨낼 체력을 길러야 한다는 진단이다. 한편으론 정부규제 이슈 해소 등도 동반돼야 한다는 지적이다. 현재 쟁점인 OTT 사업자에 대한 지위 명확화, OTT에 대한 음악 저작권료 징수 요율 합리화, 넷플릭스 법 세부 규정 마련 등이다. OTT사업자는 방송사업자인지 동영상제공사업자인지 명확화할 필요가 있다. OTT 음악 저작권 징수 규정에 대한 OTT업계의 반발 - 넷플릭스에 적용하는 오율을 국내 OTT에 일괄 적용하는 것은 바람직하지 않다는 주장 넷플릭스 법 세부 규정 마련…예정 - 구체적으로는 이용자의 사용 단말이나 인터넷망사업자(ISP) 등 환경을 차별하지 않고 서비스를 제공해야 한다는 내용, 기술적 오류와 트래픽의 과도한 집중을 막기 위한 사전 조처를 해야 한다는 등 내용이 있다. 요금의 합리적인 결제 수단을 마련해야 한다는 조항도 담겼다. 출처 : https://www.sedaily.com/NewsVIew/22JPSJ1120","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-19-IT_News/"},{"title":"2021년 3월 23일 화요일 IT뉴스","text":"1. 미국인들 “다음에도 아이폰 사겠다”…삼성폰은? [IT선빵!]미국인들 “다음에도 아이폰 사겠다”…삼성폰은? [IT선빵!] 미국 시장에서 애플의 스마트폰 아이폰과 비교해 삼성전자 갤럭시 스마트폰 사용자들의 ‘브랜드 충성도’가 낮은 것으로 나타났고, 갤럭시폰을 사용 중인 전체 응답자의 10명 중 7명만이 다음 스마트폰도 갤럭시폰으로 구입하겠다고 한 반면 아이폰 사용자의 경우엔 10명 중 9명이 다음에도 아이폰을 구입하겠다고 했다. 다만 업계에선 이같은 결과가 비단 삼성전자에만 국한된 것이 아니라 보고 있다. 전반적으로 안드로이드폰 사용자의 브랜드 충성도가 낮아졌단 것이다. 2. 흔들리는 삼성 OLED 아성…아이폰 미니 부진·갤럭시M에는 中 패널흔들리는 삼성 OLED 아성…아이폰 미니 부진·갤럭시M에는 中 패널 애플 아이폰12 미니의 부진으로 삼성디스플레이의 1월 중소형 유기발광다이오드(OLED) 출하량이 전월보다 9%쯤 줄었고, 삼성전자는 인도 시장용 저가 스마트폰 갤럭시M에 원가절감을 이유로 삼성디스플레이 OLED 패널이 아닌 중국 BOE의 것을 장착할 예정이다. 삼성전자의 BOE 채택은 삼성디스플레이로서는 뼈아픈 부분이며, 수주량을 어느 정도 보장해주던 계열사 공급 물량을 따내기 위해 앞으로 BOE와의 가격 경쟁이 불가피하기 때문이다. BOE: 중국의 디스플레이 제조기업. 2003년 현대전자(현 하이닉스)의 LCD 부문인 하이디스를 인수하여 폭발적으로 성장한 끝에 LG디스플레이를 꺾고 전세계 LCD 1위 자리를 차지한 기업이다. 게다가 중국 업계 최초로 플렉서블 OLED 양산에 돌입함으로써 중국뿐 아니라 주요 경쟁국인 대한민국에서도 큰 주목을 받는 기업이다. 3. [IT개발자 구인난] ㊤ 몸값 폭등 아닌 ‘정상화’…”더 오를 수 있다”[IT개발자 구인난] ㊤ 몸값 폭등 아닌 ‘정상화’…”더 오를 수 있다” IT 업계에서 최근 개발자 몸값 상승은 ‘폭등’이 아닌 정상화 수순이라고 이야기 한다. 개발자 부족이 장기화될 전망이 나오면서 인공지능(AI), 빅데이터, 디지털트랜스포메이션(DX) 등 ‘4차산업혁명’에 한국 경제의 경쟁력 강화에 빨간불이 켜졌다는 우려도 제기된다. IT업계 관계자들은 현재의 상황이 몇년간 지속될 가능성이 높다고 말하고,한 스타트업 인사 담당자는 “스타트업이 계속 늘어나는데 개발자 찾기는 더 어려워질 것 같다 “며 “특히 최근에는 AI기술을 활용한 서비스가 늘면서 AI에 대한 이해도가 높은 개발자 자체가 적다”고 말했다. 4. SKT과 우버의 ‘우티’ 협력…서로가 원하는 결과물은?SKT과 우버의 ‘우티’ 협력…서로가 원하는 결과물은? 3일 업계에 따르면 글로벌 차량 공유 기업 우버(Uber)와 SK텔레콤에서 분사한 티맵모빌리티의 합작법인(JV) 우티(UT LLC)는 오는 4월 1일 공식 출범한다. 우티가 운영할 서비스명이나 구체적인 사업 내용은 출범 이후 구체화 될 전망이지만, 당장 양 사가 운영하던 택시 서비스를 통합하고 가맹택시, 대리운전, 퍼스널모빌리티 사업을 전개할 계획이다. 5. 아마존, 헬스케어 영향력 확대…시장 재편 예고아마존, 헬스케어 영향력 확대…시장 재편 예고 세계 최대 전자상거래 업체인 아마존이 최근 헬스케어 사업에 박차를 가하며 시장 공략을 본격화하고 있으며, 아마존은 지난 17일(현지시간) 워싱턴에서만 전개했던 자사 원격 의료 서비스 ‘아마존 케어’(Amazon Care)를 곧 미국 내 전역으로 확대해 기업용 서비스로 전개하겠다고 밝혔다. 이와 함께 아마존이 주력하고 있는 헬스케어 분야는 지난해 11월 출범한 온라인 약국 서비스 ‘아마존 파머시’(Amazon Pharmacy)라고 할 수 있다. 아마존 파머시: 웹 사이트나 앱에서 주문을 받으면 처방약을 배송해주는 서비스다. 6. 홈쇼핑 유사한 ‘라이브커머스’, 규제 형평성 논란홈쇼핑 유사한 ‘라이브커머스’, 규제 형평성 논란 네이버와 카카오뿐 아니라 배달의민족도 뛰어든 라이브커머스. 직접 물건을 보고 사지 못하는 소비자들을 위해 실시간으로 상품을 자세히 소개해주는 홈쇼핑과 유사하지만, 규제 수준에서는 큰 차이를 보이고 있다. 홈쇼핑 방송은 방송법 규제를 받고 있어 조심해야 할 게 많다. 허위·과장된 표현이 있을 경우 방송통신심의위원회의 심의 후 제재를 받게 된다. 이는 추후 있을 재승인 과정에도 영향이 간다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-23-IT_News/"},{"title":"2021년 3월 24일 수요일 IT뉴스","text":"1. 1세대 IT기업 한글과컴퓨터에 노동조합 설립[1세대 IT기업 한글과컴퓨터에 노동조합 설립](1세대 IT기업 한글과컴퓨터에 노동조합 설립 : 네이버 뉴스 (naver.com)) 전국화학섬유식품산업노동조합 한글과컴퓨터지회(지회장 김기홍)는 3월 23일 노조 출범 선언문을 통해 한글과컴퓨터노동조합 ‘행동주의’의 출범을 공식화했다. 한글과컴퓨터지회는 “최근 수년간 업무 문화와 노동환경이 퇴보해왔다”며 설립 이유를 설명했으며, 구체적으로 “매년 불가능에 가까운 일정에 따라야 했고, 포괄임금제라는 미명 하에 대가 없는 야간 근로를 강요받아야 했으며, 충분한 보상 없는 주말 근무로 한 주를 마무리해야만 했다”고 지적했다. 거기에 반해 “구성원들의 이 모든 노력은 개개인에 대한 정당한 보상이 아니라, 극소수를 위한 돈잔치로 돌아왔다”고 비판했다. 2. 네이버, ‘지속가능채권’ 발행…”ESG경영 가속화”네이버, ‘지속가능채권’ 발행…”ESG경영 가속화” 네이버가 5억 달러(약 5643억원) 규모의 5년 만기 ‘지속가능 채권’(Sustainability Bond)을 연간 1.5% 금리로 발행했고,또 전세계 인터넷·IT 기업 가운데 데뷔 채권을 환경·사회·지배구조(ESG) 채권으로 발행하는 것은 최초라고 강조했다. 네이버는 이번 지속가능 채권을 통해 조달한 자금을 친환경 프로젝트와 사회공헌 프로젝트를 중심으로 한 ESG 경영 강화에 주로 활용할 예정이라고 설명했다. ESG 채권은 사회적 책임 투자를 목적으로 발행되는 특수목적 채권이다. ▲친환경 사업 분야에 활용되는 녹색 채권(Green Bond), ▲사회 문제 해결에 사용되는 사회적 채권(Social Bond), 그리고 ▲앞선 두 가지 목적을 결합해 포괄적으로 사용할 수 있는 지속가능 채권(Sustainability Bond) 등으로 구분된다. 3. “디즈니 못 기다리겠다!”…아마존OTT 먼저 한국 상륙 [IT선빵!]“디즈니 못 기다리겠다!”…아마존OTT 먼저 한국 상륙 [IT선빵!] 디즈니 온라인동영상플랫폼(OTT) 디즈니플러스의 한국 서비스 출시가 늦어지고 있다. 연내 한국 시장 진출을 선언했지만, 첫 협력 사업자 선정을 놓고 고심이 길어지고 있으며, 이에따라 SK텔레콤이 협력을 추진 중인 아마존 OTT ‘아마존프라임’이 디즈니플러스에 앞서 한국에 상륙할 가능성에 힘이 실리고 있다. 아마존프라임 서비스와 SK텔레콤의 요금제를 묶어 판매하는 방안 등이 거론된다. T멤버십, 11번가, 아마존프라임 서비스를 아우르는 구독형 서비스 모델도 구상 중이다. 아마존프라임은 아마존 OTT 서비스로 전 세계 약 1억5000만명의 구독자를 보유하고 있다. 넷플릭스(2억4000만명)보다는 적고 최근 구독자 1억명을 넘어선 디즈니플러스와 비슷한 수준이다. 4. “우린 어벤져스 등 막강 콘텐츠 보유…어린이부터 어른 모두 만족시킬 것”“우린 어벤져스 등 막강 콘텐츠 보유…어린이부터 어른 모두 만족시킬 것” : 네이버 뉴스 (naver.com) 올 하반기 한국 상륙을 앞두고 있는 디즈니플러스가 한국 오리지널 콘텐츠 투자를 공식화했고, 미국에서 스타워즈 만달로리안을 서비스 론칭에 맞춰 개시했듯, 한국 제작사가 만든 디즈니 오리지널 콘텐츠를 함께 볼 수 있게 될 전망이다. 디즈니의 ‘21세기폭스’ 인수로 디즈니 패밀리가 된 ‘스타’는 타이타닉, 아바타, 킹스맨 등이 ‘스타’ 브랜드 아래 포함돼 ‘마블’, ‘스타워즈’ 등 브랜드와 어깨를 나란히 하고 있으며, 가족 친화적인 전통적인 디즈니 콘셉트 외에 다양한 연령대의 콘텐츠를 포괄하는 점이 특징이다. 5. 구글 OS 오류에도 사과는 없었다…문제 파악 7시간 후에야 ‘늑장 대처’ (종합)구글 OS 오류에도 사과는 없었다…문제 파악 7시간 후에야 ‘늑장 대처’ (종합) : 네이버 뉴스 (naver.com) 구글의 안드로이드 운영체제를 사용하는 스마트폰에서 정확히 원인을 알 수 없는 애플리케이션(앱) 실행 오류가 발생했지만 회사의 늑장 대응으로 이용자들의 불만이 가중됐다. 이후 구글코리아는 문제를 인지하고 9시간이 지난 시점에 재공지를 통해 ‘웹뷰’와 ‘크롬’ 앱을 업데이트하면 된다는 해결책을 알렸지만 두 번의 공지문에는 모두 이용자 불편에 대한 사과가 빠져 있었고, 오히려 스마트폰 문제라고 착각한 이용자들이 삼성전자 서비스센터에 몰리자 삼성 측은 ‘웹뷰’ 앱을 삭제하면 된다는 임시방편과 함께 “제품 사용에 불편을 드려 죄송하며 빠른 해결을 위해 최선을 다하겠다”고 알렸다. 6. 드디어 움직인 롯데…예상 밖 중고나라 인수드디어 움직인 롯데…예상 밖 중고나라 인수 : 네이버 뉴스 (naver.com) 그동안 이커머스 시장 확장을 위해 별다른 움직임을 보이지 않았던 롯데그룹이 중고나라를 인수하며 국내 중고품 거래 시장에 진출하기로 결정했다. 롯데쇼핑은 급박하게 돌아가는 이커머스 시장 경쟁에 대응하기 위해 중고나라를 인수한 것으로 분석된다. 국내 중고 시장은 2008년 4조원에 불과했으나 지난해 20조원 규모로 성장했고, 최근 어플 등 온라인 플랫폼을 활용한 중고거래도 늘고 있어 시장 전망도 나쁘지 않다. 중고나라는 네이버 카페로 시작해 현재 국내 최대 중고거래 플랫폼으로 성장한 회사다. 네이버 카페 회원수만 2330만명에 달하는 초대형 플랫폼이다. 중고품 거래 시장에 진출하기 위한 최선의 교두보인 셈이다. 7. KT, 1300만 고객 빅데이터로 콘텐츠 ‘공룡’ 꿈꾼다KT, 1300만 고객 빅데이터로 콘텐츠 ‘공룡’ 꿈꾼다 : 네이버 뉴스 (naver.com) KT그룹은 1300만 가입자 기반의 유료방송 서비스에 실시간 채널, OTT, 음원 서비스 등 다양한 미디어 플랫폼을 보유하고 있으며, 여기에 콘텐츠 제작 및 유통 역량과 원천 지식재산(IP) 전문 자회사까지 견고한 포트폴리오를 보유한 대한민국 최대의 종합 미디어 그룹이고 가장 많은 유료방송 가입자를 확보했고 콘텐츠 전문기업 스토리위즈를 설립하고 KTH와 나스미디어의 시너지를 강화 하는 등 개별 그룹사 사업의 내실도 다졌다. KT가 다각도로 분석해 온 1300만 전체 고객의 미디어 시청 빅데이터도 강력한 무기이고, KT의 미디어 빅데이터는 감독, 작가, 출연진 등의 기본 정보와 KT만이 보유한 장면 분석 정보를 결합한 콘텐츠 데이터에 초 단위의 콘텐츠 시청 집중도와 유지율, 콘텐츠 이용 패턴(실시간 방송 유입 및 이탈, TV UI 이용 로그 등)과 같은 시청 데이터를 더하고 인구통계학적 환경을 반영한 시청자 데이터까지 결합해 구성됐으며, 이는 미디어 업계의 일반적인 실시간 방송 시청률 샘플링 데이터의 약 3000배에 달하는 방대한 규모다. KTH: 1988년 다양한 DB개발과 통신 서비스를 제공하기 위해 설립된 정부재투자기관. 나스미디어: 2000년 3월에 설립되어 디스플레이광고를 중심으로 한 인터넷 및 모바일, IPTV, 디지털옥외광고 매체판매업을 주 사업으로 영위하고 있음.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-24-IT_News/"},{"title":"2021년 3월 15일 월요일 IT뉴스","text":"​ 1. 눈동자 자세히 보면 딥페이크 가려낼 수 있다눈동자 자세히 보면 딥페이크 가려낼 수 있다 미국 뉴욕주립대학 연구진들은 최근 딥페이크 이미지를 가려낼 수 있는 눈동자의 반사된 이미지가 일관성이 있는지 확인하는 방법 공개했다.과학자들은 “GAN으로 합성된 얼굴은 두 눈의 각막에서 일관성 없는 반사 빛이 노출될 수 있다”고 밝혔다. GAN(Generative Adversary Network): 적대적 생성 신경망 2. OTT 대세 증명한 넷플릿스…국내 월 사용자 천만명 넘어서OTT 대세 증명한 넷플릿스…국내 월 사용자 천만명 넘어서 국내 넷플릭스 월 사용자가 1000만명을 넘어서며 OTT(온라인동영상서비스) 시장의 대세임을 증명했고, 일사용자수(DAU) 역시 2월 1일 기준 252만1139명으로 전년 동기 대비 1.9배 가량 증가했으며, 앱설치 대비 사용률도 넷플릭스가 72.7%로(2월 사용자 기준) 가장 높게 나왔다.반면, 주요 국산 OTT 앱 월사용자수 합은 지난해 1월부터 일정한 수준을 유지하고 있는 것으로 나타났고, 안드로이드 OS 기준, ‘웨이브’, ‘티빙’, ‘U+모바일tv’, ‘시즌’, ‘왓챠’ 앱의 중복사용자를 제외한 2월 사용자수(MAU)의 합은 595만9726명으로 지난해 1월(597만6838명) 대비 1만7112명 줄어들며 소폭 감소했다. 3. “코로나보다 무서운 랜섬웨어”…日 캡콤, 강제 출근 명령“코로나보다 무서운 랜섬웨어”…日 캡콤, 강제 출근 명령 ‘스트리트파이터’ 개발사로 유명한 일본 캡콤이 랜섬웨어 감염 여파로 원격근무를 중단한 것으로 나타났고, 캡콤 본사는 일본 방역당국이 재택근무를 권고한 오사카에 위치, 강제 출근을 놓고 노사 갈등이 심화하는 중이다.한편, 게임사를 겨냥한 랜섬웨어 공격은 지난 수년간 감행돼 왔으며, 국내 중소 게임 개발사 부나비게임즈는 2017년 랜섬웨어에 감염돼 서비스 중이던 모바일 롤플레잉게임(RPG) ‘파죽지세 영걸전’ 서비스를 종료했었고, 지난해에는 프랑스 게임 개발사 유비소프트와 독일 게임 개발사 크라이텍도 ‘에그레고르’ 랜섬웨어 공격에 당한 바 있다. 4. 지난해 한국 정보보호산업 매출 6.4% 증가··· 코로나19 위기를 기회로지난해 한국 정보보호산업 매출 6.4% 증가··· 코로나19 위기를 기회로 정보보호산업 실태조사는 매년 한국정보보호산업협회(KISIA)가 시장 전망 및 동향을 파악하기 위해 진행하고 있으며 조사 결과 국내 정보보호산업 매출 규모는 전년대비 6.4% 증가한 11조8986억원으로 조사됐고, 정보보안산업은 8%, 물리보안은 5.7% 늘었다.손승형 과기정통부 정보보호네트워크정책관은 “코로나19로 인한 경기 침체로 정보보호산업계도 지난 한해 어려운 시기를 겪었고, 실태조사 결과 역성장이 나올까 우려했는데, 디지털경제 가속화와 비대면 서비스 활성화로 보안의 중요성이 커지면서 성장을 지속했다”고 말했으며,이어서 그는 “정부는 지난해 발표된 디지털 전략을 기반으로 튼튼한 방역 체계 구축을 위해 지난 2월 K-사이버방역 정책을 수립했다. 올해도 정보보호산업이 지속 성장할 수 있도록 지원을 아끼지 않을 것”이라고 말했다. 5. 네이버클라우드, SaaS 기업과 공공 시장 진출 본격화네이버클라우드, SaaS 기업과 공공 시장 진출 본격화국내 소프트웨어 업체 이노뎁(대표 이성진)이 네이버 클라우드 플랫폼 위에서 클라우드 서비스 보안인증(CSAP)을 취득했다고 15일 밝혔다.네이버 클라우드 플랫폼은 IaaS 와 SaaS 보안 인증을 모두 획득한 클라우드이며, 네이버클라우드는 자사의 IaaS를 기반으로 SaaS 인증취득을 원하는 기업들의 인프라 비용을 절감하고, 까다롭고 복잡한 인증 심사과정의 경험과 노하우를 공유하기 위해 작년부터 ‘SaaS 보안인증 상담 프로모션’을 진행하고 있다. CSAP는 한국인터넷진흥원(KISA)이 공공기관에 안정성 및 신뢰성이 검증된 민간 클라우드 서비스를 공급하기 위해 마련한 제도이다. 현재 서비스형 인프라(IaaS)와 서비스형 소프트웨어(SaaS)서비스형 데스크톱(DaaS) 인증으로 구분돼 있다. SaaS 인증 기업은 CSAP 인증을 획득한 IaaS를 활용해야 한다. 이노뎁은 지능형 영상 및 공공 데이터 플랫폼 선도기업 6. 삼성 주요 계열사, 대졸 공채 시작…4대 그룹 중 ‘유일’삼성 주요 계열사, 대졸 공채 시작…4대 그룹 중 ‘유일’15일 삼성전자와 삼성디스플레이, 삼성SDI, 삼성전기, 삼성SDS 등 삼성 주요 계열사는 2021년 상반기 3급(대졸) 신입사원과 인턴 채용 공고를 올렸으며, 신입사원 지원 대상자는 2021년 8월 이전 졸업 또는 졸업 예정자이고, 채용 인원은 공개하지 않았지만 예년 수준인 수천명이 될 것으로 보인다.한편 삼성은 4대 그룹 중 유일하게 신입사원 공채를 유지하고 있으며, 현대차그룹, LG그룹, SK그룹 등 주요 대기업들은 점차 수시 채용으로 바꾸는 추세다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-15-IT_News/"},{"title":"2021년 3월 25일 목요일 IT뉴스","text":"1. 해커들의 새로운 먹잇감, 당신의 자동차가 위험하다해커들의 새로운 먹잇감, 당신의 자동차가 위험하다 자동차 업체들은 해커들의 공격을 막기 위해 막대한 돈을 쏟아붓고 있고, 영국 주니퍼리서치에 따르면 자동차 업계가 해킹을 막기 위해 매년 지출하는 비용은 240억달러(약 27조원)에 이르며, 테슬라는 상금을 내걸고, 자사 차량을 해킹하는 대회를 열고 있다. 이런 문제를 해결하기 위해 자동차 업체들은 모바일 앱, 인포테인먼트 시스템, 와이파이 등 외부와 연결돼 있거나 해킹에 노출되기 쉬운 시스템과 자동차의 속도·조향 같은 제어 시스템을 철저히 분리하고 하여 일부가 해킹되더라도 운전자의 목숨을 위협할 수 있는 치명적인 위협은 막겠다는 것이다. 인포테인먼트 시스템: 정보를 뜻하는 information과 즐거움을 뜻하는 Entertainment의 합성어로 차 안에서 경험할 수 있는 정보시스템을 총칭하는 용어이다. 2. 우체국, 내달부터 ‘핀테크형 해외송금’ 서비스우체국, 내달부터 ‘핀테크형 해외송금’ 서비스 핀테크형 해외송금은 전통적인 스위프트(SWIFT) 방식의 은행권 송금보다 이용이 편리하고 송금속도도 빠른데다 요금도 경제적이어서 최근 급성장하고 있는 서비스이다. 제휴기관으로는 ㈜와이어바알리가 선정됐다. 와이어바알리는 2016년 설립된 핀테크 전문기업이다. 현재까지 누적 송금액 1조원, 가입 고객 32만명을 확보했다. SWIFT (SWIFT)는 국제 형식으로 은행 정보를 송금하고 결제하는 시스템으로 전 세계 1 만 개 이상의 은행과 기업이 가입되어있으며, 회원들은 식별하기 위한 고유 한 SWIFT 코드를 발급받는다. 3. “알리바바 다음은 텐센트” 위뱅크 등 핀테크 사업 ‘먹구름’“알리바바 다음은 텐센트” 위뱅크 등 핀테크 사업 ‘먹구름’ 중국의 반독점 규제 칼날이 이제 중국 인터넷공룡 텐센트를 향하고 있다. 중국 규제당국은 텐센트 산하 모바일메신저 위챗의 이용자 데이터 수집 행위부터 수백개 스타트업에 대한 투자 포트폴리오까지 모두 면밀히 조사하며 텐센트에 대한 관리 감독을 강화하고 있으며, 특히 텐센트의 1200억 달러(약 136조원) 규모 핀테크 사업 앞날에 먹구름이 드리웠다고 블룸버그는 24일(현지시각) 진단했다. 중국 당국은 지난해 말 마윈(馬雲)의 알리바바 그룹을 시작으로 중국 대형 인터넷기업에 대한 유례없는 반독점 규제에 나섰고, 지난해 11월초 앤트그룹 기업공개(IPO)가 불발되었으며, 반독점 규제 우려 속 텐센트 주가는 지난 1월 최고점을 찍은 후 약 20% 빠졌고, 시가총액은 무려 1700억 달러가 증발했다고 블룸버그는 집계했다. 4. “반도체 패권 되찾겠다” 美 IT 공룡들의 역습“반도체 패권 되찾겠다” 美 IT 공룡들의 역습 세계 최대 반도체 기업 인텔이 반도체 파운드리(위탁 생산) 시장에 22조원을 투자해 반도체 시장의 큰손인 마이크로소프트, 반도체 관련 핵심 특허를 다수 보유한 IBM과 반도체 기술도 공동 개발하기로 했다. 인텔의 도전은 대만 TSMC와 삼성전자 등 아시아 반도체 기업들이 장악하고 있는 파운드리 업계에 거대한 지각변동을 몰고 올 수 있으며 특히 애플은 반도체 공급처 다변화 차원에서라도 인텔을 적극 활용할 가능성이 높으며, 반도체 업계 관계자는 “반도체 산업에서 오랜 노하우를 가진 인텔이 작심하고 투자하면 1~2년 내에 삼성과 TSMC의 공정 기술을 따라잡을 것”이라고 말했다. 5. “기술 인재 수시로 뽑는다”…통신업계 ‘탈통신’ 흐름, 인재 확보 경쟁으로 번져“기술 인재 수시로 뽑는다”…통신업계 ‘탈통신’ 흐름, 인재 확보 경쟁으로 번져 통신업계가 기술인재 확보에 적극 나서는 배경으로는 클라우드, 빅데이터, 미디어·콘텐츠 플랫폼 사업 등 신사업 확장이라는 내부 요인 외에 최근 포털, 게임 등 IT 기업의 개발자 쓸어가기라는 외부요인도 작용하고 있다. SK텔레콤은 누구(AI), 가상·증강현실(VR·AR) 등 필요 인력을 충원하기 위한 채용을 진행 중이며, KT는 소프트웨어개발, IT 설계, IT 보안 분야의 인공지능(AI)·빅데이터·클라우드 등 인력 확보에 집중하고 있다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-25-IT_News/"},{"title":"2021년 3월 28일 일요일 IT뉴스","text":"1. 웨이브 “1조 투자”에 판 커진다, 토종 OTT도 ‘쩐의 전쟁’웨이브 “1조 투자”에 판 커진다, 토종 OTT도 ‘쩐의 전쟁’ SK텔레콤은 26일 “웨이브의 콘텐트 경쟁력 강화를 위해 25년까지 총 1조원 규모의 투자를 진행할 예정”이라며“최고 콘텐트 책임자(CCO)를 영입하고, 상반기 내 콘텐트 기획·개발을 전문으로 하는 스튜디오를 설립할 예정”이라고 밝혔다. SK텔레콤은 당분간 독자적인 경쟁력을 강화하고, 글로벌 시장에 진출할 계획이며, 웨이브를 서비스하고 있는 콘텐츠웨이브의 이태현 대표는 “국내 방송사ㆍ제작사ㆍ지식재산권(IP) 보유 기업과 파트너십을 확대하고, 경쟁력 있는 중소 제작사를 발굴해 글로벌 OTT로 키울 것”이라고 말했다. 2. “삼성폰 가져와 아이폰 싸게 줄게” 애플 1위를 노린다 [IT선빵!]“삼성폰 가져와 아이폰 싸게 줄게” 애플 1위를 노린다 [IT선빵!] 애플 아이폰이 본격적으로 점유율 확대를 꾀하고 있으며, 새로운 보급형 아이폰 출시와 함께 삼성 갤럭시로 대표되는 ‘안드로이드폰’ 이용자까지 노리고 있다. 27일 업계에 따르면 애플은 그동안 자사 제품에 한해서만 보상프로그램을 제공해 왔지만, 안드로이드폰을 포함시켰고, 안드로이드폰으로 확대한 것은 아이폰의 시장 점유율을 더욱 확대하기 위한 것으로 보인다. 3. 네이버도 “당근?!” ‘이웃 톡’으로 지역커뮤니티 공략네이버도 “당근?!” ‘이웃 톡’으로 지역커뮤니티 공략 : 네이버 뉴스 (naver.com) 네이버는 지역 이웃이라면 네이버 카페 내 누구나 자유롭게 글을 쓰고 소통할 수 있는 ‘이웃 톡’ 서비스를 출시했다고 27일 밝혔으며, 이웃 톡 서비스는 모바일 웹과 네이버 카페 애플리케이션(앱) ‘이웃’ 탭에서 이용할 수 있다. 현재 위치 기반으로 ‘이웃 인증’을 완료하면 게시글을 작성할 수 있다. 네이버 그룹&amp;CIC(사내독립기업) 김정미 책임리더는 “코로나19 장기화로 취미, 소비 활동 등이 주변 지역 중심으로 이뤄지면서 이웃과 소통하고 싶은 사용자들이 많아지고 있다”며 “네이버 카페의 이웃 톡 서비스를 통해 더욱 자유롭게 주변 이웃들과 동네 정보를 교환하고 이야기를 나눌 수 있기를 기대한다”고 전했다. 4. 야놀자, 숙박예약 넘어 ‘여가 플랫폼’ 도약… B2B로 글로벌 공략 [K-유니콘]야놀자, 숙박예약 넘어 ‘여가 플랫폼’ 도약… B2B로 글로벌 공략 [K-유니콘] 글로벌 여가 플랫폼 기업 야놀자는 국내 기업공개(IPO)는 물론 해외상장도 모색 중이며, 특히 야놀자는 전 세계 170개국에서 운영되는 호텔, 레저시설, 레스토랑 등 2만6000여개 고객사에게 클라우드 기반 호텔관리 시스템(PMS) 등 SaaS(서비스형 소프트웨어)를 제공하며 글로벌 역량을 높이고 있다. 야놀자는 또 올해 완전 통합된 호텔 자동화 솔루션 ‘와이플럭스(Y FLUX)’를 출시한고, 이는 SW를 서버에 직접 설치해 운영하는 기존 온프레미스 방식과 달리 와이플럭스는 호텔의 모든 운영 요소를 클라우드 기반으로 연결해 데이터를 실시간 공유하며, 야놀자 측은 “코로나 펜데믹이 끝나고 다시 여행 수요가 많아지는 시점에 야놀자는 여행의 모든 것을 하나의 플랫폼으로 연결하는 ‘슈퍼앱 전략’으로 해당 수요를 충분히 소화할 수 있다”며 “글로벌 클라우드 기반 PMS 사업자로서도 B2B영역에서 가파른 성장세를 이어갈 것”이라고 강조했다. PMS(Property Management System): 호텔 자산 관리 시스템- 숙박업소 운영 전반에 필요한 객실 판매, 예약, 고객, 재무, 수익률 등을 한 번에 관리 5. 클라우드 속 내 데이터는 안전할까?…”컨피덴셜 컴퓨팅으로 신뢰 확보”클라우드 속 내 데이터는 안전할까?…”컨피덴셜 컴퓨팅으로 신뢰 확보” 힐러리 헌터(Hillery Hunter) IBM 클라우드 CTO는 컨피덴셜 컴퓨팅을 **”컨피덴셜 컴퓨팅(Confidential Computing)은 클라우드에서 신뢰성을 확보하게 해주는 기술”**이라고 설명하며, “기술적으로 컨피덴셜 컴퓨팅은 누군가 클라우드에서 업무를 하면서도 프라이버시를 지킬 수 있게 하는 것”이라고 말했다. 즉 클라우드 위에서 독립적인 공간을 만든다는 것으로 여러 사람과 같이 클라우드에서 일을 하지만, 개인 또는 팀이 원하는 것에 대해서는 독립된 권한을 가지게 되는 것이고, 클라우드 제공자도 개입할 수 없다. 온프레미스(On-Premiss): 클라우드가 아닌 기업이 직접 데이터 서버를 운영하는 것","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-28-IT_News/"},{"title":"2021년 3월 26일 금요일 IT뉴스","text":"1. “혹시 당근이세요?”…’만남의 광장’으로 변신한 중고거래앱“혹시 당근이세요?”…’만남의 광장’으로 변신한 중고거래앱 중고거래업계 관계자는 “코로나19로 인해 재택근무와 원격수업이 확대되며 기존 거래 규모가 작았던 어린이용품, 장난감, 게임, 실내 인테리어 가구의 상품거래가 크게 증가했다”며 신종 코로나바이러스 감염증(코로나19) 아래 중고거래 플랫폼은 급성장을 이뤄냈다. 당근마켓의 경우 중고거래라는 본역할을 넘어 ‘지역 SNS’의 모습을 보이고 있고, 당근마켓은 GPS를 통해 사용자의 지역을 인증하고 최대 반경 6km 이내에서만 거래할 수 있도록 하고 있으며 다소 불편하게 느껴지는 지역제한이 오히려 강점으로 작용했다. 2. 삼성전자 차세대 D램 개발… 1초에 영화 2편 용량 전송삼성전자 차세대 D램 개발… 1초에 영화 2편 용량 전송 삼성전자는 업계 최초로 전송 속도를 7200Mbps로 높인 512GB(기가바이트) 용량의 DDR5 메모리 모듈을 개발했다고 25일 밝혔으며, 반도체 슈퍼사이클(가격 상승)과 맞물려 하반기 상용화에 나설 경우 한국 업체들의 독주에 속도가 붙을 것으로 보인다. 더불어 글로벌 CPU(컴퓨터 중앙처리장치) 시장의 강자인 인텔은 이번 DDR5와 호환이 가능한 제품을 하반기에 내놓을 것으로 알려졌으며, 전날 반도체 파운드리(위탁생산) 분야에 진출을 선언하며 삼성 등을 위협하고 나섰지만, 한편에서는 긴밀한 협력관계를 유지하고 있는 것이다. 3. 스타트업에 꽂힌 네이버…이번엔 푸드테크’스타트업에 꽂힌 네이버…이번엔 푸드테크 2015년 출범한 D2SF는 유망 기술 스타트업을 집중 육성하기 위해 설립됐으며, 창업 초기 기술 스타트업을 발굴해 한 곳당 3억~5억원을 투자한다. 스타트업 투자 확대의 또 다른 목적은 필요한 기술과 인재 확보, 그리고 서비스 개선이며, 네이버는 지난해 컴퓨터 비전 스타트업 비닷두(V.DO)를 인수했고, 2017년 컴퍼니AI도 인수한 사례가 있다. 비닷두는 서울대 석·박사 출신들이 설립한 컴퓨터 비전 분야 AI 스타트업이다. 비닷두 출신은 네이버웹툰의 콘텐츠 경쟁력을 강화하기 위해 여러 웹툰 관련 기술을 고도화하고 있다. 컴퍼니AI 출신 개발자들은 네이버의 AI 플랫폼인 ‘클로바’의 대화형 엔진을 개발하는 데 중요한 역할을 하고 있다. 4. 야놀자, 숙박예약 넘어 ‘여가 플랫폼’ 도약… B2B로 글로벌 공략 [K-유니콘]야놀자, 숙박예약 넘어 ‘여가 플랫폼’ 도약… B2B로 글로벌 공략 [K-유니콘] 글로벌 여가 플랫폼 기업 야놀자는 국내 기업공개(IPO)는 물론 해외상장도 모색 중이며, 특히 야놀자는 전 세계 170개국에서 운영되는 호텔, 레저시설, 레스토랑 등 2만6000여개 고객사에게 클라우드 기반 호텔관리 시스템(PMS) 등 SaaS(서비스형 소프트웨어)를 제공하며 글로벌 역량을 높이고 있다. 야놀자는 또 올해 완전 통합된 호텔 자동화 솔루션 ‘와이플럭스(Y FLUX)’를 출시한고, 이는 SW를 서버에 직접 설치해 운영하는 기존 온프레미스 방식과 달리 와이플럭스는 호텔의 모든 운영 요소를 클라우드 기반으로 연결해 데이터를 실시간 공유하며, 야놀자 측은 “코로나 펜데믹이 끝나고 다시 여행 수요가 많아지는 시점에 야놀자는 여행의 모든 것을 하나의 플랫폼으로 연결하는 ‘슈퍼앱 전략’으로 해당 수요를 충분히 소화할 수 있다”며 “글로벌 클라우드 기반 PMS 사업자로서도 B2B영역에서 가파른 성장세를 이어갈 것”이라고 강조했다. PMS(Property Management System): 호텔 자산 관리 시스템- 숙박업소 운영 전반에 필요한 객실 판매, 예약, 고객, 재무, 수익률 등을 한 번에 관리 5. 클라우드 속 내 데이터는 안전할까?…”컨피덴셜 컴퓨팅으로 신뢰 확보”클라우드 속 내 데이터는 안전할까?…”컨피덴셜 컴퓨팅으로 신뢰 확보” 힐러리 헌터(Hillery Hunter) IBM 클라우드 CTO는 컨피덴셜 컴퓨팅을 **”컨피덴셜 컴퓨팅(Confidential Computing)은 클라우드에서 신뢰성을 확보하게 해주는 기술”**이라고 설명하며, “기술적으로 컨피덴셜 컴퓨팅은 누군가 클라우드에서 업무를 하면서도 프라이버시를 지킬 수 있게 하는 것”이라고 말했다. 즉 클라우드 위에서 독립적인 공간을 만든다는 것으로 여러 사람과 같이 클라우드에서 일을 하지만, 개인 또는 팀이 원하는 것에 대해서는 독립된 권한을 가지게 되는 것이고, 클라우드 제공자도 개입할 수 없다. 온프레미스(On-Premiss): 클라우드가 아닌 기업이 직접 데이터 서버를 운영하는 것","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-26-IT_News/"},{"title":"2021년 3월 31일 수요일 IT뉴스","text":"1. KAIST, 딥페이크 탐지 모바일 앱 ‘카이캐치(KaiCatch)’ 서비스 개시KAIST, 딥페이크 탐지 모바일 앱 ‘카이캐치(KaiCatch)’ 서비스 개시 : 네이버 뉴스 (naver.com) 이흥규 KAIST 전산학부 교수팀이 개발한 딥페이크 및 사진 위변조 탐지 소프트웨어 카이캐치 앱의 첫 화면. [사진 제공 = KAIST] 30일 KAIST는 전산학부 이흥규 교수 연구팀이 인공신경망 기반 딥페이크(deepfake) 탐지와 사진 위변조 탐지 소프트웨어인 ‘카이캐치(KaiCatch)’를 모바일 앱 형태로 개발해 서비스를 시작한다고 밝혔다. 연구팀이 개발한 기술은 딥페이크 생성 유형에 상관없이 딥페이크 여부를 탐지하기 위해 영상의 미세 변형 신호 흔적과 미세 이상 신호 흔적 탐지 기술을 적용한 신호처리 및 인공지능 기술로 개발됐으며, 이러한 핵심 기술들을 사용해, 얼굴 영역의 미세 변형과 코, 입, 얼굴 윤곽 등 얼굴 내 기하학적 왜곡 발생 가능 영역의 이상 신호 흔적을 분석해 딥페이크를 탐지한다. 2. ‘멜론’ 추격하는 ‘유튜브뮤직’…1년새 122만→261만 급증‘멜론’ 추격하는 ‘유튜브뮤직’…1년새 122만→261만 급증 : 네이버 뉴스 (naver.com) ​ (와이즈앱 제공)© 뉴스1 ‘글로벌 IT 골리앗’ 구글의 음원 스트리밍 앱 ‘유튜브뮤직’이 토종 음원 앱 ‘멜론’을 빠르게 추격하고 있는 것으로 나타났다. 가장 많이 사용한 음악 스트리밍 앱은 멜론(510만명)이었고, 그 뒤로는 유튜브 뮤직에 이어 지니뮤직(257만명), 플로(162만명), 네이버 바이브(87만명), 카카오뮤직(46만명), 스포티파이(42만명), 벅스(37만명) 순이었다. 3. “비싼 요금제 쓰는데”…’먹통 5G’에 결국 소송전 돌입하나“비싼 요금제 쓰는데”…’먹통 5G’에 결국 소송전 돌입하나 : 네이버 뉴스 (naver.com) 배민라이더스 배달 오토바이가 줄지어 서있다. 사진=강은구 한국경제신문 기자 egkang@hankyung.com 31일 이동통신 업계에 따르면 5G 일부 소비자들은 현재 이동통신 3사를 대상으로 집단 소송을 준비 중이고, 집단소송 플랫폼 ‘화난사람들’과 네이버카페 ‘5G 피해자모임’ 등에 따르면 현재까지 집단소송 의사를 밝힌 소비자는 약 1만명에 이르며, 이들은 5G 끊김현상, 빠른 배터리 소진, 일부 지역에서만 이용 가능, 4G 대비 고가 요금제 등에 대해 불만을 제기하고 있다. 한 이통사 관계자는 “지난해 코로나 타격 등으로 다소 더디긴 했지만 지난해 서울과 6대 광역시를 시작으로 5G 기지국 구축에 속도를 내고 있다”며 “트래픽이 적은 도서 산간이나 농어촌 지역도 이통사간 공동 기지국 구축으로 커버리지를 빠르게 확대해 계획대로 2022년까지 끊김없는 5G 전국망을 구축할 계획”이라고 말했다. 4. 카카오에 집결한 ‘한게임 사단’…5000억 장전하고 M&amp;A·신사업 ‘승부수’카카오에 집결한 ‘한게임 사단’…5000억 장전하고 M&amp;A·신사업 ‘승부수’ : 네이버 뉴스 (naver.com) 카카오게임즈 제공 © 뉴스1 카카오게임즈가 국내 게임 포털 시장을 장악했던 ‘한게임’ 출신 경영자들을 끌어모으고 있으며, 한게임 창립멤버 및 역대 수장을 요직에 앉혀 과거 한게임 성공신화를 재현하겠다는 김범수 카카오 의장의 청사진으로 풀이된다. 게임과 결합되고 있는 메타버스는 물론, 정욱 대표가 평소 관심이 깊은 소셜카지노 사업도 강화할 것으로 보이며, 카카오게임즈는 이번 주주총회에서 사업목적에 ‘블록체인 기반 응용 소프트웨어 개발 및 공급업’을 추가했다. 5. “노조 만들어 쟁취한다”…IT업계 성과급 논란 ‘노조 설립’으로 번졌다“노조 만들어 쟁취한다”…IT업계 성과급 논란 ‘노조 설립’으로 번졌다 : 네이버 뉴스 (naver.com) 코로나19 사태가 ‘IT업계 호황→개발자 부족→연봉 인상→연봉·성과급 충분치 않은 직원 불만 토로’를 촉발했는데 이것이 이제는 노조 설립으로까지 이어지는 것이며, ‘한국의 실리콘밸리’라 불리는 판교의 IT기업들은 업종 특성상 노조 설립이 활발하지는 않았는데 봄바람처럼 살살 불기 시작한 노조 설립 기조가 강풍으로 변하고 있다. 이에 앞서 지난 25일에는 ‘카카오뱅크’에 인터넷은행 최초로 노조가 설립됐고, 지난 23일 소프트웨어 업체 ‘한글과컴퓨터’에도 2004년 해산된 이후 17년 만에 노조가 재설립됐다는 소식이 알려졌고, LG전자에서도 지난달 25일 사무직 중심의 제3노조가 만들어져 3000명이 넘는 조합원을 모았다. 6. [단독] 한컴-아마존 ‘클라우드PC’ 연합군 뜬다[단독] 한컴-아마존 ‘클라우드PC’ 연합군 뜬다 : 네이버 뉴스 (naver.com) 30일 정보기술(IT)업계에 따르면, 한글과컴퓨터그룹(한컴그룹)은 그룹운영실·해외사업 총괄을 주축으로 아마존웹서비스(AWS)와 DaaS(Desktop as a Service) 기반의 클라우드PC 사업 진출을 추진하고 있으며, 성사된다면 글로벌 클라우드 업체와 국내 소프트웨어 업체가 ‘연합군’을 꾸린 첫 사례가 된다. 클라우드PC 시장은 새롭게 떠오르는 ‘블루오션’이고, 운영체제(OS)와 응용프로그램, 저장 공간 등 컴퓨터 기능의 대부분을 클라우드 환경으로 옮겨버린다는 개념이어서, 솔루션과 저장공간이 중심인 일반 클라우드 서비스와는 다르다. 최소한의 장치만 있는 태블릿이나 스마트폰을 클라우드에 연결해 내 사무실 데스크톱PC처럼 쓰는 게 가능한 반면 비용은 PC 네트워크 구축 금액의 30~40% 수준이라는 게 강점이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-31-IT_News/"},{"title":"2021년 4월 5일 월요일 IT뉴스","text":"1. 카카오 vs 네이버, 글로벌 콘텐츠 무한경쟁카카오 vs 네이버, 글로벌 콘텐츠 무한경쟁 : 네이버 뉴스 (naver.com) 카카오는 래디쉬, 네이버는 왓패드를 앞세워 글로벌 웹소설 플랫폼 경쟁에 나설 전망이다. 카카오가 래디쉬를 인수하는 핵심 이유는 IP 비즈니스이며, 영화, 드라마, 게임 등 다른 장르로 IP를 확장할 수도 있고, 온라인동영상서비스(OTT) 업체에 IP를 판매하는 것도 가능하며, 또한 웹소설 시장에 최대한 빠르게 진입해 네이버에 ‘IP 비즈니스 패권’을 넘겨주지 않기 위해서다. 2. 애플·구글 전방위 로비, 美 인앱결제 강제금지법 저지애플·구글 전방위 로비, 美 인앱결제 강제금지법 저지 : 네이버 뉴스 (naver.com) 애리조나 주는 인앱결제 강제를 금지한 ‘HB2005’ 법을 세계 최초로 통과시키면서 큰 관심을 모았다. 하지만 애플, 구글의 강력한 로비 때문에 결국 이 법이 무산되면서 또 다른 논란이 예상된다. 3. “웨이브서 디즈니 영화 못본다” 韓상륙 앞두고 OTT 제휴 중단“웨이브서 디즈니 영화 못본다” 韓상륙 앞두고 OTT 제휴 중단 : 네이버 뉴스 (naver.com) SK텔레콤과 지상파 3사가 연합한 온라인동영상서비스(OTT) 웨이브에서 다음 달부터 어벤져스, 겨울왕국 등 월트 디즈니의 주요 콘텐츠를 볼 수 없게 된다. OTT 디즈니플러스의 한국 시장 진출을 앞두고 기존 제휴를 정리하고 있는 것으로 분석된다. 4. ‘디도스 사태’ 10년이 지났어도…여전히 허술한 한국 인터넷망‘디도스 사태’ 10년이 지났어도…여전히 허술한 한국 인터넷망 : 네이버 뉴스 (naver.com) 3월24일 디도스 공격으로 네이버 일부 서비스가 중단됐다. 네이버 화면 갈무리 지난달 24일 네이버 포털(이하 네이버)이 서비스거부(Ddos·이하 디도스) 공격을 받아 일부 서비스가 중단돼 이용자들이 불편을 겪는 가운데, 네이버 관계자가 “블로그와 카페 등 일부 서비스 쪽만 당했다. 검색과 온라인쇼핑몰 등 메인 서비스용 아이피(회선)는 공격받지 않았다.”라고 말했다. 이 관계자는 “네이버 대상 디도스 공격은 이전에도 자주 있었지만 잘 막아냈다. 이번 공격은 우리의 대응 능력을 넘는 수준이었다”고 설명했지만, 컴퓨터 보안 전문가들과 누리꾼들 사이에선 이번 사태와 관련해 중요하게 짚어봐야 할 지점이 따로 있다는 지적이 나온다. 5. [단독] ‘웹툰’ 이름 네이버만 쓰나…美日이어 韓서도 상표등록[단독] ‘웹툰’ 이름 네이버만 쓰나…美日이어 韓서도 상표등록 : 네이버 뉴스 (naver.com) 네이버가 국내외에서 ‘웹툰(webtoon)’ 상표권 선점에 나섰다. 이미 미국과 일본 같은 주요 시장에선 상표권을 획득한 것으로 확인됐다. 미국·일본·유럽 시장으로 진출하고 있는 국내 웹툰 플랫폼 기업들은 “네이버가 언제든지 웹툰이란 표현을 쓰지 못하게 할 수 있어 사실상 해외에서 경쟁 사업자를 견제하는 것”이라며 네이버가 추후 문제 삼을 수 있어 노심초사하고 있다. 6. “스마트주문→네이버주문” 확대…수수료 공짜인 ‘비대면주문’ 왜 키울까“스마트주문→네이버주문” 확대…수수료 공짜인 ‘비대면주문’ 왜 키울까 : 네이버 뉴스 (naver.com) 네이버가 ‘네이버 주문’을 본격적으로 확대하기 시작했다. 네이버는 지난 2019년 9월 ‘스마트 주문(당시 QR코드 기반)’이라는 명칭으로 비대면 주문 서비스를 도입한 이후 대부분의 기간동안 수수료를 받지 않고 있다. 돈이 안되는 서비스인데도 네이버가 공을 들이는 것은 네이버페이 이용자 증가로 이어질 수 있다는 점, 특정 음식에 관심을 보이는 이들이 검색한 페이지에서 바로 주문까지 할 수 있도록 할 수 있게 해 검색의 질을 높일 수 있다는 점, 상생할 수 있다는 점 등 복합적인 요인이 작용했고, 특히 네이버페이 결제 시 혜택을 제공하는 방식으로 네이버페이 가맹점을 빠르게 넓힐 수 있다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-05-IT_News/"},{"title":"2021년 3월 29일 월요일 IT뉴스","text":"1. “어차피 개발자들에게 ‘평생직장’은 없다”“어차피 개발자들에게 ‘평생직장’은 없다” : 네이버 뉴스 (naver.com) IT·게임업계 개발자 영입 경쟁이 불붙자 네이버가 ‘비전공자 공채 신설’과 ‘정기적 경력 공채’라는 새로운 전략을 내놓았다. 29일 네이버는 올해 개발자 신규 채용 규모를 역대 최대인 900여명으로 정했다면서, 신입 공개 채용을 연 2회로 늘리고 비전공자 채용·육성 트랙을 신설한다고 밝혔다. 비전공자 트랙이란 대학에서 컴퓨터공학 등 개발 관련 전공을 하지 않았어도 IT 개발자로 자질이 있으면 선발해 개발자로 육성하는 제도다. 추가: 매월 1~10일 경력자를 뽑는 ‘월간 영입’ 프로그램을 신설해 매달 정기적으로 경력 사원을 모집한다. 첫 경력 사원 모집은 다음달 1일부터 시작한다.7월에 입사 예정인 상반기 신입 개발자 공채는 다음달 2일부터 12일까지 네이버 채용 홈페이지에서 모집을 실시하고, 12월에 입사하는 하반기 공채는 9월에 모집을 실시한다. 2. ‘국민비서’ 카카오·네이버, 건강검진·면허갱신 미리 알려준다‘국민비서’ 카카오·네이버, 건강검진·면허갱신 미리 알려준다 : 네이버 뉴스 (naver.com) 카카오와 네이버가 29일부터 국민비서 알림 서비스를 시작하며, 이날부터 제공되는 서비스는 국민건강보험공단 건강검진 안내, 도로교통공단 운전면허 갱신 알림, 경찰청 교통 과태료 납부 안내 등 교통, 교육, 건강 등 3개 분야 8종이다. 한성숙 네이버 대표이사는 “네이버 전자문서 서비스는 앞으로도 사용자가 내게 필요한 생활밀착형 정보를 빠짐 없이 확인할 수 있고 차질 없이 일정을 챙기는 데 도움을 주도록 최선을 다할 것”이라고 말했다. 3. 하이닉스서 나온 매그나칩 중국에 매각 … “여전한 中 반도체 굴기 야욕”하이닉스서 나온 매그나칩 중국에 매각 … “여전한 中 반도체 굴기 야욕” : 네이버 뉴스 (naver.com) 매그나칩반도체 회사 로고. 매그나칩반도체 제공 2004년 하이닉스반도체(옛 SK하이닉스)에서 분사된 매그나칩반도체가 중국에 1조원대로 매각되며, 미국의 집중 견제로 반도체 자립이 어려워진 중국이 자금력을 앞세워 공격적인 해외 반도체 기업 인수에 나선 모양새다. 안기현 한국반도체산업협회 전무는 “매그나칩 인수에 대해 가장 우려되는 부분은 대상이 중국이라는 점으로 결국 중국에 기술과 인력이 넘어가게 될 것”이라며 “이에 따라 디스플레이 쪽에서 중국의 추격이 더 빨라질 수 있다”고 우려했다. 매그나칩: 매그나칩반도체 주요 제품으로는 유기발광다이오드(OLED) 디스플레이 드라이버 구동칩(DDI)과 자동차용 전력 반도체 등이다. 매그나칩반도체의 DDI는 삼성전자에 이어 세계 2위에 올라 있다. 지난해 매출은 5억705만9,000달러(약 5,740억 원), 영업이익은 3,264만5,000달러(약 370억 원) 규모였다. 8,800여 명의 임직원 대부분이 한국인으로 구성된 매그나칩반도체 사업장은 모두 국내에 자리하고 있다. DDI: DDI는 디스플레이를 구성하는 수많은 화소들을 조정해 다양한 색을 구현토록 하는 디스플레이 구동칩이다. 4. 화상회의 피로감에 가상 출퇴근, 노 테크 데이 나선 기업들화상회의 피로감에 가상 출퇴근, 노 테크 데이 나선 기업들 : 네이버 뉴스 (naver.com) 최근 일부 기업들은 화상회의를 줄이려는 노력을 하고 있으며, 마이크로소프트는 다음 달부터 협업툴 ‘팀즈’ 내에 가상 출퇴근 기능(Virtual Commute)을 운영한다. 글은 매주 화요일 밤을 전자기기를 사용하지 않는 날로 삼고 ‘테크기기 없는 화요일(No tech Tuesday)’ 캠페인을 진행하고 있으며, 원격근무가 장기화하고 화상회의 솔루션 등 기기를 통한 비대면 소통이 강조되면서 일과 사생활의 경계가 없어지는 직원들을 위한 처방이다. 5. 클라우드 빌드·배포 등 단순업무, 오픈소스로 한 번에 해결클라우드 빌드·배포 등 단순업무, 오픈소스로 한 번에 해결 : 네이버 뉴스 (naver.com) 김동현 개발자가 깃허브에 공개한 SSM 샌드 커맨드(이미지=깃허브) 29일 만난 앰포의 김동현 개발자는 오픈소스 AWS SSM send-command(이하 샌드커맨드)를 깃허브를 통해 공개했으며, 이를 활용하면 개발자는 AWS 인스턴스에 접속하지 않고도 코드 테스트와 빌드, 배포 등의 업무를 자동으로 처리할 수 있다. 샌드커맨드는 최근 깃허브에 추가된 깃허브 액션스를 활용해 제작됐으며, 김 개발자는 “액션스는 개인 깃허브 저장소에 발생하는 모든 이벤트에 알림을 보내는 일종의 자동화 도구로 아직 많이 알려지지 않았지만 활용범위는 상당히 크다고 생각한다”며 “기존에는 젠킨스를 사용하려 했는데 오래된 기술이라 인터페이스도 불편하고 사용하기 쉽지 않았다”라고 설명했다. Github Action: 소프트웨어 workflow를 자동화할 수 있도록 도와주는 도구공식 홈페이지, 공식 문서","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-29-IT_News/"},{"title":"2021년 4월 2일 금요일 IT뉴스","text":"1. 한성숙 “네이버도 정기구독·당일배송 준비”…이커머스 1등 굳힌다한성숙 “네이버도 정기구독·당일배송 준비”…이커머스 1등 굳힌다 : 네이버 뉴스 (naver.com) 네이버가 상품 정기구독 서비스와 함께 생필품·신선식품 당일·익일 배송 서비스 등을 올해 출시할 계획으로 지분 맞교환으로 혈맹을 다진 CJ대한통운·이마트와의 물류·유통 협력 시너지가 구체화 됐다. 됐다. 한성숙 대표는 “네이버는 이용자·판매자·파트너와 함께 성장하는 이커머스 시장 리더로서 지난해 거래액 28조원을 달성하며 국내 이커머스 1위 지위를 공고히 했다”며 “커머스 사업을 지속 선도하기 위해 5가지 방향에서 계속 앞서 나가겠다”고 짚었다. 5가지 방향은 ▲판매자 솔루션 강화 ▲다양한 구매 방식 지원 ▲멤버십을 통한 파트너십 생태계 확대 ▲데이터 기반 온디맨드 풀필먼트 구축 ▲글로벌 진출이다. 2. 구글, 카카오모빌리티에 투자…빅테크 전쟁 시작됐다구글, 카카오모빌리티에 투자…빅테크 전쟁 시작됐다 : 네이버 뉴스 (naver.com) ​ 카카오모빌리티 투자유치 현황. 그래픽=김영옥 기자 yesok@joongang.co.kr 카카오모빌리티의 전략적 투자 유치는 이번이 처음이며, 이전까지 유치한 7200억원은 자금이 필요해 받은 투자라면, 이번엔 돈 보단 협업 목적이 강하다. 카카오모빌리티는 구글과 클라우드 기반 인공지능(AI) 기술을 고도화하고, 클라우드 사물인터넷 관련 포괄적 협력을 추진하겠다고 밝혔으며, 사용자 경험 향상을 위해 다양한 OS(운영체제) 소프트웨어에 대한 협업도 추진하지만 시장에선 다른 협업 가능성도 거론된다. 3. 패션 업계, AI·테크 만나면 어떤 변화 맞이할까?패션 업계, AI·테크 만나면 어떤 변화 맞이할까? - 코딩월드뉴스 (codingworldnews.com) 세계 최대 산업 중 하나로 언급되는 패션 산업과 테크 산업. 언뜻 보았을 때, 전혀 관계가 없는 분야처럼 보이지만, 미국 유력 경제지 포브스는 인공지능(AI)과 테크가 패션 업계를 180도 바꿀 수 있다고 주장한다. 포브스가 예측한 AI·테크가 패션 업계에 가져올 변화 세 가지를 아래와 같이 설명한다. 1. 머신러닝, 패션 업계 동향 예측한다2. 디지털 모델, 최신 패션 상품 라인 착용3. 미래 패션 업계 및 고객 쇼핑 경험의 변화 4. LG전자, 5일 이사회 개최… 스마트폰 사업 철수 가닥LG전자, 5일 이사회 개최… 스마트폰 사업 철수 가닥 : 네이버 뉴스 (naver.com) ​ LG전자 여의도 본사 전경. /연합뉴스 1일 업계에 따르면, LG전자는 5일 오전 이사회를 열고 모바일(MC)사업본부의 사업 철수를 결정, 발표할 예정인 것으로 알려졌으며, 이에 따라 MC사업본부에 있는 직원 3700여명이 타 부서로 재배치될 것으로 전해졌고, 인위적인 구조조정은 없을 것이란 게 회사 측 방침이다. “이미 지난 1월 LG전자가 스마트폰 사업을 접을 수 있다는 점을 공식화했고, 해당 부서 직원들의 사기가 꺾이고 모든 관련 사업이 중단돼 있는 상황이다”라며 “매각이 완료될 때까지 3000~4000명이나 되는 직원을 모두 끌고 가는 것은 엄청난 비용인 만큼 향후 부분 매각 등 가능성을 염두에 두고 핵심 인력, 지식재산권(IP) 정도만 남겨두고 사업본부를 정리할 것으로 추정된다”라고 했다. 5. ARM, 차세대 아키텍처 ‘Armv9’ 공개ARM, 차세대 아키텍처 ‘Armv9’ 공개 : 네이버 뉴스 (naver.com) ARM이 인공지능(AI)·디지털신호처리(DSP)·보안 성능을 강화한 차세대 아키텍처 ‘Armv9’을 공개했고, 코로나19 대확산으로 산업 전반에서 디지털 전환(DT)이 가속하는 가운데 반도체 설계자산(IP)을 앞세워 시장 지배력을 높이겠다는 뜻으로 풀이된다. ​ (자료=ARM) Armv9은 슈퍼컴퓨터용 명령어 세트인 ‘스케일러블 벡터 익스텐션2(SVE2)’을 지원해 Armv8 아키텍처 보다 빠른 머신러닝(ML)과 DSP 성능을 구현하며, 보안 성능 역시 강화됐다. DSP: 디지털 신호 처리 장치(digital signal processor, DSP)는 디지털 신호 처리를 위해 특별히 제작된 마이크로프로세서로 특히 실시간 운영 체제 계산에 사용된다. 6. ‘IPO 大魚’ 크래프톤 최대주주 노리는 텐센트…“상장 과실은 中 기업에”‘IPO 大魚’ 크래프톤 최대주주 노리는 텐센트…“상장 과실은 中 기업에” : 네이버 뉴스 (naver.com) 중국 최대 게임 회사인 텐센트가 최대주주에 버금가는 지배력을 갖고 있기 때문에 상장을 앞둔 크래프톤에 ‘차이나 리스크’가 커지고 있다. 최근 중국과 분쟁을 겪고 있는 나라가 늘고 있어 향후 성장성이 중요한 기업공개(IPO)에 악재로 작용할 가능성이 크다는 우려가 나오며, 투자은행(IB)업계 한 관계자는 “이미 인도에서 중국과의 갈등으로 곤욕을 겪었고, 미·중 무역분쟁이 장기화하는 상황에서 크래프톤과 텐센트의 관계는 북미 시장 진출 등 향후 사업에 있어 큰 걸림돌이 될 수 있다”고 했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-02-IT_News/"},{"title":"2021년 4월 9일 금요일 IT뉴스","text":"1. [단독] 진격의 카카오, 이베이 대신 1조 유니콘 ‘지그재그’ 인수단독 진격의 카카오 이베이 대신 1조 유니콘 지그재그 인수 | 한경닷컴 (hankyung.com) 8일 투자은행(IB) 및 IT 업계에 따르면 카카오는 국내 1위 여성 의류 온라인쇼핑몰 ‘지그재그’(법인명 크로키닷컴)의 최대 주주에 오를 예정이며, 카카오는 카카오 본사가 신설 자회사를 설립하고, 이 회사와 지그재그를 합병하는 방식의 거래 구조를 고안했다. 그간 카카오커머스 등 쇼핑사업 내에선 경쟁사 대비 품목 다양성을 늘리는 문제를 두고 고심이 깊었고, 카카오 내부적으론 한 때 유사한 구조로 무신사와 합병하는 방안도 고민했지만 무신사의 기업가치가 빠르게 늘면서 지그재그로 선회했고 선물하기·쇼핑하기 등 ‘커머스’ 역량 확대를 고민해온 카카오 입장에서도 최적의 거래라는 평가다. 지그재그: 지그재그는 개발자 출신인 서정훈 대표가 2015년 설립한 패션 플랫폼이다. 이용자가 취향에 맞춰 카테고리를 설정하면, 해당 조건에 맞춰 플랫폼에 입점한 4000곳 이상 업체(Soho)들이 보유한 제품을 한 번에 볼 수 있는 서비스를 고안했다. 2. 애플 “사용자 허락없는 개인정보 추적앱 차단” 페이스북 광고 치명타애플 “사용자 허락없는 개인정보 추적앱 차단” 페이스북 광고 치명타 - 조선일보 (chosun.com) 애플이 이달 중 아이폰 운영체제를 업데이트해 사용자 허락 없이 개인정보를 추적하는 앱을 차단한다.백서에 따르면, 아이폰 업데이트 이후 이용자가 특정 앱을 실행하면 ‘이 앱이 사용자의 활동을 추적하도록 허용하시겠습니까’라는 창이 뜨고, 이용자는 ‘추적 금지 요청’이나 ‘허용’을 선택할 수 있으며, 애플은 더 나아가 설정-프라이버시 탭에서 모든 앱에 대한 추적을 일괄적으로 거절할 수 있는 기능도 넣을 예정이다. 3. [팩플] 회원 3200만 싸이월드 부활한다는데···돈·기술 어디에?[팩플] 회원 3200만 싸이월드 부활한다는데···돈·기술 어디에? : 네이버 뉴스 (naver.com) 3200만 회원 싸이월드가 부활한다는데, 기대와 함께 의혹도 부풀었고, 업계에서는 ‘돈과 기술은 있나’, ‘회사의 실체가 뭐냐’라고 묻는다. 싸이월드는 모바일 대응이 느려 2010년대 들어 쇠락했고 주인이 수차례 바뀌었으며, 서버 비용을 못 내 지난해 사이트가 닫혔던 싸이월드를 다시 열겠다고, ‘싸이월드Z’가 서비스 운영권을 10억원에 인수했으며, 싸이월드Z는 5개 회사가 컨소시엄을 이뤘다고 밝혔지만, 이 중 이름을 공개한 곳은 2개사 뿐이다. 두 곳 모두 코스닥 상장사인데, 싸이월드 투자에 대해 공시한 건 없다. 컨소시엄(consortium)은 2가지 이상의 개인 또는 회사, 단체, 정부의 협동체(협회)로 공통의 활동에 참여하는 목적을 지니며 공통의 목적을 달성하기 위해 그들의 자원을 투입한다. 4. 쏘카, 종합 모빌리티 전쟁 승기 잡는다 [K-유니콘]쏘카, 종합 모빌리티 전쟁 승기 잡는다 [K-유니콘] : 네이버 뉴스 (naver.com) 모빌리티 업계 첫 ‘유니콘(기업가치 1조원 이상 비상장기업)’인 쏘카는 내년 기업공개(IPO)를 앞두고 기술 역량과 사업 포트폴리오를 강화하고 있다 쏘카 주력사업인 차량공유(카셰어링) 운영 효율성을 높여 수익성을 개선하고 있으며, 차량구독 서비스 ‘쏘카패스’와 장기렌트 형태 월 단위 차량공유 서비스 ‘쏘카플랜’ 등을 운영 중이고, 또 쏘카 자회사 VCNC는 △가맹택시 ‘타다 라이트’ △고급택시호출 ‘타다 플러스’ △대리운전 중개 ‘타다 대리’ 등을 통해 모든 이동에 정보기술(IT)을 융합하며 사업을 확대하고 있다. 5. 12번째 한국 유니콘 ‘센드버드’를 만든 ‘API 이코노미’12번째 한국 유니콘 ‘센드버드’를 만든 ‘API 이코노미’ : 네이버 뉴스 (naver.com) 우아한형제들(배달의민족), 넥슨, SSG닷컴, KB국민은행, 중고나라, 레딧, 야후…분야는 각기 달라도 널리 알려진 이들 기업에는 모두 센드버드의 채팅 플랫폼을 도입했다는 것이라는 한 가지 공통점이 있다. 앞서 유니콘이 된 우아한형제들이나 쿠팡은 모두 대중에 널리 알려진 B2C(기업·소비자간거래) 기업이다. 이와 달리 센드버드처럼 기업만을 대상으로 서비스를 제공하는 B2B(기업간거래) 기업이 유니콘에 오른 건 국내 스타트업 사상 처음 있는 사례로 더욱 눈길을 끈다. 6. 인생술이 집으로 온다…’술담화’ 창업 스토리인생술이 집으로 온다…’술담화’ 창업 스토리 : 네이버 뉴스 (naver.com) ‘찾아오는 인생술’이라는 문구를 내건 전통주 구독 서비스 ‘술담화’는 2018년 설립됐고, 술담화 ’담화박스’는 2천 개 종류 전통주 중 테마에 맞게 선별돼 페어링 안주, 큐레이션 카드와 함께 매달 소비자에게 제공된다. 그는 외국에서 우연히 ‘우리술 대축체’에 참여했고, 처음으로 희석식 소주와 맥주를 제외한 한국 술을 마신후, 너무 맛있어서 온라인에서 전통주를 구매해봤는데, UI/UX(사용자 환경과 경험)가 너무 불편했고 큐레이션 역시 너무 부족해 구매를 포기했고, 반년 뒤, 시장이 전혀 바뀌지 않은 것을 보고 전통주 관련 창업을 하기로 결심했습니다.”","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-09-IT_News/"},{"title":"2021년 4월 7일 수요일 IT뉴스","text":"1. 투자하면 대박 …금융권, 핀테크 기업에 반했다투자하면 대박 …금융권, 핀테크 기업에 반했다 : 네이버 뉴스 (naver.com) [이데일리 이동훈 기자] 쿠팡에 이어 두나무의 미국 증시 상장설이 솔솔 피어오르면서 핀테크 기업에 대한 지분 투자가 관심사로 떠오르고 있다. 한화투자증권, 우리기술투자 등이 두나무 상장 수혜 기대감에 연일 급등세를 이어가고 있고, 본인신용정보관리업(마이데이터) 본격화에 힘입어 기업가치가 커질 것으로 보이는 토스·뱅크샐러드 등에 투자한 업체들도 잭팟을 기대하고 있다. 2. 삼성 vs 애플, 120조 웨어러블 시장에서도 ‘격돌’삼성 vs 애플, 120조 웨어러블 시장에서도 ‘격돌’ : 네이버 뉴스 (naver.com) 웨어러블 기기 시장이 만개하기 시작했다. /사진제공=각 사, 그래픽=김민준 기자 스마트폰 시장이 포화 상태에 이르러 성장세가 점차 둔화되면서 IT기업도 다방면으로 돌파구를 찾고 있다. 폴더블·롤러블 등과 같은 폼팩터 혁신뿐 아니라 스마트폰 기반으로 생태계를 이루는 이어폰과 워치 등 각종 기기의 영역 확장도 이뤄지고 있다. 3. 삼성SDS ‘클라우드·공정 보안’ 주목…황성우 체제 첫 대외 행사삼성SDS ‘클라우드·공정 보안’ 주목…황성우 체제 첫 대외 행사 : 네이버 뉴스 (naver.com) 서재일 삼성SDS 보안사업부장(전무)이 6일 온라인으로 개최된 ‘사이버 시큐리티 콘퍼런스 2021’에서 환영사를 하고있다. /사진=삼성SDS 삼성SDS가 황성우 대표이사 취임 후 처음 개최한 대외행사인 이날 행사에서는 비대면 업무환경 보안과 클라우드 보안, 생산설비·제조공정(OT) 보안 등 3가지 최신 사이버 보안이 집중적으로 다뤄졌다. 삼성SDS의 보안 관련 사내벤처들의 소개도 이뤄졌으며, ‘팀나인’은 인공지능(AI)을 활용한 사진·영상·음성 합성 기술인 딥페이크를 탐지할 수 있는 솔루션을 발표했고 ‘해킹존’은 보안 취약점을 신고하고 포상하는 제도인 ‘버그바운티’ 관련 플랫폼을 발표했다. 4. ‘가상 공간에서 홀로그램 회의를?’… 스페이셜로 보는 ‘메타버스’의 현주소‘가상 공간에서 홀로그램 회의를?’… 스페이셜로 보는 ‘메타버스’의 현주소 : 네이버 뉴스 (naver.com) 스페이셜을 통해 회의를 진행하고 있는 예시. 제공=페이스북 코로나 19라는 불가항력적인 요인으로 사무실 근무가 어려워지면서 많은 기업이 재택근무를 위한 솔루션을 도입함으로써 네트워크나 인프라를 대체하기 시작했다. 하지만, 재택근무는 대화 과정이 이메일이나 메신저로 옮겨가면서 누락되고, 여기서 오류가 발생할 수밖에 없었고,…최근에는 기술을 활용해 이 부분까지 극복하려는 조짐이 관측되고 있다. 5. 업계, “LG전자 스마트폰 철수 여파 ‘미미’”…왜? [IT클로즈업][업계, “LG전자 스마트폰 철수 여파 ‘미미’”…왜? IT클로즈업] : 네이버 뉴스 (naver.com) LG전자는 “프리미엄 휴대폰 시장은 양강체제가 굳어지고 주요 경쟁사는 보급형 휴대폰 시장을 집중 공략하는 가운데 LG전자는 대응 미흡으로 성과를 내지 못해왔다”라며 “이 같은 시장 상황 속에서 선택과 집중을 통해 내부 자원을 효율화하고 경쟁우위를 확보할 수 있는 핵심사업에 역량을 집중한다”라고 설명했다. 스마트폰 사업 중단은 LG전자 실적 개선으로 이어질 전망이고, 거래선과 협력사 피해는 크지 않을 것으로 예상되며, 국내 스마트폰 점유율은 삼성전자와 애플이 양분할 것으로 여겨지지만, 현재 LG전자 스마트폰을 쓰고 있는 사람은 불편이 불가피하다. 6. 코로나로 원격수업하자 독서줄고 PC사용량 늘었다코로나로 원격수업하자 독서줄고 PC사용량 늘었다 : 네이버 뉴스 (naver.com) 2020년 청소년의 시간대별 이용매체[KISDI 제공. 재판매 및 DB 금지] 신종 코로나바이러스 감염증(코로나19) 확산으로 온라인 원격수업이 시작되자 청소년들의 종이 매체 이용은 줄고 PC 이용이 증가한 것으로 나타났다. 이에따라 청소년의 독서 시간도 감소했고, 데스크톱과 노트북, 태블릿PC 이용 시간은 모두 1시간 이상 증가했지만, 하루평균 스마트폰 사용시간은 162분으로 전년(143분)과 크게 차이가 없는 것으로 파악됐다. 7. 동네친구 된 IT… 중고거래서 취업까지 해결동네친구 된 IT… 중고거래서 취업까지 해결 : 네이버 뉴스 (naver.com) 코로나 팬데믹(대유행)이 장기화되면서 좁아진 사람들의 생활 반경에 맞춘 ‘하이퍼로컬(hyper-local) 서비스’가 뜨고 있다. 하이퍼로컬의 시대가 다시 돌아온 것은 사용자 위치를 정확하게 파악해 지역 기반 맞춤형 정보를 제공하는 IT 업체들이 속속 등장하면서부터이며, 국내에선 하이퍼로컬 앱의 원조인 당근마켓에 네이버가 도전하고 있고, 유통 대기업 롯데도 동네 상권 공략을 위해 지역 기반 중고거래 사이트 ‘중고나라’를 인수했으며, 미국에서는 기업 가치 5조원이 넘는 하이퍼로컬 스타트업(초기 벤처기업)까지 등장했다. 하이퍼 로컬(Hyperlocal): ‘범위가 좁은 특정 지역에 맞춘’이란 뜻. 코로나 이후 사람들의 생활 반경이 좁아져 동네 상권을 중심으로 한 서비스가 늘면서 주목받고 있는 개념으로 상거래뿐 아니라 동네 기반 온라인 커뮤니티 기능도 아우른다. 예전 ‘벼룩시장’ 같은 지역 정보지와 전단이 타깃으로 삼았던 게 하이퍼로컬 시장이다. 당시엔 사람 구하는 일, 중고거래나 중고차 매매도 모두 동네에서 해결하는 게 당연했다. 하지만 동네를 초월하는 인터넷과 전국 익일 배송 서비스가 확산하면서 급속히 사라졌다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-07-IT_News/"},{"title":"2021년 4월 12일 월요일 IT뉴스","text":"1. [단독] 카카오, 북미 최초웹툰 타파스 인수…美서 네이버와 격돌[단독] 카카오, 북미 최초웹툰 타파스 인수…美서 네이버와 격돌 - 매일경제 (mk.co.kr) 카카오가 웹소설 플랫폼 래디쉬와 함께 북미 콘텐츠 시장을 본격 공략하기 위해서 콘텐츠 자회사 카카오엔터테인먼트를 통해 북미 첫 웹툰 플랫폼을 운영하는 타파스미디어 경영권 인수를 추진한다. 카카오 군단이 북미로 출격을 준비하면서, 네이버와의 콘텐츠 경쟁도 더욱 치열해질 전망이며, 국내에선 양 사가 웹툰, 웹소설, 음악, 영상까지 전방위적인 경쟁을 벌이고 있고 세계 최대 만화 시장인 일본에선 후발 주자로 시작한 카카오가 자회사 카카오재팬의 콘텐츠 플랫폼 픽코마를 앞세워 라인망가(네이버의 일본 웹툰 서비스)를 제치고 매출 기준 1위를 차지했다. 타파스: 김창원 대표가 2012년 미국에서 설립한 타파스미디어는 북미 최초 웹툰 플랫폼 타파스를 운영하고 있다. 2. 당근마켓, 일주일에 천만명 넘게 쓴다…93%가 구매자 겸 판매자당근마켓, 일주일에 천만명 넘게 쓴다…93%가 구매자 겸 판매자 : 네이버 뉴스 (naver.com) 12일 당근마켓에 따르면, 이 앱은 지난달 기준으로 주간 활성 이용자 수(WAU·Weekly Active Users)가 1천만명을 돌파했다. 당근마켓 김용현 공동대표는 “환경과 자원 재사용의 중요성도 커지면서 어느덧 중고 거래 이용자 1천만명 시대가 열렸다”며 “지역의 가치 있는 정보·소식을 연결하고 생활 편의를 높이는 하이퍼로컬 시장의 선두 주자로 혁신을 거듭할 것”이라고 말했다. 3. 클럽하우스, 차세대 SNS 아닌 ‘반짝’이었다…”Z세대 놓친 탓”클럽하우스, 차세대 SNS 아닌 ‘반짝’이었다…”Z세대 놓친 탓” : 네이버 뉴스 (naver.com) ‘신드롬’에 가까운 반응을 자아내며 혜성처럼 등장했던 오디오 소셜미디어(SNS) ‘클럽하우스’가 약 두 달 만에 이용자들의 외면을 받고 있고, 12일 IT업계에 따르면, 클럽하우스는 3월 이후로 국내 활성 이용자(Active Users)가 대폭 줄어든 상태다. 전문가들은 클럽하우스가 iOS용만 있고 아직도 안드로이드용 앱을 내놓지 않은 것이 인기 하락의 기본적인 이유라고 입을 모으며, SNS 전문가들은 클럽하우스가 ‘Z세대’(Gen Z·Generation Z)를 잡지 못한 것이 부진 요인의 핵심이라고 말한다. 4. [나는개발자다] 게임 공략법 분석하던 유튜버, 샌드박스 ‘개발리더’ 되다[나는개발자다] 게임 공략법 분석하던 유튜버, 샌드박스 ‘개발리더’ 되다 : 네이버 뉴스 (naver.com) 지난 8일 서울 용산구 샌드박스 본사에서 만난 노성산 샌드박스 CX·CT팀 총괄 디렉터(팀장)&lt;사진&gt;는 샌드박스 개발자의 첫 번째 덕목으로 미디어와 콘텐츠에 대한 애착을 꼽았다. MCN 소속으로서 당연하다고 하면 당연할 수 있겠지만, 기술력 바탕의 개발 중심 조직에 익숙한 개발자들이라면 다소 의아해 할 수 있는 답변이다. 노 팀장은 “능력 좋고 코드를 잘 짜는 개발자들과도 일해봤지만 오히려 개발만 생각하다보면 비즈니스에 독이 되는 경우를 많이 봤다”며 **“우리 팀의 가장 이상적인 그림은 신입사원이라도 개발자 한명 한명이 자신이 맡은 프로젝트에 대해서는 모두가 창업자 정신으로 오너십을 가지는 것”**이라고 강조했다. CS: 고객경험, 서비스 CT: 문화콘텐츠 기술 5. 넷플릭스는 왜 스파이더맨 붙잡았을까…콘텐츠 투자 가속페달넷플릭스는 왜 스파이더맨 붙잡았을까…콘텐츠 투자 가속페달 : 네이버 뉴스 (naver.com) 넷플릭스는 온라인동영상서비스(OTT) 시장 경쟁자인 디즈니플러스와 HBO, 애플TV, 아마존프라임 등의 견제와 공세에 대응하려면 ‘콘텐츠 확보만이 살 길’이라는 판단을 내려, 스파이더맨과 베놈 등을 거느린 소니픽처스와 손잡고 콘텐츠 투자에 가속 페달을 밟는다. 넷플릭스는 코로나19 반사이익으로 얻은 성장기가 끝나가는 만큼 내실을 다지겠다는 것으로 과감한 콘텐츠 투자와 함께 요금인상으로 수익성 강화에도 본격적으로 나서고 있다. 6. [개발자 쟁탈전]② 판교역 ‘이직의 다리’를 아시나요?[개발자 쟁탈전]② 판교역 ‘이직의 다리’를 아시나요? : 네이버 뉴스 (naver.com) 판교역 지상 ‘이직의 다리’로 불리는 공중 연결통로. /사진 = 장도민 기자 © 뉴스1 판교에는 ‘이직의 다리’라고 불리는 판교역 지상에 위치한 크래프톤타워와 알파돔타워를 연결해주는 공중 연결통로가 있다. 네이버와 넥슨, 크래프톤, 엔씨소프트 등 대형 IT기업들이 줄줄이 ‘개발자 모시기’에 나서면서 최근 ‘귀하신 몸’이 된 개발자들의 위상이 날로 높아지고 있기 때문에 최근 판교에는 개발자들을 중심으로 이직의 다리를 건너려는 분위기가 확산될 조짐이 보인다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-12-IT_News/"},{"title":"2021년 4월 14일 수요일 IT뉴스","text":"1. 네이버·카카오 新사업 질주…비결은 M&amp;A ‘스타트업 군단’네이버·카카오 新사업 질주…비결은 M&amp;A ‘스타트업 군단’ : 네이버 뉴스 (naver.com) 카카오엔터프라이즈는 지난해 인수한 스타트업인 리모트몬스터의 기술을 활용하여 1인 방송, 실시간 온라인 방송, 화상 회의, 웨비나, 라이브커머스까지 모든 생중계 동영상을 쉽게 유통할 수 있는 클라우드 기반의 라이브 스트리밍 플랫폼인 ‘카카오 i 커넥트 라이브’를 최근 내놨다 네이버는 인재 확보를 위해 스타트업을 사들이고 있으며, 네이버는 지난해 서울대 석·박사 출신들이 설립한 컴퓨터 비전 분야의 인공지능(AI) 스타트업인 비닷두를 인수하여 이들은 네이버웹툰의 콘텐츠 경쟁력을 강화하기 위해 여러 웹툰 관련 기술을 고도화하고 있다. 2. 북미서 웹툰 전쟁…유튜브식 네이버, 넷플릭스식 카카오?북미서 웹툰 전쟁…유튜브식 네이버, 넷플릭스식 카카오? : 네이버 뉴스 (naver.com) 웹툰은 한국에서 시작해 일본과 동남아 각국에서 카카오와 네이버의 웹툰 플랫폼이 만화앱 매출 1위를 다투고 있을 정도로 해외에서 인증받은 콘텐트이며, 특히 이들 플랫폼이 작심하고 만든 ‘자체 IP’의 수익성이 탁월하다. 네이버·카카오 모두 국내 최대 플랫폼사이며, 플랫폼에 모여든 창작자와 사용자가 많으면 많을수록, 플랫폼 수익도 늘어난다는 걸 누구보다 잘 알고 있기 때문에 전세계 각국 웹툰·웹소설 이용자의 구미에 맞는 콘텐트를 다양하게 구비할 수 있다면, ‘웹툰계의 넷플릭스’ 혹은 ‘웹툰계의 유튜브’가 되지 말란 법 없다. 더 넓게는, 유튜브처럼 웹툰 소비자를 창작자로 끌어 들여 ‘웹툰 크리에이터 플랫폼’을 만들 수도 있다. 어느 쪽이든 콘텐트와 사용자가 많을수록 플랫폼 이익도 커진다. 왓패드: 웹소설계의 유튜브다. 아마추어 작가가 자유롭게 작품을 올리고, 독자에게 선택을 많이 받으면 히트작이 된다. 대부분 무료 작품이란 점까지, 네이버 도전만화와 비슷하다. 누구나 들어올 수 있게 판을 깔고 소비자 선택을 지켜보는 네이버의 플랫폼 전략과 닮았다. 래디쉬: 프로페셔널 작가군단이 데이터 기반으로 ‘히트작’만 골라쓴다. 인기 많은 작품일수록 연재횟수를 빠르게 늘리는 등 ‘미리보기’에 기꺼이 지갑을 여는 코어 팬덤을 구축하는 데 능하다. 자체 IP(오리지널)에 투자하고 콘텐트 값을 받는 넷플릭스와 유사하다. 3. 유튜브뮤직 VS 지니뮤직, 음원시장 2위 놓고 치열한 경쟁유튜브뮤직 VS 지니뮤직, 음원시장 2위 놓고 치열한 경쟁 : 네이버 뉴스 (naver.com) 지니뮤직과 유튜브 뮤직이 음원업계 2위 자리를 놓고 치열한 경쟁을 벌이고 있다. 특히 유튜브 뮤직이 유튜브 프리미엄을 등에 앞세워 빠른 속도로 이용자를 확보하면서 2위 다툼에 불을 붙였다. 업계 한 관계자는 “음악 스트리밍 서비스는 온라인동영상서비스(OTT)와 달리 하나의 앱을 쓰는 경우가 대부분”이라며 “가격 경쟁력을 갖춘 유튜브 뮤직의 성장세가 워낙 가팔라 음원 업계 모두가 예의주시 하고 있다”고 말했다. 4. “DSLR 아냐?”… 갤럭시S22 ‘더 커진’ 카메라 탑재“DSLR 아냐?”… 갤럭시S22 ‘더 커진’ 카메라 탑재 : 네이버 뉴스 (naver.com) 삼성전자가 차세대 갤럭시폰에서 올림푸스 카메라를 탑재할 것이라는 전망이 나왔다. 사진은 갤럭시S22 렌더링이미지. /사진제공=렛츠고디지털 12일(현지시각) 네덜란드 IT매체 렛츠고디지털은 삼성전자가 갤럭시 이용자의 모바일 사진 경험을 개선하기 위해 일본 카메라 업체 ‘올림푸스’와 파트너를 맺을 것이라고 밝혔다. 삼성전자가 개발 중인 새로운 엑시노스 프로세서의 코드명이 ‘올림푸스’라고 알려진 것도 양사 간 협업설에 신빙성을 더했고, 삼성전자는 지난 1월 ‘엑시노스 온’ 온라인 행사를 개최해 최대 2억 화소 이미지까지 처리할 수 있는 고성능 ISP(이미지처리장치)를 갖춘 2021년형 프리미엄 모바일AP ‘엑시노스 2100’를 소개했다. 5. 네이버-카카오, 1Q 실적도 ‘맑음’…비대면 수혜 ‘쏠쏠’네이버-카카오, 1Q 실적도 ‘맑음’…비대면 수혜 ‘쏠쏠’ : 네이버 뉴스 (naver.com) 경기도 성남시 분당구 네이버 그린팩토리 본사.ⓒ네이버 국내 양대 포털업체인 네이버와 카카오가 올해 1분기 비대면 수혜로 실적 상승세를 이어갈 전망이고, 신종 코로나바이러스 감염증(코로나19) 여파로 이커머스·콘텐츠·금융 등 생활 전반을 아우르는 ‘생활 밀착형 플랫폼’으로 진화하면서 관련 사업도 빠른 속도로 성장하고 있다. 콘텐츠 사업은 네이버가 확보한 지식재산권(IP)을 기반으로 성장을 이어가고 있고 지난해 네이버 웹툰 거래액은 8200억원으로 8000억원이었던 원래 목표를 초과했으며, 월간활성이용자수(MAU)도 7200만명으로 역대 최고치를 달성했고 특히 회사는 올해 글로벌 1위 웹소설 플랫폼 왓패드 인수를 통한 시너지 효과를 기대하고 있다. 6. “구글도 뉴스 사용료 내라”…’한국판 구글법’ 발의된다“구글도 뉴스 사용료 내라”…’한국판 구글법’ 발의된다 : 네이버 뉴스 (naver.com) 네이버, 카카오 등 국내 포털은 자율적인 협상을 통해 뉴스 저작권료(전재료) 또는 광고 수익 일부를 언론사에 지급하고 있는 반면 구글·페이스북 등 글로벌 인터넷 플랫폼은 한국 언론의 뉴스를 이용해 많은 광고 수익을 올리면서도 전혀 대가를 지불하지 않고 있음에 따라 정치권이 뉴스 저작권료 지급을 강제하는 이른바 ‘구글법’ 제정에 나선 것이다. 이종관 법무법인 세종 전문위원은 “개정법안의 취지에는 찬성하지만, 호주에서의 입법례는 구글 페이스북이 가진 시장지배력을 견제하는 차원에서 마련되었으며, 이는 국내 상황과 다르다”며 “한국판 구글법을 통해서는 수천개의 언론사와 포털간의 협상을 어떻게 할지 등 난제가 있다”라는 부정적 의견또한 나왔다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-14-IT_News/"},{"title":"2021년 4월 16일 금요일 IT뉴스","text":"1. 페이스북에 뿔난 35개국 시민단체 “어린이용 인스타가 왠말?”페이스북에 뿔난 35개국 시민단체 “어린이용 인스타가 왠말?” - Chosunbiz &gt; 국제 &gt; 국제경제 페이스북이 12세 이하 어린이 전용 인스타그램을 출시하겠다고 밝힌 가운데, 해당 플랫폼이 어린이를 왜곡되고 조작된 환경에 노출시키고 소셜미디어(SNS)에 중독되는 나이를 지금보다 더 낮출 거란 우려에서 각국의 시민단체가 반발하고 나섰다. 스테파니 어트웨이 페이스북 대변인은 “현실은 어린이들도 인터넷에 접속해 있다는 것”이라며 “어린이들도 인터넷을 통해 가족·친구와 시간을 보내기를 원하는 것이 현실이기 때문에, 페이스북은 안전한 환경을 만들어 어린이들을 돕고 싶다”고 했다. 2. 中 바이두, 자율주행 대중교통 버스 시범 운영中 바이두, 자율주행 대중교통 버스 시범 운영 : 네이버 뉴스 (naver.com) 16일 중국 언론 타이핑양뎬나오왕에 따르면 이번주 중국 충칭시와 바이두가 ‘자율주행 공공 버스 운영 착수 및 스마트 교통 프로젝트 전략적 협력 협약’을 체결했다. 이번 운행을 위해, 바이두의 아폴로 플랫폼은 이미 충칭시가 발행하는 일종의 허가서인 ‘자율주행 대중교통 승객 탑승 테스트 통지서’를 받았으며, 바이두는 이번 자율주행 대중교통 버스 유료 탑승 프로젝트를 통해, 인공지능(AI) 자율주행 대중교통 상용화의 의미있는 진척을 이루게 된다. 3. 카카오·네이버 ‘패션’에 거액 투자한 이유…이커머스 성장카카오·네이버 ‘패션’에 거액 투자한 이유…이커머스 성장 : 네이버 뉴스 (naver.com) 분야를 막론하고 몸집 불리기에 나선 카카오와 네이버가 이번엔 패션업계에서 맞붙으며, 카카오는 인수·합병(M&amp;A)으로, 네이버는 직접 투자 방식으로 차세대 성장동력으로 주목받는 패션 플랫폼 수혈에 나섰다. 이창영 유안타증권 연구원은 “한국 이커머스 시장은 지난 10년 동안 연평균 21%의 고성장을 하고 있지만 시장 내 이커머스 사업자들은 오히려 성장의 수혜보다 극심한 생존경쟁에 들어갔다”면서 온라인 쇼핑의 마지막 성장 옵션으로 남아있는 패션 플랫폼 진출 배경을 설명했으며, 업계 관계자는 “플랫폼 인수와 투자로 많은 돈이 오가고 있는데 패션만큼 유행과 트렌드에 민감한 분야도 없다”면서 “지금 자리를 잡은 플랫폼을 잘 끌고 가기 위해선 지속적 투자와 디자이너 발굴이 더욱 중요하다”고 말했다. 4. IT업계, 연봉 전쟁 이어 채용 전쟁 막올라IT업계, 연봉 전쟁 이어 채용 전쟁 막올라 : 네이버 뉴스 (naver.com) 업계에 따르면 15일 라인, 크래프톤, 카카오 등 주요 IT 업체들이 잇따라 채용 공고를 게시했으며, 연봉 인상 경쟁을 벌였던 IT업계가 채용 경쟁에도 속도를 내고 있다. 네이버가 매달 초 경력직을 정기 채용하겠다고 밝힌 데 이어, 라인은 ‘365일 경력직 채용’을 꺼내들고, 신입 채용에서는 채용연계형 인턴과 연 2회 신입 공채를 진행하고, 카카오는 채용연계형 인턴을 뽑아 아직 졸업하지 않은 학생들을 떡잎부터 키우려는 시도도 보인다. 5. 웹소설 플랫폼 ‘문피아’ 잡아라…네이버·카카오·엔씨 ‘3파전’웹소설 플랫폼 ‘문피아’ 잡아라…네이버·카카오·엔씨 ‘3파전’ : 네이버 뉴스 (naver.com) 양질의 지식재산권(IP) 확보를 위해 IT 업계를 중심으로 ‘IP 전쟁’이 거센 가운데, 국내 웹소설 플랫폼 ‘문피아’ 인수를 놓고 네이버, 카카오, 엔씨소프트의 3파전이 펼쳐질 전망이다. 게임, 포털 등 IT 업계가 IP 확보에 열을 올리는 이유는 IP가 가진 무궁무진한 부가가치 창출 가능성 때문이다. 6. ‘KT와 동맹’ 뱅크샐러드, 마이데이터 날개 달았다‘KT와 동맹’ 뱅크샐러드, 마이데이터 날개 달았다 - 팍스넷뉴스 (paxnetnews.com) 16일 투자 업계에 따르면 KT는 최근 뱅크샐러드에 250억원을 투자하면서 주요 주주로 올라섰고, 뱅크샐러드가 국내 최대 통신사 KT와의 ‘동맹’ 통해 마이데이터 사업 전개에 속도를 높인다. 투자 업계 관계자는 “뱅크샐러드가 KT와의 협업 관계를 구축하면서 마이데이터 사업에서 독보적인 경쟁력을 갖게 됐다”며 “KT가 보유한 데이터와 뱅크샐러드의 마이데이터 사업 역량이 결합한다면 혁신 금융 서비스들이 다수 출시돼 시장에서 큰 반향을 일으킬 수 있을 것으로 기대한다”고 말했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-16-IT_News/"},{"title":"2021년 4월 21일 수요일 IT뉴스","text":"1. “개인정보 관리 우려”…日정부, 네이버 자회사 라인 ‘릴레이 조사’“개인정보 관리 우려”…日정부, 네이버 자회사 라인 릴레이 조사 - 매일경제 (mk.co.kr) 네이버 자회사 라인이 개인정보 관리에 문제가 있다는 논란이 일면서 일본 정부의 조사를 받고 있어, 일본 최대 포털업체 야후재팬과 합작회사를 출범시키며 핵심 사업 중 하나로 내세운 공공사업(B2G)에 타격이 불가피할 것이란 관측이 적지 않다. 일본 정부도 라인 플랫폼을 활용해 행정 서비스의 디지털 전환을 의욕적으로 추진해왔는데 행정 처분 등이 결정될 때까지 올스톱이 불가피하며, 당장 라인을 대체할 플랫폼을 찾기도 쉽지 않아 고민에 빠졌다. 2. 빅블러 시대…네이버·토스 등 ‘적’과 동맹 잇는 은행들빅블러 시대…네이버·토스 등 ‘적’과 동맹 잇는 은행들 (ekn.kr) 은행들이 마이데이터 시대(본인신용정보관리업)를 앞두고 기존에 가지고 있던 금융 데이터만을 활용하기에 한계가 있어, 이종산업과 협업을 맺고 축적하는 데이터 범위를 확대하겠다는 의도로 네이버, 토스 등 빅테크(대형 IT기업)·핀테크 기업과 손을 잡으며 적과의 동맹을 이어가고 있다. 산업 간 경계가 사라지는 빅블러 시대인 만큼 금융과 이종산업 간 결합 사례는 더욱 많아질 것으로 보이며, 특히 대부분의 기업이 공통적으로 ‘디지털 플랫폼 기업’을 지향하고 있어, 다양한 분야를 아우르는 데이터를 가지는 것은 곧 경쟁력으로 여겨진다. 3. [IT큐레이션] 네이버는 지금 콘텐츠 앱 생태계를 만들고 있다[IT큐레이션] 네이버는 지금 콘텐츠 앱 생태계를 만들고 있다 &lt; IT/스타트업 &lt; IT/게임 &lt; 기사본문 - 이코노믹리뷰 (econovill.com) 네이버의 콘텐츠 확보 전략은 단순히 좋은 콘텐츠 IP를 확보해 이를 바탕으로 양질의 플랫폼 서비스를 하겠다는 일차원적 접근이 아니라 존재하는 모든 온라인과 오프라인의 활동을 콘텐츠로 인식해 말 그대로 콘텐츠 토털 생태계를 구축하고 있다. 실제로 대리운전, 게임, 메모, 미팅, 협업툴 등 세상 만물이 모두 콘텐츠가 되어 막강한 플랫폼으로 달려왔으며 구글과 애플은 이들에게 수익을 제공해 방대한 생태계를 만들어냈다. 4. 상장 채비 서두르는 카카오페이…발목 잡는 ‘차이나 리스크’ 해소될까상장 채비 서두르는 카카오페이…발목 잡는 ‘차이나 리스크’ 해소될까 : 네이버 뉴스 (naver.com) 카카오페이는 2대주주 중국 앤트그룹의 적격성 문제에 발목 잡혀 신산업으로 주목받고 있는 마이데이터 사업 관련 일부 서비스를 중단하는 등 ‘차이나 리스크’로 사업에 차질을 빚어왔다. 그러나 최근 금융당국 내에서 카카오페이의 마이데이터 적격성 심사와 관련해 기류변화가 나타나고 있어서 최대 걸림돌이 사라질 것이라는 분위기가 지배적이고, 그동안 금융당국은 고유의 최종 결정권한을 사실상 해외 금융당국에게 맡기는 것과 다름 없다는 비난을 받아왔는데, 이같은 분위기가 반전되기 시작한 것이다. 5. “역대 최강 스펙, 성능 자신있다”…애플 신제품들 어떻길래 [종합][“역대 최강 스펙, 성능 자신있다”…애플 신제품들 어떻길래 종합] : 네이버 뉴스 (naver.com) 애플은 21일 오전 2시(한국시간) 미국 캘리포니아주 쿠퍼티노 애플파크 스티브잡스 극장에서 신제품 공개행사를 온라인으로 열고 태블릿 PC ‘아이패드 프로’, 일체형 데스크톱 ‘아이맥’, 무선 위치추적 장치 ‘에어태그’ 등 신제품을 다수 선보였다. 애플은 2023년까지 제조 공급망 및 제품에서 발생하는 탄소 배출량의 75%를 감축하는 한편 재활용 소재를 제품 생산에 적극 활용할 계획으로 팀쿡 애플 최고경영자(CEO)는 “매년 탄소 배출량을 100만 톤씩 줄이겠다”는 목표를 밝혔다. 6. 생각만으로 컴퓨터 사용? 성큼 다가온 미래, BCI생각만으로 컴퓨터 사용? 성큼 다가온 미래, BCI : 네이버 뉴스 (naver.com) 테슬라 CEO 일론 머스크가 설립한 스타트업 ‘뉴럴링크’는 . 뇌에 칩을 이식한 원숭이가 생각만으로 간단한 게임을 즐기는 모습이 담긴 영상을 지난 9일 유튜브에 공개했다 지금까지 BCI가 가장 널리 연구되고 활용됐던 영역은 의료분야로 뇌 질환 예방 또는 치료하는 용도로 쓰거나 신경손상 환자 재활에 활용할 수 있으며, 가령 손상된 뇌 기능 일부를 대신하는 칩을 이식해 뇌 질환을 치료한다거나, 팔다리가 마비된 사람이 생각만으로 컴퓨터나 휠체어를 조작하는 게 가능하다. BCI: 뇌-컴퓨터 인터페이스(BCI, Brain Computer Interface): 뇌와 컴퓨터가 직접 상호작용할 수 있게 하는 인터페이스","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-21-IT_News/"},{"title":"2021년 4월 23일 금요일 IT뉴스","text":"1. 천장 뚫는 그래픽 카드 값에··· 클라우드 게임에 눈 돌리는 게이머천장 뚫는 그래픽 카드 값에··· 클라우드 게임에 눈 돌리는 게이머 : 네이버 뉴스 (naver.com) 전세계적으로 반도체 품귀 현상이 장기화되고 가상화폐 채굴 열풍으로 인한 사재기가 벌어지면서 PC의 성능을 좌우하는 그래픽 카드 칩셋(GPU) 가격이 천정부지로 올라가고 있다. 고사양 그래픽 카드를 구하기 힘들어진 유저들은 발 빠르게 클라우드 게임으로 이동하고 있다. 클라우드 게임은 게임 서버만 마련해 두면 시간·장소·기기에 상관없이 플랫폼 자체에서 PC게임을 이용할 수 있어 기기의 사양이나 종류에 상관 없이 고사양 그래픽을 구현할 수 있다. 2. 넷플릭스 단독 계약였는데… 손 잡은 소니픽처스-디즈니, 조건은 18개월 후 개봉?넷플릭스 단독 계약였는데… 손 잡은 소니픽처스-디즈니, 조건은 18개월 후 개봉? : 네이버 뉴스 (naver.com) 21일(현지시각) 소니픽처스 엔터테인먼트(SPE)와 디즈니는 ‘영화 스트리밍 계약’을 체결했다고 밝혔다. SPE가 제작한 영화를 극장에서 먼저 개봉하고 나면 디즈니플러스를 비롯, 훌루 등 디즈니계열 플랫폼에 방영하는 방식이다. 3. NHN, 데이터 기술 전문법인 ‘NHN DATA’ 설립NHN, 데이터 기술 전문법인 ‘NHN DATA’ 설립 : 네이버 뉴스 (naver.com) NHN(대표 정우진)은 오는 5월 1일 데이터 기술 전문 기업 ‘NHN DATA(NHN데이터)’를 공식 출범한다고 22일 밝혔다. NHN데이터는 NHN의 데이터 기술력이 집약된 데이터 통합 관리 솔루션 ‘다이티(Dighty)’로 국내외 CDP 시장을 공략하는 동시에 인공지능(AI) 기술로 증강 분석 및 비즈니스 전략 수립을 지원하는 신규 라인업을 선보일 예정이다. CDP는 다양한 채널에서 수집되는 고객 데이터를 한 곳에서 통합 관리·분석할 수 있는 플랫폼이다. 4. [다가온 마이데이터 시대]④ 금융권 vs 빅테크 패권 전쟁 점화[다가온 마이데이터 시대]④ 금융권 vs 빅테크 패권 전쟁 점화 © News1 최수아 디자이너 금융권과 통신, 유통 등 비금융권과의 조합. 언뜻 봐선 관련성을 찾기가 힘들지만 이들은 ‘마이데이터 동맹’으로 뭉쳤다. 금융권이 외부와의 협업에 적극적일 수밖에 없는 이유는 마이데이터 시대의 성패가 데이터의 질과 양에 달려있다고 해도 과언이 아니기 때문이다. 5. 애플 vs 페북 갈등 격화…”아이메시지 강화로 왓츠앱과 경쟁”애플 vs 페북 갈등 격화…”아이메시지 강화로 왓츠앱과 경쟁” : 네이버 뉴스 (naver.com) 블룸버그 통신은 22일(현지시간) 익명의 관계자 말을 인용해 “‘아이메시지’(iMessage)를 업그레이드하는 작업이 초기 단계이지만 궁극적으로는 아이메시지가 소셜네트워크서비스(SNS)처럼 작동하고 페이스북의 메신저인 ‘왓츠앱’과 더 잘 경쟁하도록 하는 것이 목표”라고 전했다. 현재 애플과 페이스북은 현재 ‘표적 광고’를 두고 첨예한 갈등을 빚고 있고, 이런 검색·이용 기록 추적을 통해 표적 광고를 보내온 페이스북과 앱 개발자들은 이 조치가 표적 광고를 통해 소비자를 찾고 상품·서비스를 광고해오던 수백만 소상공인에게 타격을 입힐 것이라고 비판하고 있다. 6. 카카오 전기자전거, 대구·부산·광주·대전 4개 광역시로 확대카카오 전기자전거, 대구·부산·광주·대전 4개 광역시로 확대 : 네이버 뉴스 (naver.com) 카카오 T 바이크는 자동차나 지하철, 버스 등 대중교통이 닿지 않는 중·단거리 이동에 효과적인 이동 수단으로, 일반 자전거와 달리 전기 모터를 탑재한 PAS(Pedal Assist System) 방식으로 남녀노소 누구나 더욱 편리하게 이용 가능하다. 카카오모빌리티는 올 상반기 대구·부산·광주·대전 4개 광역시 진출을 통해 카카오 T 바이크를 전국 서비스로 본격 확장한다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-23-IT_News/"},{"title":"2021년 4월 26일 월요일 IT뉴스","text":"1. 세계 최초 국가재난안전통신 전국망 개통세계 최초 국가재난안전통신 전국망 개통 : 네이버 뉴스 (naver.com) KT와 SK텔레콤은 삼성전자와 함께 세계 최초로 국가재난안전통신 전국망을 개통했다고 오늘(26일) 밝혔습니다.경찰·소방·국방·철도·지방자치단체 등 8대 분야 333개 국가기관의 무선통신망이 하나로 통합됐고, 무선통신 국제표준화 기술협력 기구인 3GPP가 제정한 재난안전통신규격(PS-LTE Standard)에 맞춰 구축됐습니다. 재난안전통신망은 각종 중대형 재난사고를 효율적으로 예방하고 대응하기 위해 정부 주도로 구축된 차세대 무선통신망입니다. 2. 오라클, 더 나은 세상을 위한 온라인 해커톤 개최오라클, 더 나은 세상을 위한 온라인 해커톤 개최 : 네이버 뉴스 (naver.com) 오라클은 온라인 해커톤 전문 회사인 핵메이커와 함께 스마트시티 및 지속 가능한 미래를 위한 해커톤을 개최한다고 26일 밝혔다. 이 해커톤은 주요 UN 지속가능발전목표(SDG) 관련 도전 과제 해결을 목표로, 시민 및 전문 개발자와 학생들이 창의적인 기술을 활용해 모두를 위한 보다 나은 세상을 만드는 데 기여할 새로운 아이디어와 솔루션을 고안하도록 지원한다. 3. 몸집 키우는 네이버·카카오, 직원 1만시대몸집 키우는 네이버·카카오, 직원 1만시대 : 네이버 뉴스 (naver.com) 네이버와 카카오는 비대면 여파를 타고 쇼핑, 콘텐츠, 핀테크 등 각종 사업이 성장하면서 올해 들어서도 인재 충원 경쟁에 나섰다. 인력이 곧 생산설비와도 같은 IT기업들은 빅데이터, 인공지능(AI) 등 개발자를 비롯한 각종 분야의 인력 충원에 공격적으로 나섰다. 4. 공인인증제도 폐지됐지만··· “우리는 여전히 공인인증서 시대에 살고 있다”공인인증제도 폐지됐지만··· “우리는 여전히 공인인증서 시대에 살고 있다” : 네이버 뉴스 (naver.com) 작년 12월 10일 공인인증제도 폐지를 골자로 하는 새 전자서명법의 시행으로 공인인증서(현 공동인증서)의 활용이 줄고 다양한 민간인증서의 활용도가 높아질 것으로 기대됐으나 파급력이 기대에 못미친다는 의견이 나오고 있다. 인증업계 관계자는 “공동인증서의 유효기간 만료 기간이 다가옴에 따라 새로운 기회가 찾아올 것이라 기대했지만 마이데이터 서비스에 공동인증서만 이용 가능하다면 다수 이용자가 공동인증서를 재발급하면서 공동인증서 만료로 인한 특수를 기대하기 어려워졌다”고 꼬집었고, 마이데이터 서비스처럼 정부가 추진하는 혁신 서비스에 차세대 인증 기술은 사용 안 되고 공동인증서만 사용 된다면 법을 개정한 취지가 퇴색되는 것”이라며 “여전히 우리는 공인인증서 시대에 살고 있다”고 부연했다. 5. 韓 70% ‘앱으로 쇼핑’…규모는 쿠팡, 대세는 당근마켓韓 70% ‘앱으로 쇼핑’…규모는 쿠팡, 대세는 당근마켓 : 네이버 뉴스 (naver.com) 지난달 국내 모바일 쇼핑 사용자수가 전 국민의 약 70%인 3500만명을 넘어선 것으로 나타났다. 이 가운데서도 가장 높은 월간 활성 사용자수(MAU)를 기록한 곳은 ‘쿠팡’이었고, 중고거래에선 ‘당근마켓’이 독보적인 점유율을 차지했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-26-IT_News/"},{"title":"2021년 4월 19일 월요일 IT뉴스","text":"1. 연봉 인상만으론 안된다…게임사들 ‘복지’로 개발자 유혹연봉 인상만으론 안된다…게임사들 ‘복지’로 개발자 유혹 : 네이버 뉴스 (naver.com) 개발 인력 부족 현상으로 개발자들의 연봉이 상향 평준화되자 또다른 유인책으로 복지 수준 향상을 택한 것이다. 업계 관계자는 “기업을 택하는 데 있어 연봉 만큼이나 복지 수준도 중요한 요소”라며 “개발자들의 연봉이 상향 평준화 된 만큼, 또 다른 당근책이 필요하다는 인식이 각 사 복지 향상을 불러온 것 같다”고 말했다. 2. 네이버·카카오, 3년간 스타트업에 5천억·1천억 투자…이제 글로벌 투자로네이버·카카오, 3년간 스타트업에 5천억·1천억 투자…이제 글로벌 투자로 : 네이버 뉴스 (naver.com) [이데일리 노재웅 기자] 네이버, 북미·유럽으로 영토 확장. 지난 2월 ‘스페인의 당근마켓’이라 불리는 온라인 중고 거래 업체 ‘왈라팝’에 1억1500만유로(약 1550억원)을 투자했다. 1월엔 캐나다의 세계 최대 웹소설 플랫폼 ‘왓패드’를 인수했고, 이달 인도네시아 최대 미디어기업 ‘엘랑 마코타 테크놀로지(엠텍)’에 1억5000만달러(약 1678억원) 규모의 전략적 투자를 단행하면서 해외 IP(지식재산권) 확보에도 강한 드라이브를 걸었다. 라인과 Z홀딩스 산하 라인벤처스와 YJC를 합병해 ZVC를 만들고, 300억엔(약 3000억원) 규모의 ‘ZVC 1 인베스트먼트 파트너십’ 펀드를 출범시켰다. ZVC는 “헬스케어, 사이버 보안, B2B 소프트웨어 분야를 비롯해 Z홀딩스의 3가지 핵심 사업인 커머스, 미디어, 핀테크 분야에 적극 투자할 것”이라고 밝혔다. 전세계에 카카오 콘텐츠 왕국 세운다 카카오는 글로벌 웹소설 플랫폼 래디쉬, 북미 웹툰 플랫폼 타파스미디어의 지분 인수를 추진 중이다. 국내에서는 MZ세대를 겨냥한 패션 플랫폼 ‘지그재그’를 운영하는 크로키닷컴 인수를 공식화했다. 합병 법인은 국내 대표 패션플랫폼으로서의 지위를 단단히 하고, 글로벌 패션 시장에 도전한다. 카카오의 스타트업 투자를 담당하는 카카오벤처스는 최근 디지털헬스케어 분야 전문가인 김치원 서울와이즈재활요양병원장을 전담 파트너로 영입했다. 3. 네이버, 고화질 영상 데이터 소비량 40% 줄인다네이버, 고화질 영상 데이터 소비량 40% 줄인다 : 네이버 뉴스 (naver.com) 네이버는 동영상 화질은 유지하면서 용량은 줄이는 기인 ‘AI최적화인코더’ 기술을 연내 네이버TV 등에 적용할 예정이라고 18일 밝혔다. 고화질 영상시대에 ‘인코딩 개발’은 넷플릭스 등 국내외 동영상 서비스 업체들이 공을 들이는 핵심 분야로 떠오르고 있으며, 화질이 올라갈수록 이용자는 데이터 부담이 커지고 사업자들은 서버 용량이 비용으로 뒤따르는데, 기술력으로 이를 극복하기 위해서다. 4. 우아한형제들, 배민은 ‘단건배달’ B마트는 ‘묶음배달’ 실험우아한형제들, 배민은 ‘단건배달’ B마트는 ‘묶음배달’ 실험 : 네이버 뉴스 (naver.com) 기존에는 B마트에 주문이 들어오면 고객 별로 단건 배달이 이뤄졌지만, 20일부터 송파점과 강동천호점 담당지역에서는 주문이 들어오면 AI가 거리나 배달 예상 시간 등을 분석해 가까운 배송을 하나로 묶어서 가까운 라이더나 커넥터에게 전달한다. 최근 우아한형제들은 6월부터 단건배달을 하는 ‘배민1(one)’을 출시해 서울 일부지역에서 서비스를 시작한다고 예고한 바 있다. 5. 테슬라 모델S 충돌로 2명 사망…운전석에 ‘아무도 없었다’테슬라 모델S 충돌로 2명 사망…운전석에 ‘아무도 없었다’ : 네이버 뉴스 (naver.com) 테슬라 모델S의 조수석에 탑승한 59세 남성과 뒷좌석에 탑승한 69세 남성은 차량이 나무에 부딪히면서 사망했다. 테슬라 모델S는 운전자가 탑승하지 않았는데, 자율주행 기능을 작동시키게 설계돼 안전성 문제가 있다는 것이며, 사고 발생 후 현장에 도착한 소방관들은 화제를 진압하는 데 4시간이 걸렸던 것으로 전기차 배터리의 안전성 문제도 제기됐다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-19-IT_News/"},{"title":"2021년 4월 28일 수요일 IT뉴스","text":"1. 큐냅 NAS 노린 랜섬웨어 ‘Q로커’ 사기 주의보큐냅 NAS 노린 랜섬웨어 ‘Q로커’ 사기 주의보 데이터를 볼모로 몸값을 요구하는 악성코드, 랜섬웨어가 PC가 아닌 NAS(네트워크 저장장치)로 눈을 돌렸고, 특히 이달 중순 등장한 랜섬웨어인 Q로커(Qlocker)는 시놀로지, 에이수스토어(Asustor) 등과 함께 대만 내 주요 NAS 업체로 꼽히는 큐냅(QNAP) 제품을 노린다. 모든 파일의 암호화가 끝났다 해도 NAS 내부에 존재하는 로그 파일에 암호화에 쓰인 비밀번호가 남아 있기 때문에 NAS의 전원을 끄거나 재부팅해서는 안된다. 2. 네이버 ‘웨일’ 크롬 콧대 꺾을까… “3년 내 시장 석권할 것” 기염네이버 ‘웨일’ 크롬 콧대 꺾을까… “3년 내 시장 석권할 것” 기염 네이버가 자사의 웹 브라우저 ‘웨일’을 통해 3년 안에 구글 크롬을 제치고 국내 웹브라우저 시장을 석권하겠다는 야심찬 포부를 드러냈다. 시장조사업체 스탯카운터에 따르면 지난해 12월 기준 웨일의 국내 브라우저 시장 점유율은 8.29%로 1위 크롬(52.77%)과 여전히 큰 격차를 보이고 있지만 지난해 1월 웨일이 0.12%의 점유율을 기록한 것과 비교하면 큰 성장을 이뤄냈다. 3. “애플, 차세대 ‘M2’칩 생산 들어가…올해 맥북 탑재될 수도”“애플, 차세대 ‘M2’칩 생산 들어가…올해 맥북 탑재될 수도” 애플이 자체 설계한 반도체 칩 ‘M1’을 잇는 ‘M2(또는 M1X)’가 생산에 들어간 것으로 알려졌으며, M2는 세계 반도체 파운드리(위탁생산) 1위 업체인 대만 TSMC가 맡는 것으로 전해졌다. 5나노미터플러스(N5+) 공정이 도입될 전망이고, 전작인 M1과 같이 ARM 기반 시스템온칩(SOC)으로 설계될 것으로 보인다. 앞서 애플은 인텔과 작별하고 자체 설계한 반도체 칩 M1을 공개한 바 있다. 4. ‘게임사와 다른’ 개발자 잡아라…삼성SDS·LG CNS·SK㈜C&amp;C 연봉 인상‘게임사와 다른’ 개발자 잡아라…삼성SDS·LG CNS·SK㈜C&amp;C 연봉 인상 삼성SDS·LG CNS·SK㈜C&amp;C 등 주요 대기업집단 IT서비스 3사가 올해 직원들의 연봉을 예년보다 큰 폭으로 인상한 것은 개발자 처우를 개선하자는 취지다. 하지만, IT서비스 기업과 게임사 개발자들의 업무 내용 및 개발 범위가 다르기 때문에 최근 전직원들의 연봉을 대폭 인상하거나 대규모의 자사주를 지급한 게임사나 인터넷 기업으로의 인력 유출에 대한 우려와는 거리가 멀다. 5. 20년 쌓아올린 알리바바 제국, AI 무장 新生기업에 추월당했다20년 쌓아올린 알리바바 제국, AI 무장 新生기업에 추월당했다 중국 이커머스 업체 핀둬둬는 중국 1위 이커머스 업체 알리바바가 다양한 채널로 소비자들에게 접근하는 것과 달리 인터넷 쇼핑몰이지만 PC 홈페이지 없이 모바일 앱만 운영한다. 핀둬둬는 AI를 소비자 개개인에게 최적화하여 백화점식 배열에 익숙한 인터넷 쇼핑 이용자들에 핀둬둬의 맞춤형 서비스는 엄청난 파장을 몰고 왔으며, 창업 6년 만에 알리바바의 이용자 수를 넘어섰다. 6. AI發 ‘마의 벽’에 부딪힌 자율주행차AI發 ‘마의 벽’에 부딪힌 자율주행차 . 세계 최고 기술을 갖춘 글로벌 기업 책임자가 실적 부진을 이유로 사퇴하는가 하면 국내 유망 스타트업이 사실상 해체 수순을 밟고 있다는 소문까지 나돌고 있으며, 업계에선 “기술 진화 속도보다 비즈니스가 과속할 때 벌어지는 불일치 현상”이란 지적이 나온다. 27일 정보기술(IT)업계에 따르면 국내 자율주행 전문 기업 포티투닷의 사업회사 퍼플엠의 서영우 대표와 최고운영책임자(COO) 등 초기 멤버 상당수가 최근 회사를 이탈했고, 세계 자율주행차 기술의 ‘쌍두마차’로 꼽히는 테슬라와 구글 등 글로벌 선두주자들이 나란히 악재를 겪고 있으며, 글로벌 업체들의 ‘운전자 없는’ 자율주행차 상용화 시기는 애초 기대했던 2021년이나 2022년이 아니라 2025년 이후로 대부분 미뤄진 것으로 알려졌다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-28-IT_News/"},{"title":"2021년 5월 3일 월요일 IT뉴스","text":"1. 애플·에픽, 세기의 ‘앱스토어 전쟁’ 마침내 시작애플·에픽, 세기의 ‘앱스토어 전쟁’ 마침내 시작 두 회사 공방의 핵심 쟁점은 앱스토어를 운영하고 있는 애플의 독점 행위다. 에픽은 애플이 앱스토어 이외 다른 앱 장터를 허용하지 않으면서 사실상 경쟁을 막고 있다고 주장하고 있으며 앱 배포 못지 않게 인앱결제 문제도 쟁점으로 떠오르고 있다. 2. 13일부터 킥보드 헬멧 의무화…”공용이냐, 개인용이냐” 업계 ‘딜레마’13일부터 킥보드 헬멧 의무화…”공용이냐, 개인용이냐” 업계 ‘딜레마’ 다음달 13일부터 헬멧을 착용하지 않고 전동킥보드를 타면 이용자에게 범칙금 2만원이 부과된다.업계는 헬멧 착용을 유도하되, 킥보드 이용률은 유지하기 위한 방법을 고심하고 있으며, 각사의 대처 능력에 따라 업계의 시장 점유율도 차이가 벌어질 전망이다. 3. TV도 워크맨도 다 버리더니… ‘콘텐츠’로 창사 이래 최대실적, 소니의 부활TV도 워크맨도 다 버리더니… ‘콘텐츠’로 창사 이래 최대실적, 소니의 부활 워크맨과 TV로 1990년대까지 세계를 호령했던 소니는 2000년대부터 인터넷 시대에 대응하지 못하면서 침몰의 길로 들어섰다. 하지만, 게임과 음악, 영화 등을 포함한 엔터테인먼트 사업의 견인으로 2일 업계에 따르면, 소니그룹은 최근 발표한 2020회계연도(작년 4월~올해 3월) 순이익(연결기준)이 전년의 2배 수준인 1조1,717억 엔(약 11조9,500억 원)에 달했고, 매출액도 9% 늘어난 8조9,993억 엔(약 91조8,000억 원)으로, 순이익과 매출액 모두 사상 최대치다. 4. VR 회사 또 샀다…페이스북, 다운푸어 인수VR 회사 또 샀다…페이스북, 다운푸어 인수 지난달 30일(현지시간) 페이스북이 VR 슈팅 게임 온워드를 개발한 ‘다운푸어 인터렉티브’를 인수했다. 페이스북은 지난 2019년 말부터 VR 개발사를 활발히 인수해왔으며, “VR을 육성하기 위해 다양한 방법을 모색하고 있다”며 “향후 몇 년간 VR 게임을 위한 놀랍고 혁신적인 계획도 가지고 있다”고 밝혔다. 5. 구글 이어 야후도 ‘이것’에 손 뗐다… ‘네이버 지식인’만 살아남은 비결구글 이어 야후도 ‘이것’에 손 뗐다… ‘네이버 지식인’만 살아남은 비결 이달 4일 미국 야후는 2005년부터 운영해온 ‘야후! 앤서스(Yahoo! Answers) 서비스’를 완전히 종료한다. 네이버에 따르면 지식공유 서비스인 ‘네이버 지식인’의 글 생산량은 역대 최대치를 돌파했으며, 지식iN 서비스에서 한 단계 진화한 ‘네이버 엑스퍼트’는 ‘SME 대상의 마이크로 컨설팅’ 플랫폼으로 자리 잡으며 빠르게 성장하고 있다. 야후 앤서스는 사용자가 질문하면 다른 사용자가 답변을 달아주고 검색창에 질문을 입력하면 답이 될 만한 정보를 찾아주는 서비스로, 국내에서는 네이버 지식인과 비슷하다. 네이버 엑스퍼트는 결제, 라이브기술, 채팅 등 네이버가 개발한 기술들을 고도화한 서비스로, 전문가와 사용자가 일대일(1:1) 비공개로 만날 수 있다는 점이 특징이다. 6. 줌이 장악한 화상회의 플랫폼… 국내 업체들 “좀, 들어갈게”줌이 장악한 화상회의 플랫폼… 국내 업체들 “좀, 들어갈게” 후발주자로 분류되던 국내 IT업체들도 다양한 기능을 탑재한 협업 툴을 내세우며 줌에 도전장을 던지고 있다. 한 업계 관계자는 2일 “줌은 화상회의만 가능한 플랫폼이다보니 용도가 한정적”이라며 “업무 툴을 여러 개 두기보단 하나로 통합해서 쓰는 게 효율적이라고 보기 때문에 종합 협업 툴을 지향하는 국내 업체들도 발전 가능성이 충분하다”고 설명했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-03-IT_News/"},{"title":"2021년 4월 30일 금요일 IT뉴스","text":"1. 카카오 이어 네이버도 ‘대기업집단’ 반열…재계 순위 27위 ‘껑충’카카오 이어 네이버도 ‘대기업집단’ 반열…재계 순위 27위 ‘껑충’ 네이버는 사업이익 증가, 외부 신규투자 유치로 자산총액이 9조5000억원에서 13조6000억원으로 급증하면서 재계 순위가 41위에서 27위로 약진했고, 넷마블(36위), 넥슨(34위)도 자산총액이 각각 10조7000억원, 12조원으로 늘어 상호출자제한 기업집단으로 지정됐으며, 이들 기업은 상호출자가 금지된다. 공정위는 “코로나19 극복 과정에서 시중 유동성이 크게 증가해 자산가치가 급등하면서 지정집단이 대폭 확대됐다”며 “(특히) 비대면 시장이 급성장함에 따라 IT업종을 주력으로 하는 기업집단들의 성장세가 뚜렷했다”고 설명했다. 상호출자: 회사간에 주식을 서로 투자하고 상대회사의 주식을 상호보유하는 것 2. [단독] “쿠팡맨 말고 당근맨?”…당근마켓 ‘3000원’ 배송 서비스 나왔다 [IT선빵!][단독] “쿠팡맨 말고 당근맨?”…당근마켓 ‘3000원’ 배송 서비스 나왔다 [IT선빵!] 중고거래 애플리케이션 당근마켓이 거래 물품을 배송해주는 ‘당근배송’ 서비스를 내놨으며, 일부 지역의 서비스 테스트를 시작으로, 본격적인 배송 서비스가 도입될 것으로 전망된다. 당근마켓 측은 “다만, 직거래가 아니어서 실제로 물건을 확인하지 않고 진행되다가 생기는 거래 분쟁, 물품 진위 여부 등은 배송원이 확인하기 어려워 당근마켓에서 관여하지 않는다”고 설명했고 “테스트 결과와 이용자들의 반응에 따라 타지역 확대 여부가 결정될 예정”이라며 “테스트 서비스로, 아직 공식 서비스 오픈 일정은 미정”이라고 말했다. 3. “배달 거절하면 패널티” vs.“싼 배달 거절은 권리” 배달앱과 라이더 ‘충돌’ [IT선빵!]“배달 거절하면 패널티” vs.“싼 배달 거절은 권리” 배달앱과 라이더 ‘충돌’ [IT선빵!] “배달 콜 거절하지 마세요. 패널티 부과합니다.”(배달앱 측 입장) “최저 단가나 장거리 배달을 거절하는 건 권리 아닌가요? 부당합니다.”(배달 라이더 측 입장) 쿠팡이츠에 이어 배달의민족도 라이더들의 배달 수락률과 배달 완료율을 표시하며, 라이더들은 배달앱이 이를 근거로 패널티를 부과할 가능성이 커졌다며 우려하고 있다. 앞서 쿠팡이츠는 ‘배달 호출(콜) 거절과 취소’를 이유로 일부 라이더에게 하루 동안 배달을 제한한다고 통보했지만, 일부 라이더들은 업무 제한 기준이 고객센터에 문의해도 “내부 규정상 기준을 공개할 수 없다”는 입장만 반복하거나, 상담원마다 언급하는 기준이 다르기 때문에 명확하지 않다고 주장하고 있다. 4. “격주로 4일 근무”… 게임업계 이번엔 복지전쟁“격주로 4일 근무”… 게임업계 이번엔 복지전쟁 예전 게임 업계는 크런치 모드(게임 개발 막바지에 밤을 새우며 작업하는 상황)로 악명 높았지만, 요즘 업계에선 “게임 업체들이 워라밸 선진 기업들로 속속 바뀌고 있다”는 말이 나온다. 임금 인상에 복지 경쟁까지 불붙으면서 중장기적으로 기업의 인건비 부담이 크게 늘어날 것이라는 우려도 나오며, 게임 업계에서는 “임금을 대폭 인상한 데 이어 복지 지출까지 커지면서 게임 업체들의 인건비 지출 규모는 지난해 대비 20~30% 증가할 것”이라는 전망이 나온다. 5. LG폰은 없애고 특허만 남겼다…스마트가전·전장에 IP 이식LG폰은 없애고 특허만 남겼다…스마트가전·전장에 IP 이식 LG전자가 휴대폰 사업에서 26년간 쌓은 특허와 기술력을 스마트가전, 전장 등 미래사업으로 이관하며, 휴대폰 핵심 지식재산권(IP) 자산은 차량용 커넥티비티 등을 개발하는 전장솔루션(VS)사업본부에서 적극적으로 활용할 방침이다. LG전자는 휴대폰 사업 종료 후에도 미래준비를 위한 핵심 모바일 기술의 연구개발은 지속할 방침이고, 특히 6세대 이동통신(6G)·카메라·소프트웨어 등 핵심 모바일 기술은 차세대 TV·가전·전장부품·로봇 등에 필요한 역량으로 꼽힌다. 회사는 이 분야에서 최고기술책임자(CTO)부문 중심으로 연구개발을 지속할 예정이다. 6. 코로나 내년초엔 끝날까…’CES 2022’ 라스베이거스서 현장 진행코로나 내년초엔 끝날까…’CES 2022’ 라스베이거스서 현장 진행 올해 비대면 진행된 세계 최대 전자·정보기술(IT) 전시회 CES가 내년에는 예년처럼 라스베이거스에서 현장 행사로 열린다. 미국 야후는 “내년 1월 백신 접종 상황이 얼마나 진척될 지도 모른다”며 “올해는 2020년 당시 방문객수 17만 명보다는 적겠지만, 상당수가 외국인 참가자라는 걸 고려하면 상황이 어떻게 될지 모르겠다”고 우려했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-04-30-IT_News/"},{"title":"2021년 5월 5일 수요일 IT뉴스","text":"1. 파이썬, 자바 꺾고 2위 등극 …5월 TIOBE 지수 공개파이썬, 자바 꺾고 2위 등극 …5월 TIOBE 지수 공개 매달 프로그래밍 언어의 인기 지표를 발표하는 TIOBE에서 파이썬(Python)이 자바(JAVA)를 누르고 2위에 올랐다. (관련기사) 4월의 1위 프로그래밍 언어 자리는 지난달과 동일하게 C가 차지했다.올해의 언어상을 수상했던 Objective-C가 지난달 20위 밖으로 퇴장한 이후 20위 내 프로그래밍 언어들의 변동은 크게 없지만, 20위 밖에서 러스트(Rust)ㆍ다트(Dart)ㆍ줄리아(Julia)가 상승세를 보인다. 2. 2위 배달앱 ‘요기요’ 인수전…신세계·야놀자 참여2위 배달앱 ‘요기요’ 인수전…신세계·야놀자 참여 4일 투자은행(IB) 업계에 따르면 독일 딜리버리히어로(DH)와 매각 주관사 모건스탠리가 이날 진행한 요기요 운영사 딜리버리히어로코리아 예비 입찰에 신세계, 야놀자, MBK파트너스 등 국내 유통 대기업과 유니콘(기업가치 1조원 이상의 비상장사), 사모투자펀드(PEF)가 참여한 것으로 알려졌다.야놀자는 요기요 인수로 여행·숙박 사업과 배달 서비스를 연계하는 방안을 모색하고 있으며, 야놀자가 올해 상장을 준비하는 만큼 인수 성공시 기업가치가 달라질 수 있다는 분석도 나온다. 3. 카카오가 꽉잡은 3.5조원 선물하기, 네이버도 눈독카카오가 꽉잡은 3.5조원 선물하기, 네이버도 눈독 비대면(언택트) 흐름 속 가파른 성장세를 보이는 ‘선물하기’ 시장에서 네이버가 카카오에 도전장을 내밀었고, 카카오톡을 기반으로 한 관계형 커머스에 강점을 보이는 카카오를 상대로 네이버는 45만 스마트스토어를 앞세워 공략에 나섰다. 4일 이커머스 업계에 따르면 선물하기 시장 규모는 지난해 기준 약 3조5000억원 수준으로 추산되며, 이 가운데 3조원 가량이 카톡 선물하기 거래액으로 지난해 12월 기준 이용자만 2173만명에 이른다. 4. [단독] LG전자 모바일인력 600명, LG엔솔로 간다…왜[단독] LG전자 모바일인력 600명, LG엔솔로 간다…왜 4일 재계와 LG전자 등에 따르면 LG전자는 지난달 휴대전화 사업 종료를 선언한 후 3400여 명의 모바일(MC)사업본부 인력의 재배치를 구체화하고 있다.회사 측은 직원 개개인의 의사를 최대한 반영하고 있으며, 사업 부서를 해체거나 매각할 때 국내 어느 대기업에서도 전례가 없는 파격적인 조치다. 5. [OTT온에어] 넷플릭스 1Q 가입자 성장둔화…5천500억 韓 투자 ‘우려’[OTT온에어] 넷플릭스 1Q 가입자 성장둔화…5천500억 韓 투자 ‘우려’ 넷플릭스의 올 1분기 매출은 71억6천300만달러(약 8조10억원), 영업이익은 19억6천만달러(약 2조1천900억원) 수준으로 전년동기대비 각각 늘었고, 영업이익률도 27.4%에 육박하며 실적은 견고했다.사실상 사상 최고치임에도 불구하고 600만명 이상 증가할 것이라 예측했던 넷플릭스 글로벌 가입자 순증이 398만명에 그쳤기 때문에 각국 애널리스트의 시선은 보수적이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-05-IT_News/"},{"title":"2021년 3월 30일 화요일 IT뉴스","text":"1. 카카오 “주식가치 올릴 것”..500원→100원 액면분할 승인카카오 “주식가치 올릴 것”..500원→100원 액면분할 승인 : 네이버 뉴스 (naver.com) 카카오가 29일 정기 주주총회에서 1주당 가액을 500원에서 100원으로 액면분할 하기로 결정했고,국내 최대 음원 플랫폼 멜론의 사업 분할 안건도 승인했다. 여 대표는 “카카오는 앞으로 다양한 사업의 성장동력 지속과 사업모델 수익화에 힘쓰며 재무적인 개선을 보여 드릴 뿐 아니라 더 나아가 환경, 사회, 지배구조를 중시하는 ESG(환경·사회·지배구조) 경영에도 힘쓰며 기업가치를 높여갈 것”이라고 강조했다. 2. 삼성, 스마트폰 세계 1위 수성 ‘고군분투’삼성, 스마트폰 세계 1위 수성 ‘고군분투’ : 네이버 뉴스 (naver.com) 삼성전자는 갤럭시S21 출시를 앞당기면서 지난달 ‘점유율 1위’ 탈환에 성공했지만, 애플과의 차이는 매우 근소하다. 삼성전자는 가성비 높은 갤럭시A 라인업을 갖추고 하반기 폴더블폰(접는 스마트폰) 대거 출시를 준비하는 등 격차를 벌리기 위한 전략에 매진하고 있다. 3. 카톡 닮은 ‘카카오워크’, 일상 속 스마트워크 야심카톡 닮은 ‘카카오워크’, 일상 속 스마트워크 야심 : 네이버 뉴스 (naver.com) 국민 메신저 카카오톡(카톡)을 닮은 비대면 업무용 협업 플랫폼인 카카오엔터프라이즈의 ‘카카오워크(Kakao Work)’ 본격적인 시장 공략을 시작했다. 백상엽 카카오엔터프라이즈 대표는 “‘카카오워크’에서는 내 업무를 도와주는 진정한 AI 어시스턴트를 만날 수 있다”며 “우수한 벤처기업들과 상생하는 마켓플레이스를 구축하고 기존에 사용하던 IT 시스템과 내게 필요한 다양한 기능을 직접 커스텀할 수 있는 쉬운 IT 환경을 제공해 나가고 있다”고 밝혔다. 카카오워크는 카톡을 닮은 편리한 사용성, 다양한 정보기술(IT) 서비스와의 유연한 연결, 인공지능(AI) 통합 검색 기술 등이 핵심이다. 화상회의, 전자결재. 근태관리 등 업무 플랫폼으로서 필수적인 기능이 무료 탑재돼 대기업뿐만 아니라 작은 중소기업이나 자영업자 등 다양한 규모의 기업에서 활용할 수 있다. 최근엔 메시지 삭제, 워크스페이스 봇 관리 기능 등을 추가했고 ‘프리미엄 플랜’ 이상부터 화상회의 시 100명까지 입장할 수 있게 했다. 아울러 화상회의의 품질을 업데이트해 전반적인 성능과 연결 안정성을 향상시켰다. 4. ‘AI’로 무장한 네이버웍스, 외국인 직원과 협업도 거뜬‘AI’로 무장한 네이버웍스, 외국인 직원과 협업도 거뜬 : 네이버 뉴스 (naver.com) 네이버웍스 메시지 화면 (사진=네이버클라우드) 신종 코로나바이러스 감염증(코로나19)로 원격근무 시대가 열리면서 해외 협업툴이 밀려 들어오고 있는 가운데 네이버는 외산 제품의 공세에 맞서 국내외 시장을 확장해 나가고 있다. 이미 네이버웍스는 일본에선 ‘라인웍스’라는 이름으로 유료 업무용 메신저 시장 1위를 차지하고 있으며, 대웅제약, 웅진씽크빅 등 10만개가 넘는 기업의 직원들이 네이버웍스로 업무를 본다. 네이버웍스의 강점은 네이버, 라인 서비스와 유사한 화면으로 누구나 쉽게 사용할 수 있다는 것이다. 메시지 기능은 읽은 사람 수를 넘어 읽은 사람이 누구인지까지 확인이 가능하며, 최대 200명까지 동시 접속할 수 있다.인공지능 기술 - AI번역서비스(파파고), OCR서비스 5. “사람 대신 사물·서비스 이동…패러다임 바꾸겠다”“사람 대신 사물·서비스 이동…패러다임 바꾸겠다” : 네이버 뉴스 (naver.com) 카카오모빌리티가 그리는 미래 속 소비자는 구매 희망하는 상품을 원하는 장소까지 교통 수단을 활용해 이동시킬 수 있다. 카카오모빌리티 플랫폼을 통해 차량이 아닌 물건을 호출하는 것이다. / 카카오모빌리티 경기도 판교 사무실에서 만난 신동훈 카카오모빌리티 MaaS(통합교통서비스)사업실 실장(상무)은 ‘사람의 이동’ 효율화에 초점을 맞추고 있는 현재 모빌리티 사업을 ‘사물과 서비스의 이동’으로 바꾸겠다고 밝혔다. “카카오모빌리티는 택시, 바이크, 시외버스, 기차 등 다양한 이동 수단을 통해 방대한 데이터를 축적했고, 이를 기반으로 A에서 B까지 이동할 때 소비자가 어떤 상품과 서비스를 필요로 하는지, 어떻게 하면 다양한 이동 수단을 최적화해 연결할지에 대한 노하우를 많이 쌓아왔기 때문에 앞으로는 사람이 교통 수단을 이용해 이동할 필요 없이, 사물과 서비스가 교통 수단을 통해 고객 앞으로 직접 찾아오는 서비스를 제공하겠다.”","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-03-30-IT_News/"},{"title":"2021년 5월 17일 월요일 IT뉴스","text":"1. [PLAY IT] 홈쇼핑 고객 정착 가능할까…‘CJ온스타일’ 이용해보니[PLAY IT] 홈쇼핑 고객 정착 가능할까…‘CJ온스타일’ 이용해보니 CJ온스타일은 기존 TV홈쇼핑과 CJ몰 등에서 판매하던 상품·서비스를 한 곳에 모아놓은 모바일 애플리케이션(앱)이며, 지난 10일 공식 론칭 후 대대적 이벤트를 함께 진행한 결과 3일 만에 애플 앱스토어 쇼핑앱 부문 1위, 구글 플레이스토어 쇼핑앱 부문 2위에 등극했다. 실제 지난 10일부터 12일까지 3일간 실적에선 모바일 앱 구매 고객이 크게 늘며 전년동기대비 43% 증가했고, 특히 핵심 타깃인 35~54세 고객 비중은 약 70%였다. 2. 코로나19 백신이 넷플릭스에 미친 영향, 글로벌 OTT 타격코로나19 백신이 넷플릭스에 미친 영향, 글로벌 OTT 타격 전세계 코로나19 대유행으로 사회적 거리두기가 강화되면서, 집에 머무는 시간이 늘어나자 넷플릭스와 같은 글로벌 온라인동영상서비스(OTT)는 폭발적으로 성장했지만, 최근 미국 등에서 코로나19 백신 접종이 확산되면서, 경제활동과 일상생활이 재개되었고, 집에서 OTT를 보는 것 대신, 외부활동을 선택하는 이들이 증가한 셈이다. 넷플릭스, 디즈니플러스, HBO맥스를 비롯해 아마존프라임, 애플TV플러스, 훌루 등 OTT 사업자들이 속속 등장하며 경쟁구도가 가속화된 가운데, 코로나19 영향으로 제작 환경까지 위축되었고, 새로운 구독자를 유인할 신작이 과거보다 많지 않은 상황에서, 사람들은 일상생활로 눈을 돌리게 된 것이다. 3. 구글 안드로이드 오토 갑질논란에 정부 칼 빼들었다구글 안드로이드 오토 갑질논란에 정부 칼 빼들었다 구글이 자사가 운영하는 구글플레이가 아닌 원스토어·삼성 갤럭시 스토어 등에서 받은 앱은 안드로이드 오토에서 실행되지 않도록 차단했다는 ‘갑질행태’에 대해 정부가 칼을 빼 들었다. 이탈리아 정부도 구글의 이같은 갑질 행태에 약 1400억원의 과징금을 부과한 바 있어, 국내에서도 실제 처벌까지 이어질지 관심이 모아지고 있다. 4. 네이버-카카오, 한국은행 디지털화폐 사업 맞붙는다네이버-카카오, 한국은행 디지털화폐 사업 맞붙는다 한국은행이 조만간 발표 예정인 중앙은행 발행 디지털화폐 CBDC 파일럿 시스템 구축 사업을 두고 네이버와 카카오 두 IT 대기업들이 일제히 출사표를 던지면서 국내 CBDC 사업의 주도권을 잡을 기업에 관심이 쏠리고 있다. 한 금융업계 관계자는 “CBDC 플랫폼을 전국민이 체감할 수 있는 서비스로 만들기 위해 예산을 당초보다 늘리는 등 사업확장을 위해 일정이 지연되고 있는 것으로 안다”면서 “네이버와 카카오는 각각 자체 가상자산을 발행해 유통해본 경험이 있어 CBDC 플랫폼 구축에 최적화돼 있긴 하나, 동시에 최근의 비이상적인 가상자산 가격 급등 현상 속에 CBDC 사업이 이들 가상자산을 치솟게하는 요인으로 작용할까 우려하는 분위기도 감지된다”고 말했다. 5. 주문 제작 카카오메이커스, 이젠 호텔 예약까지주문 제작 카카오메이커스, 이젠 호텔 예약까지 카카오커머스의 주문 제작 플랫폼 ‘카카오메이커스(메이커스)’는 5월 한 달간 국내 유명 호텔 숙박 이용권 판매를 진행한다고 16일 밝혔다. 카카오커머스 관계자는 “수요를 사전에 파악할 수 있는 카카오메이커스의 장점을 살려 국내 여행을 준비하는 고객들을 위한 주문 예약 상품들을 확대하고 있다”며 “코로나로 인해 어려움을 겪는 국내 숙박 업소들에게 판로 확보와 더불어 사전 고객 수요를 예측할 수 있도록 도움을 제공하고 고객들에게는 좋은 혜택의 패키지 상품들을 지속적으로 선보일 것”이라고 말했다. 6. 파이썬 창시자 귀도 반 로섬 “최대 약점인 속도 4년 내 최대 5배 향상 예정”파이썬 창시자 귀도 반 로섬 “최대 약점인 속도 4년 내 최대 5배 향상 예정” 최근 미국 지디넷에 따르면, 파이썬 창시자인 귀도 반 로섬은 파이썬 랭귀지 서밋 2021(Python Language Summit 2021)에서 파이썬 속도 향상계획을 발표했다. 파이썬 속도 향상 프로젝트는 귀도 반 로섬이 지난해 입사한 마이크로소프트 산하 연구팀에서 주도하며, 인터프리터 코드를 최적화하는 핫파이(HotPy)와 호이파이2(HoyPy2) 등을 참조해 속도를 개선하는 한편, 과도한 속도 개선으로 인해 언어 기반을 무너트리지 않도록 기준도 마련하고 있다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-17-IT_News/"},{"title":"2021년 5월 10일 월요일 IT뉴스","text":"1. “문자도 철회 OK”…이통 3사 채팅+ ‘메시지 보내기 취소’ 기능 추가“문자도 철회 OK”…이통 3사 채팅+ ‘메시지 보내기 취소’ 기능 추가 : 네이버 뉴스 (naver.com) SK텔레콤과 KT, LG유플러스 등 이동통신 3사는 문자메시지와 그룹채팅, 대용량 파일 전송은 물론 선물과 송금하기도 가능한 메시징 서비스(RCS) ‘채팅+(채팅플러스)’의 신규 기능으로 ‘메시지 보내기 취소’를 선보인다고 10일 밝혔다. 이 기능은 상대방의 메시지 읽음 여부와 관계 없이 메시지 발송 5분 이내에 한해 사용할 수 있다. 2. 美국방부도 민간클라우드 쓰는데…한국은 “안돼”美국방부도 민간클라우드 쓰는데…한국은 “안돼” : 네이버 뉴스 (naver.com) 정부가 2025년까지 중앙부처와 지방자치단체, 공공기관의 약 1만개의 모든 정보 시스템을 클라우드로 전환하겠다고 밝힌 가운데 행정안전부가 민간 참여를 너무 소극적으로 해석하는 것 아니냐는 업계 반발의 목소리가 커지고 있다. 임종인 고려대 정보보호대학원 교수는 “민간을 믿지 못하겠으니 직접 한다는 건데 자꾸만 큰 정부를 지향하는 것은 시대정신에 역행하는 행정”이라며 “미국이 아마존과 MS 간 입찰을 붙이듯이 한국도 우수 민간기업들이 경쟁하는 기술입찰 방식으로 클라우드 산업을 선도하도록 해야 한다”고 밝혔다. 3. e커머스·테크핀·웹툰… 네이버-카카오 ‘디지털 영토 확장’ 정면승부e커머스·테크핀·웹툰… 네이버-카카오 ‘디지털 영토 확장’ 정면승부 : 네이버 뉴스 (naver.com) PC·모바일 플랫폼에서 꾸준히 격돌해온 양사가 전자상거래(e커머스), 테크핀(기술+금융), 웹툰 등 콘텐츠 분야에서 한판 승부를 예고한 것. 양사는 또 오프라인 상점 및 결제 영역을 디지털화하는 과정에서 시장 선점경쟁을 하는 한편 K-웹툰을 무기로 글로벌 사업 확대에 박차를 가할 전망이다. 4. 퀵서비스 시동 건 카카오, 대리·택시 판박이 갈등 예고퀵서비스 시동 건 카카오, 대리·택시 판박이 갈등 예고 : 네이버 뉴스 (naver.com) 퀵서비스 진출을 선언한 카카오모빌리티가 최근 배송기사 1만명을 모집하며 서비스 출시에 속도를 내고 있으며, 카카오의 플랫폼 영향력이 퀵서비스 시장과 이용행태에 상당한 변화를 불러올 것이라는 예상과 함께 대리기사, 택시에서처럼 기존 사업자와의 갈등 가능성도 제기되고 있다. 퀵서비스 업계 관계자는 “대기업 카카오가 퀵 시장에 들어오면 자본력을 바탕으로 단가를 낮추는 식으로 싸움을 걸 것으로 본다”며 “단가인하시 결국 퀵 기사에게 돌아오는 몫도 그만큼 줄어들게 될 것”이라고 말했다. 5. 애플이 왼뺨 때리자, 구글이 오른뺨을…허찔린 페북 광고시장애플이 왼뺨 때리자, 구글이 오른뺨을…허찔린 페북 광고시장 : 네이버 뉴스 (naver.com) 휴대폰에 깔린 애플리케이션(앱)이 사용자 개인정보를 얼마나 수집하는지를 알려주겠다는 것, 사용자 정보를 추적한 맞춤 광고로 돈 벌던 페이스북·알리바바 같은 업체에게는 뼈 아픈 소식이고, 아마존·쿠팡·네이버와 같이 자체 데이터를 보유한 이들에게는 기회라는 분석도 나온다. ‘서비스는 공짜, 돈은 광고로 번다’는 인터넷 비지니스모델(BM)이 흔들릴 것이며, 맞춤형 서비스를 제공하려면 여전히 사용자 데이터가 필요한데, 이를 확보하려는 경쟁은 더 치열해질 전망이고, 이제 그 가치가 높아질 것이다. 6. ‘단종설’ 선그은 갤노트, KT이어 유플도 줄줄이 몸값 낮춰‘단종설’ 선그은 갤노트, KT이어 유플도 줄줄이 몸값 낮춰 : 네이버 뉴스 (naver.com) 삼성전자가 통상 하반기에 선보여온 플래그십 스마트폰 ‘갤럭시 노트’ 시리즈를 올해 출시하지 않겠다고 밝힌 가운데 국내 이동통신사는 구형 모델의 재고 정리 수순에 돌입했다. 앞서 고동진 IM(IT&amp;모바일)부문장(사장)은 지난3월 삼성전자 정기주주총회에서 “S펜을 적용한 플래그십 모델을 1년에 두개 낸다는 것은 부담이 될 수 있어 하반기에는 출시가 어려울 수 있다고 생각한다”고 공식화했으며, 그는 “노트 카테고리는 지속적으로 해갈 것”이라고 단종설에는 선을 그었다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-10-IT_News/"},{"title":"2021년 5월 7일 금요일 IT뉴스","text":"1. IBM, 세계 최초 2㎚ 마이크로칩 개발 발표IBM, 세계 최초 2㎚ 마이크로칩 개발 발표 IBM은 6일 지금까지 개발된 것 중에서 가장 작고 가장 강력한 2㎚ 마이크로칩을 개발했다고 발표했다. IBM의 새로운 칩은 현재 사용되고 있는 7㎚ 칩보다 전력 소비를 75% 정도 줄이면서 성능은 45% 향상시킬 것으로 기대되고 있으며, 2㎚ 칩은 스마트폰 배터리의 사용 시간을 4배 늘릴 수 있고, 노트북 속도도 현저히 빠르게 구현할 것으로 보인다. 2. 장병규 크래프톤 의장, 전 직원에 1000억 규모 주식 무상 증여장병규 크래프톤 의장, 전 직원에 1000억 규모 주식 무상 증여 크래프톤의 최대 주주인 장병규 이사회 의장이 국내외 전 구성원 및 입사 예정자들에게 사재 주식을 무상 증여한다. 그는 우리사주조합 제도를 실시하지만, 법/제도상으로 국내에만 적용되고 해외법인 구성원들이 해당되지 않는 점 등 모두 함께 나눌 수 있는 특별한 방법을 찾아야만 했고, 글로벌 전체 구성원에게 감사한 마음을 나눌 수 있는 방법으로 사재 주식의 증여를 결심했다고 언급했다. 기업의 종업원이 자기 회사의 주식을 취득, 관리하기 위하여 조직한 조합. 3. “송가인 노래가 한가득!”…‘트로트 스마트폰’ 출시“송가인 노래가 한가득!”…‘트로트 스마트폰’ 출시 SK텔레콤은 KBS의 인기프로그램 ‘트롯전국체전’의 음원이 탑재된 시니어 전용 휴대폰 ‘갤럭시 A12 VIVA 트롯전국체전 에디션(이하 A12 VIVA 트롯)’을 7일부터 단독 출시한다고 밝혔다. 문갑인 SK텔레콤 스마트 디바이스 그룹장은 “이번 A12 VIVA 트롯은 시니어들이 선호하는 콘텐츠와 서비스를 보다 편하게 누릴 수 있도록 기획된 제품”이라며 “앞으로도 다양한 고객층의 요구와 사용성에 맞춘 합리적인 가격의 스마트폰을 지속 출시할 계획”이라고 말했다. 4. NHN, 자체 개발 AI 접목 ‘얼굴인식’ 서비스 출시NHN, 자체 개발 AI 접목 ‘얼굴인식’ 서비스 출시 NHN이 얼굴인식 서비스는 머신러닝 기술을 기반으로 양질의 얼굴 데이터셋 학습 과정을 통해 개발됐다. 이를 활용한 얼굴 감지·분석, 비교, 신원 인증 등이 가능하며, 향후 얼굴 식별이 필요한 금융, 의료, 커머스 등 다양한 온·오프라인 환경에서 맞춤형 서비스를 제공할 것으로 기대된다. 5. ‘갤버즈 프로’ 무슨 일이?…다수 사용자 외이도염·주변소리듣기 불량 호소‘갤버즈 프로’ 무슨 일이?…다수 사용자 외이도염·주변소리듣기 불량 호소 삼성전자가 올해 1월 갤럭시S21 시리즈와 함께 선보인 무선이어폰 갤럭시버즈 프로가 외이도염을 유발한다는 의혹이 국내외에서 동시다발적으로 제기되고 있다. 갤럭시버즈 프로 사용자 중에는 “(갤럭시버즈 프로를 끼다가) 이비인후과에서 외이도염 치료받고 완치받은 뒤 다시 갤럭시버즈 프로를 사용한지 하루 만에 재발했다”, “똑같은 인이어 타입 이어폰인 이전 갤럭시버즈를 사용할 때에는 하루종일 끼고 있어도 문제가 없었는데, 갤럭시버즈 프로에서 처음으로 외이도염에 걸렸다”고 밝힌 사람도 있었다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-07-IT_News/"},{"title":"2021년 5월 21일 금요일 IT뉴스","text":"1. 카카오재팬 6,000억 투자 유치···IPO 추진 본격화하나카카오재팬 6,000억 투자 유치···IPO 추진 본격화하나 카카오(035720)재팬이 홍콩계 사모펀드(PEF) 앵커에퀴티파트너스로부터 6,000억 원 규모의 투자를 유치했다고 20일 밝혔으며, 올해 일본 내 콘텐츠 기업이 유치한 외부 투자 중 최대 규모로 8조 8,000억 원의 기업가치를 인정받았다. 카카오재팬은 대규모 투자를 유치한 만큼 공격적인 투자에 나설 것으로 보이며, 투자 유치를 이끈 배재현 수석부사장(CIO)은 “이번 딜은 카카오 해외 자회사의 첫 투자 유치 사례이자, 올해 일본 콘텐츠 기업 중 최대 가치·최대 규모의 투자 유치라는 점에서 의미가 있다”며 “이번에 확보한 자원을 바탕으로 일본 뿐만 아니라 글로벌 경쟁력을 가진 지적재산권(IP)을 적극 확보하고, 잘할 수 있는 신사업에 공격적으로 투자해 카카오의 글로벌 영향력을 확대할 계획”이라고 밝혔다. 2. 네이버, 어제의 ‘적’이었던 은행이 동반자로…’합종연횡’ 확대네이버, 어제의 ‘적’이었던 은행이 동반자로…’합종연횡’ 확대 지난해까지만해도 금융사들 사이에서 네이버 등 빅테크 기업과 손잡는 것이 마치 업계를 배신하는 것처럼 금기시돼 온 것과 대조적인 분위기로 금융권에서 빅테크 기업의 성장세는 위협적이지만 국내 최대 규모의 네이버 플랫폼을 무조건 멀리하기보단 오히려 손을 잡고 활용해서 시너지를 내는 것이 더 주효하다는 판단으로 네이버가 주요 은행들과 손을 잡기 시작했다. 특히 네이버와 금융사 간의 합종연횡이 가속화되고 있다는 점을 주목할만하다. 신한은행: 네이버 부동산에서 전세 매물을 검색한 뒤 바로 신한은행의 대출까지 이어주는 기능을 도입 우리은행: 네이버 스마트스토어 사업자들을 위한 전용 신용대출 상품을 개발 중 미래에셋캐피탈: 스마트스토어 전용 대출 농협은행: 네이버클라우드와 손잡고 자사 은행 앱인 올원뱅크에 퍼블릭 클라우드 시스템을 도입 3. 코로나19에 웃고 울었다…이러다 ‘넷플릭스 천하’ 끝나나코로나19에 웃고 울었다…이러다 ‘넷플릭스 천하’ 끝나나 20일 코리안클릭에 따르면 넷플릭스의 MAU는 지난 1월 899만3785명에서 2월부터 하락 추세로 전환해 지난달 808만3501명까지 떨어졌다. 넷플릭스에 따르면 올해 1분기 전 세계 신규 가입자 수는 398만 명이었다. 지난해 같은 기간(1580만 명)의 4분의 1수준으로 시장 전망치(620만 명)를 크게 밑도는 수치다. 넷플릭스 “코로나19로 제작 지연, 성장률 둔화” 내달25일 ‘망사용료’ 소송 분수령 4. 굿바이 MS 익스플로러···내년 6월 지원 종료굿바이 MS 익스플로러···내년 6월 지원 종료 : 네이버 뉴스 (naver.com) MS는 공식 블로그에 내년 6월 15일부터 컴퓨터 운영체제인 윈도10의 모든 버전에서 IE를 쓸 수 없게 된다고 밝혔다. 다만 IE를 기반으로 만든 웹사이트를 지원하는 엣지의 ‘IE 모드’에서는 최소 오는 2029년까지 IE 사용을 가능하게 했다. 5. “배달의민족 형제들 결국 해체!”…쿠팡이 웃는다“배달의민족 형제들 결국 해체!”…쿠팡이 웃는다 : 네이버 뉴스 (naver.com) 국내 첫 배달앱 ‘배달통’이 오는 6월 24일 서비스를 종료한다. 지난 2010년 출시 후 약 11년 만이며, 배달통을 위탁 운영해온 독일 딜리버리히어로(DH)는 현재 요기요 매각도 앞두고 있어 DH가 운영 중인 배달앱 3사가 전부 찢어지게 됐다. 요기요의 주인이 누가 될지가 변수이긴 하지만, 결국 배달앱 시장은 배민과 쿠팡의 양강구도가 될 가능성이 크며, 원조 배달앱 강자 배민 홀로 쿠팡이츠와 대결을 펼칠 전망이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-21-IT_News/"},{"title":"2021년 5월 14일 금요일 IT뉴스","text":"1. 네이버, 한국은행 ‘디지털 원화’ 실험 참여네이버, 한국은행 ‘디지털 원화’ 실험 참여 네이버는 한국은행이 추진하는 ‘중앙은행 디지털화폐(CBDC)’ 모의실험에 자회사 라인플러스와 네이버파이낸셜을 참여시켰다. 우리나라도 한국은행이 올해 하반기에 CBDC를 발행, 유통, 결제, 송금, 환수, 폐기 등 화폐 생애주기별 처리 업무를 수행함으로써 화폐로서 제기능을 하는지 살펴보는 실험을 실시해 도입과 상용화 가능성을 연구하기로 했다. CBDC는 실제 화폐를 대체하거나 보완하기 위해 중앙은행이 직접 발행하는 디지털화폐다. 2. 삼성전자, 스마트폰 사업 인도 시장 우려 커졌다삼성전자, 스마트폰 사업 인도 시장 우려 커졌다 중국과 함께 스마트폰 최대 시장으로 꼽히는 인도는 하루 40만명 감염자가 속출하는 2차 확산세로 올 한해 시장 자체가 크게 축소될 거란 전망이 나왔다. 김종기 산업연구원 신산업실장은 “인도는 스마트폰 수요 시장으로 중요하고 삼성전자 생산 거점”이라고 강조했고, 이어 “중국 업체들이 온라인 판매 비중을 높여가고 있어서 삼성도 온라인 판매 비중을 높이면서 대응을 하겠으나 수요 심리 위축에 따른 판매량 감소는 분명 우려된다”며 “현지 5G 전환도 당초 계획보다 늦어질 수 있다”고 말했다 3. OTT 성장 둔화하나…디즈니+ 가입 증가 시장 기대 못 미쳐OTT 성장 둔화하나…디즈니+ 가입 증가 시장 기대 못 미쳐 13일(현지시간) 월스트리트저널(WSJ) 등의 보도에 따르면 디즈니는 지난달 3일 끝난 최근 분기의 디즈니+ 가입 증가 인원이 870만명으로, 총 가입자가 1억360만명이라고 발표했고, 이는 금융정보 제공업체 팩트세트가 전문가들을 상대로 조사한 전망치(1억930만명)에 크게 못 미치는 수준이다. 일각에서는 OTT 시장의 성장세 둔화가 시작된 것일 수 있다는 분석도 나왔으며, 디즈니 주가는 이날 시간 외 거래에서 4% 가까이 떨어졌다. 4. 카카오 3분 유머 영상 ‘톡드립’, MZ세대를 사로잡다카카오 3분 유머 영상 ‘톡드립’, MZ세대를 사로잡다 지난달 29일 카카오페이지 웹툰과 웹소설 탭 바로 옆에 신설된 ‘톡드립’은 카카오톡 대화 형식을 빌린 유머 콘텐츠와 3분 안팎의 숏폼 영상 콘텐츠들로 꾸려진 공간이다. 황선재 카카오엔터테인먼트 페이지컴퍼니 사업개발이사는 “‘톡드립’은 스토리가 다양하고 언제 어디서든 간편하게 즐길 수 있으며, 서비스가 카카오톡 형태로 직관적이라는 게 최대 장점”이라며 “기존 웹툰과 웹소설을 보던 카카오페이지 독자들의 유입 속도가 날마다 빨라지고 있다. 5. [취재수첩] 만연한 개인정보 유·노출, 심각성 인지하고 있나https://zdnet.co.kr/view/?no=20210511172039 [디지털데일리 이종현기자] 작년 통과된 데이터3법(개인정보보호법·신용정보법·정보통신망법)을 기점으로 정부 차원에서 데이터 활용을 적극 장려하는 추세이지만, 데이터 활용 활성화는 필연적으로 보호를 약화시킨다는 문제를 품고 있다. 최근 이를 잘 드러낸 사건이 인공지능(AI) 챗봇 서비스 ‘이루다’이고, 이루다의 개발사 스캐터랩은 양질의 서비스를 제공하기 위해 데이터를 수집·활용했지만, 그 과정에서 제대로 된 보호 조치가 이뤄지지 않아 개인정보 유·노출 및 오·남용 논란에 휩싸였다. 6. ‘머스크 입’에 놀아나는 암호화폐 시장…문제 없나‘머스크 입’에 놀아나는 암호화폐 시장…문제 없나 암호화폐 시장이 일론 머스크의 ‘입’에 놀아나고 있고, 종잡을 수 없는 말을 연이어 쏟아내면서 암호화폐 시장을 요동 치게 만들고 있다. “테슬라 차량 판매 때 당분간 비트코인을 받지 않겠다”고 선언해 암호화폐 시장에 찬물을 끼얹고, 이 선언 직후 암호화폐 시가총액이 순식간에 3천650억 달러(약 412조원) 빠지기도 했으며, “도지코인 개발자들과 거래 효율성을 높이기 위한 작업을 함께 하고 있다. 상당히 유망하다”는 글을 올린 후에는 순식간에 20% 이상 상승하면서 ‘머스크 효과’를 톡톡히 누렸다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-14-IT_News/"},{"title":"2021년 5월 24일 월요일 IT뉴스","text":"1. LG, 마지막 폰 ‘롤러블’ 제작하기로LG, 마지막 폰 ‘롤러블’ 제작하기로 : 네이버 뉴스 (naver.com) LG 고위 관계자는 23일 “혁신적인 제품으로 LG전자 스마트폰 사업 26년을 정리하자는 공감대가 이뤄졌다”며 “롤러블폰 수백 대를 제작할 계획”이라고 말했다. LG전자는 다만 롤러블폰을 시장에 내놓지는 않고, LG전자의 스마트폰 사업에 기여했던 내·외부 인사들에게 선물로 증정하는 방안이 유력한 것으로 알려졌다. 2. 농협은행, 디지털금융 표준플랫폼 구축 나서… “디지털뱅킹 구축 뼈대”농협은행, 디지털금융 표준플랫폼 구축 나서… “디지털뱅킹 구축 뼈대” : 네이버 뉴스 (naver.com) 클라우드를 기반으로 한 농협은행 대고객 서비스 인프라 전환 및 표준 플랫폼 전환을 위한 기능검증 등 2가지를 축으로 하는 사업으로 채널 슬림화, 법인분리, 시스템 현대화 및 신기술 도입 체계 마련 등이 병행된다. 디지털 금융 표준 플랫폼에 신기술 적용을 위해 퍼블릭 클라우드 환경 구축도 추진하며, 농협은행은 퍼블릭 클라우드 적용을 위해 요구사항 분석, 네트워크 설계, 클라우드 서버 환경룰 설계, 마이그레이션 패턴 전략 수립을 진행하는 한편 클라우드 수행을 위한 기술검증(PoC)에 나설 계획이다. 3. “1시간 수다 떨고 1억” 라이브커머스, IT 공룡 판으로 넘어가나“1시간 수다 떨고 1억” 라이브커머스, IT 공룡 판으로 넘어가나 : 네이버 뉴스 (naver.com) 실시간 영상인 스트리밍으로 상품을 파는 라이브커머스는 일반 쇼핑몰의 질의응답(Q&amp;A)이나 리뷰 등으론 한계가 있는 쌍방향 소통을 익명 채팅으로 나눌 수 있다는 게 가장 큰 특징이다. 라이브커머스 선점의 승패를 가르는 건 트래픽 확보인데, 일반적인 유통 기업들은 각 사 응용소프트웨어(앱)을 내려받을 수 있도록 만들어야 하는 진입장벽이 있는 반면 네이버와 카카오는 이미 전 국민이 이용 중이라고 해도 과언이 아닌 포털과 메신저 플랫폼을 쥐고 있어, 신세계, CJ 등은 그룹 통합몰이나 계열사별 별도 라이브커머스 서비스를 만들고 있지만 기본 트래픽 확보가 쉽지 않은 상황이다. 4. ‘신의직장’ 두번 박차고 6000억 잭팟…카카오 홀린 ‘K-웹툰 아버지’‘신의직장’ 두번 박차고 6000억 잭팟…카카오 홀린 ‘K-웹툰 아버지’ : 네이버 뉴스 (naver.com) 삼성전자를 퇴사하고 IT 스타트업에 합류해 키운 회사를 국내 기업 최초로 구글에 매각하고, 북미 최초 웹툰 플랫폼을 창업해 카카오엔터테인먼트에 6000억원에 매각한 인물. 이 모든 사연의 주인공은 한 사람, ‘북미 K-웹툰의 개척자’로 불리는 김창원 타파스미디어 대표의 이야기다. ‘누구나 작가가 될 수 있는 플랫폼’을 만들겠다던 그의 ‘작가 중심’(Creator First) 사업 전략은 IP 확보와 회사의 성장으로 이어졌고, 최근 ‘IP 확보 전쟁’이 막 오르며 타파스미디어가 카카오엔터테인먼트를 포함한 여러 플랫폼 기업의 러브콜을 받게 된 배경이다. 5. 지금 커닝 중, 표정만 봐도 안다···‘AI연구소’ 손잡은 KT·KAIST지금 커닝 중, 표정만 봐도 안다···‘AI연구소’ 손잡은 KT·KAIST 캐릭터가 사용자의 표정을 따라 움직이는 ‘이모지’에 적용되는 ‘페이스 랜드마크’ 기술이 진보하면 인공지능(AI)이 사람의 표정과 감정, 행동의 특징을 뽑아내 수업시간에 딴짓하는 학생, 온라인 시험 때 부정행위를 하는 수험생 등을 걸러낼 수 있으며, 나아가 반려동물이나 혼자 사는 어르신의 이상징후를 파악하고 대응하는 데도 활용될 수 있다. 원천기술과 관련해서는 음성ㆍ비전ㆍ휴머니스틱 AI(인간중심 AI) 등을 다루며, 이를 통해 사람과 유사한 대화와 추론이 가능하며 음성ㆍ영상ㆍ센싱 정보를 기반으로 상황을 판단하고 답변하는 AI 모델을 개발한다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-24-IT_News/"},{"title":"2021년 5월 19일 수요일 IT뉴스","text":"1. 랜섬웨어 피해 급증 ‘가상화폐 탓?’…정부 “예방이 최선, 사고 땐 빠른 신고”랜섬웨어 피해 급증 ‘가상화폐 탓?’…정부 “예방이 최선, 사고 땐 빠른 신고” : 네이버 뉴스 (naver.com) 과학기술정보통신부는 19일 최근 늘고 있는 랜섬웨어 공격에 대응해 24시간 신고 접수·분석 및 피해 복구를 위한 ‘랜섬웨어 대응 지원반’을 한국인터넷진흥원의 인터넷침해대응센터(KISC)에 설치한다고 밝혔다. 홍진배 과기정통부 정보보호네트워크정책관은 “랜섬웨어에 감염되면 사실상 데이터 복구가 불가능하기 때문에 무엇보다 외부 매체를 이용한 백업 등의 예방이 최선이며, 랜섬웨어 감염 등 침해사고 정황이 의심되는 경우 국번 없이 118센터 또는 인터넷 보호나라 침해사고 신고를 통해 기술지원을 받을 것을 당부한다”고 밝혔다. 2. 베일벗은 ‘안드로이드12’…확 바뀐 디자인에 개인정보 보호 강화베일벗은 ‘안드로이드12’…확 바뀐 디자인에 개인정보 보호 강화 : 네이버 뉴스 (naver.com) 안드로이드12에는 ‘머리티얼 유(Material You)’ 디자인이 적용됐으며, 잠금화면은 사용자의 상태에 따라 변화하며 알림 내용이 없을 때는 모든 일정이 끝났음을 알 수 있도록 화면 가운데 시계가 크게 표시된다. 안드로이드12에서는 사용자의 데이터에 접근하는 애플리케이션(앱)에 대한 투명성을 높이는 ‘사생활 대시보드(Privacy Dashboard)’ 기능이 추가됐고, 사생활 대시보드에서는 사용자 데이터에 접근하는 앱과 접근하는 데이터, 접근 빈도, 접근 허용 설정까지 한 눈에 확인할 수 있으며, 앱 접근에 대한 허용을 간단하게 제어할 수도 있다. 3. 구글 “삼성전자와 스마트워치 OS 통합…성능·배터리 강화”구글 “삼성전자와 스마트워치 OS 통합…성능·배터리 강화” : 네이버 뉴스 (naver.com) 구글은 이날 미 캘리포니아주 마운틴뷰 본사에서 온라인으로 개최한 ‘구글 I/O(연례 개발자회의) 2021’에서 그동안 구글과 삼성이 각각 써오던 ‘웨어 OS’과 ‘타이젠’을 통합하기로 했다고 발표했습니다. 사마트는 “이 플랫폼은 구글과 삼성뿐 아니라 다른 기기 메이커에도 개방될 것”이라고 밝혔고, 삼성 모바일의 고객경험실장 패트릭 초메이도 영상으로 등장해 “삼성과 구글이 성능을 최적화하기 위해 긴밀히 협력하고 있다”며 “이는 더 나은 반응성과 더 긴 배터리 수명을 뜻한다”고 말했습니다. 4. 한국인 인스타그램보다 ‘당근마켓’ 자주 썼다한국인 인스타그램보다 ‘당근마켓’ 자주 썼다 : 네이버 뉴스 (naver.com) 국인이 가장 많이 사용한 앱은 ‘카카오톡’으로 조사됐고, 인스타그램보다 중고거래 플랫폼 ‘당근마켓’을 더 자주 사용했다는 결과도 나왔다. 전 세대를 합쳐 가장 오랜 시간 사용한 앱은 유튜브로 총 680억분 사용한 것으로 조사됐다. 5. ‘폭풍 성장’ 카카오뱅크…50대 이상 이용자가 ‘숨은 공신’‘폭풍 성장’ 카카오뱅크…50대 이상 이용자가 ‘숨은 공신’ : 네이버 뉴스 (naver.com) 올해 1분기 카카오뱅크의 당기순이익은 지난해 동기(185억원) 대비 152.43% 늘어난 467억원을 기록했고, 올해 1분기 말 기준 카카오뱅크 이용자수(계좌 미개설 서비스 이용 고객 포함)는 1615만명이었다. 눈에 띄는 것은 기존의 주 타깃층이던 20~30대 이용객 비중은 줄고 있지만 50대 이상의 중장년층은 늘었다는 점이며, 카카오뱅크의 올해 1분기 연령별 비중을 보면 50대 이상 이용자가 전체의 15%를 차지했다. + SKB·넷플릭스 소송 핵심 ‘망중립성’ 뭐길래…미국서도 논란SKB·넷플릭스 소송 핵심 ‘망중립성’ 뭐길래…미국서도 논란 : 네이버 뉴스 (naver.com) 망중립성 개념은 구글 페이스북 아마존 넷플릭스 등이 거대 기업으로 성장할 수 있었던 주요 배경으로 꼽힌다. ISP가 구축한 네트워크를 기반으로 트래픽을 유발하며 성장했지만 접속료 외의 추가 비용은 내지 않았기 때문이다. 급증한 트래픽에 대한 비용을 내야 한다(SK브로드밴드)는 입장과 망 이용대가는 이중과금(넷플릭스)이라는 입장이 팽팽하게 맞섰다. 망중립성 완화를 주장하는 측은 인터넷 통신망이 공공재가 아니라 정보 서비스이며 통신망을 효율적으로 분배해야 자율주행과 같은 사물인터넷(IOT) 기술이 발달할 수 있다고 본다. 반면 망중립성에 찬성하는 측은 인터넷은 누구나 접근할 수 있도록 개방돼야 하며 모든 트래픽은 공평하게 처리해야 공정한 경쟁이 가능하다고 반론을 편다. 미국에서 망중립성은 정권의 정치적 성향에 따라 움직였다. 망중립성 원칙은 소비자 권리와도 직결된다. ISP가 통신사에게 망사용료를 받는다면 소비자가 내는 통신비용과 콘텐츠 이용요금에도 변화가 생길 가능성이 높다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-19-IT_News/"},{"title":"2021년 5월 26일 수요일 IT뉴스","text":"1. 카카오도 공공 클라우드 시장 뛰어든다…네이버·KT와 한판 승부카카오도 공공 클라우드 시장 뛰어든다…네이버·KT와 한판 승부 : 네이버 뉴스 (naver.com) 25일 업계에 따르면 카카오의 B2B IT자회사인 카카오엔터프라이즈가 내달 말 ‘카카오 아이(i) 클라우드’ 서비스 정식 출시를 앞두고 한국인터넷진흥원(KISA)의 클라우드 보안 인증(CSAP) 취득을 위한 심사를 받고 있다. 카카오가 늦게라도 공공 시장을 비집고 들어가려는 건 시장이 급격히 커지고 있기 때문으로 해석되며, 실제로 모든 공공기관의 IT시스템은 올 하반기를 시작으로 오는 2025년까지 클라우드로 전환될 예정이고 여기에 공공 시장은 클라우드 보안 인증이라는 ‘장벽’으로 국내에서만 1조원 가량의 매출을 거두는 것으로 추정되는 아마존웹서비스(AWS) 등 글로벌 클라우드 기업이 진입하지 못하는 만큼 국내 기업들에는 ‘기회의 땅’이다. 2. 빅테크-대기업 ‘초거대 동맹’ 구글 · 아마존의 독주 막는다빅테크-대기업 ‘초거대 동맹’ 구글 · 아마존의 독주 막는다 : 네이버 뉴스 (naver.com) 코로나19 이후에도 빅테크 기업으로 살아남기 위해 네이버는 CJ, 신세계, 미래에셋 등과 플랫폼 동맹을, 카카오는 SK텔레콤, 삼성전자, SAP 등과 기술 동맹에 나섰다. IT업계 관계자는 “코로나19로 인해 시장 재편이 빨라지면서 업종별 1,2위도 굳어져 가는 상황”이라며 “이제는 누가 누구와 손을 잡고 시장을 선점하느냐의 싸움이기 때문에 대기업 간 지분스와프 같은 혈맹이나 스타트업과의 M&amp;A 움직임은 당분간 지속될 것으로 보인다”고 전망했다. 3. ‘구글 천하’ 개인용 클라우드 시장…이통3사, 줄줄이 ‘백기’‘구글 천하’ 개인용 클라우드 시장…이통3사, 줄줄이 ‘백기’ : 네이버 뉴스 (naver.com) 이동통신 3사가 개인 클라우드 시장에서 사업을 종료한 가장 큰 원인은 국내 개인 클라우드 시장을 구글, 마이크로소프트(MS), 드롭박스 등 글로벌 사업자들이 주도하게 됐기 때문이다. 이동통신3사는 공공·금융클라우드 등, 클라우드에서도 최근 강화하고 있는 기업간거래(B2B) 분야 쪽으로 무게추를 옮기고 있다. 4. “내 손 안에 홈쇼핑 시대” 네이버 vs 카카오 ‘라방 대결’…1년 성적표는“내 손 안에 홈쇼핑 시대” 네이버 vs 카카오 ‘라방 대결’…1년 성적표는 : 네이버 뉴스 (naver.com) ‘개방’과 ‘중소사업자(SME) 지원’에 방점을 찍은 네이버는 콘텐츠와 누적 시청횟수에 압도적인 ‘라이브커머스계 공룡’으로 우뚝 섰고, ‘국민 SNS’ 카카오톡에 서비스를 집어넣은 카카오는 하루 방송을 5회로 제한, ‘검증된 고품질 방송’을 고수하고 있다. 카카오커머스 관계자는 “카카오 쇼핑라이브는 ‘퀄리티 있는 방송’을 지향하고 있다”며 “방송장비부터 브랜드 선정까지 카카오의 통제하에 진행하고 있다”며 “이용자가 일부러 시간을 내서 방송을 보는 것이기 때문에 일정 수준 이상의 방송을 제작·방영하려고 한다”이라고 말했다. 네이버 관계자는 “플랫폼과 기술이 모두에게 열려있는 개방성이 네이버 쇼핑라이브의 가장 큰 특징”이라며 “플랫폼에서 기술을 쥐고 있는 게 아니라 기술이 필요한 중소사업자(SME) 누구나 쓰도록 개방하면서 전국에서 휴대전화만 있으면 라이브 방송을 할 수 있는 환경을 만들어왔다”고 말했다. 5. 어도비 “개인화된 고객경험 제공이 디지털 경제 시대 성패 가른다”어도비 “개인화된 고객경험 제공이 디지털 경제 시대 성패 가른다” : 네이버 뉴스 (naver.com) 어도비코리아 대표는 코로나19 이후 디지털화가 가속화된 비즈니스 환경을 언급했다. 우 대표는 “디지털 경제 시대에는 개인화된 고객경험을 통해 강력하고 지속적인 고객 관계를 구축한 기업만이 살아남을 수 있을 것”이라고 말했다. 앞으로는 CXM이 비즈니스 성패를 가를 가능성이 커진 만큼, 기업 규모와 관계없이 어도비 익스리언스 클라우드와 같은 CXM 솔루션을 도입하는 사례는 더욱 늘어날 것으로 보인다. 6. 알파고 넘는 ‘초거대 AI’ 개발 경쟁 가열…네이버 이어 KT·SKT·카카오·LG 참전알파고 넘는 ‘초거대 AI’ 개발 경쟁 가열…네이버 이어 KT·SKT·카카오·LG 참전 : 네이버 뉴스 (naver.com) 새로운 인공지능(AI) 시대가 열리고 있다. 한국의 AI 기술이 글로벌 플랫폼에 종속되지 않기 위해서는 이미 공개된 기술을 따라잡는 수준에 그칠 수 없다고 판단했다. 정석근 네이버 클로바 대표 이제 이 기술을 선점하는 일이 중요해졌다. 이 기술을 확보하지 못하면 다른 기업의 모델을 사서 써야 하기 때문에 AI 기술 자립도가 떨어지고 앞으로의 경쟁에서 밀릴 수밖에 없다. KT 관계자 26일 IT업계에 따르면 최근 네이버, KT, SK텔레콤, 카카오, LG가 잇따라 자체 개발한 초거대 AI를 공개하거나 개발 계획을 발표했다. 초거대 AI는 대용량의 데이터를 빠르게 처리할 수 있는 슈퍼컴퓨터를 기반으로 딥러닝(심층학습) 효율을 크게 높인 차세대 AI다. 네이버, 美 GPT-3 뛰어넘는 국내 최초 모델 공개…”신기술 주도권 잡겠다”네이버는 자사의 초거대 AI ‘하이퍼클로바’의 파라미터가 GPT-3(1750억개)보다 많은 2040억개라고 밝혔다. 자연어(영어·한국어 등 일상에서 쓰는 언어) 데이터 학습량은 GPT-3의 6500배 이상이다. 네이버는 “GPT-3가 영어 중심으로 학습해 국내 기업들이 도입하기엔 한계가 있지만, 하이퍼클로바는 학습 데이터의 97%가 한국어다”라며 “우리나라가 AI 주권을 확보한다는 의미도 있다”고 했다. KT·SKT·카카오·LG 추격…정부 지원책 마련 중과기정통부는 또 초거대 AI가 결국 슈퍼컴퓨터 구축을 위한 자본 싸움이 될 경우 국내 기업이 글로벌 빅테크에 밀릴 수 있다는 점을 고려해, 작은 규모로도 높은 성능을 낼 수 있는 초거대 AI 이후의 AI를 연구하는 ‘사람 중심 AI 실현을 위한 차세대 AI 핵심 원천기술 개발’ 사업을 내년부터 5년간 시행한다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-26-IT_News/"},{"title":"2021년 5월 31일 월요일 IT뉴스","text":"1. 삼성전자보다 매출 낮은 TSMC, 시총 2배 가까이 ‘껑충’삼성전자보다 매출 낮은 TSMC, 시총 2배 가까이 ‘껑충’ 대만의 파운드리 기업 TSMC와 삼성전자가 나란히 시총 1, 2위 자리를 유지했지만. 1년 전 근소했던 두 회사간 시총 격차는 지난해 100억9천100만달러에서 현재 1천178억8천300만달러로 벌어졌다. 그래픽 반도체 전문 회사에서 최근 중앙처리장치(CPU) 등으로 영역을 확장하고 있는 엔비디아는 미국 반도체 시총 1위 기업으로 1년 새 주가가 81.8%나 급등하며 삼성전자를 무섭게 뒤쫓고 있다. 2. “콧대 높던 애플이 달라졌다?”… ‘삼성 텃밭’ 한국에 공들인다“콧대 높던 애플이 달라졌다?”… ‘삼성 텃밭’ 한국에 공들인다 제품 가격, 서비스에 인색했던 애플이 한국 시장에 공을 들이고 있으며, LG전자의 스마트폰 사업 철수를 겨냥, 삼성 텃밭인 한국에서 점유율을 본격적으로 높이기 위한 것으로 보인다. 한국에서 대규모 매장 애플 스토어의 대대적인 확장에도 나섰다. 최근 여의도에 국내 2번째 애플 스토어를 만들었고, 서울 명동에 3호점 개장도 준비 중인 것으로 알려졌다. 3. [마이데이터 시대] ③ 페이코 “구글 플레이·애플 앱스토어 경험이 강점… 결제 기능에 주력”[마이데이터 시대] ③ 페이코 “구글 플레이·애플 앱스토어 경험이 강점… 결제 기능에 주력” 마이데이터 1차 허가 취득사 중 ‘결제’ 기능에 주력하는 핀테크사는 NHN의 자회사인 NHN페이코가 유일하다. 페이코 마이데이터 사업을 총괄하는 오보명 이사는 “차기 버전 콘셉트는 2030을 위한 쉽고 가벼운 금융 서비스”라고 요약했다. 8월부터 새 서비스 출시와 관련한 타임라인이 궁금하다. 금융 행위와 관련해 적재적소에 푸쉬 알림을 띄우는 ‘금융 버디’라는 서비스도 선보인다. 다양한 데이터를 통해 자신의 금융 상태를 조회만 한다고 해서 끝나는 것이 아니다. 그것을 해석하는 작업이 중요하다. 마이데이터 사업이 회사에는 어떤 도움이 될까. “마이데이터 사업은 당장 돈이 되지 않는다. 다만, 토스라는 좋은 경쟁사에서 보여줬던 점이 있다면 금융상품을 중개하는 것으로도 당장 매출이 발생한다는 것이다. 스스로가 금융기관이 아니더라도 서비스를 잘 운영해서 상품을 입점시키고 고객에게 소개했을 때 수반되는 판매·광고 수수료가 매출로 잡힌다. 당장 매출보다는 좀 더 장기적인 시각으로 사업 확장성을 높게 평가하고 있다. 마이데이터와 관련해 전 산업군에서 금융·핀테크 쪽이 먼저 움직이고 있다는 점은 고무적이다. 여기서부터 관련 산업들이 다수 파생될 거라고 보며, 오프라인 유통 산업군이나 정보기술(IT) 접목이 빈약한 곳들은 향후 마이데이터 라이선스를 선점한 곳과 제휴를 할 수 있을 거라고 본다. 마이데이터 사업이란 여러 금융회사 등에 흩어진 개인 신용 정보를 한곳에 모아 활용할 수 있도록 하는 것이다. 기존에는 특정 서비스를 구현하기 위해 한 업체가 자체적으로 보유한 데이터만을 활용할 수 있었다면, 마이데이터 시대에서는 모든 금융사가 보유한 데이터를 활용해 새로운 서비스를 선보일 수 있다. 활용할 수 있는 데이터 풀(pool)이 넓어지고 획일화된 대신, 어느 때보다 차별점이 중요해졌다. 4. 네이버 개발자 죽음의 증언…IT업계선 “바닥 좁고 학연 세다”네이버 개발자 죽음의 증언…IT업계선 “바닥 좁고 학연 세다” : 네이버 뉴스 (naver.com) 네이버 ‘ESG보고서’에 따르면 지난해 With U(6건), kNock(2건)을 통해 접수된 직장 내 괴롭힘 관련 고충은 모두 내부 규정에 따라 처리 완료됐으며, 지난해 열린 ‘직장 내 괴롭힘 예방교육’에도 전 직원이 참여해 100% 수료했다. 국내 스타트업계 한 관계자는 “수평적 조직문화가 잘 운영되려면 제도도 중요하지만 윗선의 역할도 중요하다”며 “결국 제도도 사람이 운영하는 것”이라고 지적했다. IT기업 내 구조적 문제점을 지적하는 목소리도 있다. 특히 개발자 사회의 경우 특정 학교 출신의 입김이 강한데 이들의 ‘끼리끼리’ 문화가 조직 내 억압 구조를 강화했을 가능성이 있다는 분석이며, 국내 한 IT 기업 임원은 “개발자 사회가 생각보다 좁고 관리자급은 학연이나 전 직장 근무이력 등으로 연결된 경우가 많다”며 “상사의 평가가 부정적일 경우 다른 회사로 옮기기 쉽지 않기 때문에 조직 내에서 자유롭게 소통하는 게 말처럼 쉽지 않다”고 말했다. ‘With U’ 익명 채널, ‘kNock’ 사내 통합 채널","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-31-IT_News/"},{"title":"2021년 5월 28일 금요일 IT뉴스","text":"1. 카카오, 음성 커뮤니티 서비스 ‘사운드K(가칭)’ 준비카카오, 음성 커뮤니티 서비스 ‘사운드K(가칭)’ 준비 : 네이버 뉴스 (naver.com) 27일 업계에 따르면 카카오는 클럽하우스와 닮은꼴인 음성 커뮤니티 서비스 ‘사운드K(가칭)’을 준비 중으로 올 여름 출시로 예상된다. 현재 인터넷 업계에선 음성 커뮤니티 시장에 앞다퉈 주목하는 상황으로 트위터가 음성 채팅이 가능한 ‘스페이스’를 선보였고 올 여름 페이스북이 ‘라이브 오디오룸’ 적용을 예고하는 등 음성으로 사람 간 관계를 맺는 기능이 속속 시험대에 오른다. 2. 네이버·카카오·통신사, ‘전기 먹는→저탄소·친환경’ IDC 구축 전쟁네이버·카카오·통신사, ‘전기 먹는→저탄소·친환경’ IDC 구축 전쟁 : 네이버 뉴스 (naver.com) 최근 공공과 기업의 디지털전환이 가속화되면서 통신3사와 네이버, 카카오 등 IT기업들이 ‘친환경’ 인터넷데이터센터(IDC) 경쟁에 뛰어들었고, IDC 선점 경쟁은 최근 사물인터넷(IoT), 인공지능(AI) 등 데이터 처리 시장이 성장하고, 공용 클라우드 수요 증가로 데이터 센터 중요성 확대되고 있기 때문으로 풀이된다. IDC 전력 소모량 상당해 ‘탄소 배출’ 부담 커져…친환경 노력 각양각색 KT의 용산 IDC는 냉수식 항온기, 냉수식 프리쿨링과 더불어 냉각팬, 인버터 방식의 고효율 설비를 갖춰 냉방용 전력비를 기존 대비 20% 이상 절감 LG유플러스는 지난 12일 1분기 실적발표 컨퍼런스 콜에서 경기도 안양 신규 IDC와 관련 친환경 설비를 강화할 것이란 계획 네이버는 외부 경관 조명과 온실 난방에 태양광 및 태양열 발전을 이용하고, 차가운 공기와 지하수를 이용해 서버를 식히는 친환경 기술인 AMU(Air Misting Unit) 및 NAMU(NAVER Air Membrane Unit) 개발을 통한 자연 냉각 시스템을 활용 카카오가 2023년 준공 예정인 안산 데이터센터는 설계 단계에서부터 친환경 요소를 적용했다. 친환경 설계로 에너지효율등급 1등급을 획득하고, 재생에너지 인프라를 구축하고 냉각 전력 효율 향상을 위한 설비를 적용할 예정 3. 카카오엔터, 아이앤아이소프트 250억에 인수카카오엔터, 아이앤아이소프트 250억에 인수 : 네이버 뉴스 (naver.com) 27일 업계에 따르면, 카카오엔터는 아이앤아이소프트 지분 100%를 250억원에 인수한 것으로 알려졌다. 카카오엔터 관계자는 “현재 회사는 카카오TV에 오리지널(자체) 영상 콘텐츠를 올리는 등 영상 사업을 하고 있다”라면서 “아이앤아이소프트의 기술을 이런 사업에 적용할 수 있을 것”이라고 기대했다. 아이앤아이소프트는 미디어 스트리밍을 위한 솔루션·서비스를 개발, 통신사, 온라인동영상서비스(OTT) 등에 공급하고 있다. DRM(디지털 콘텐츠 저작권 보호 기술) 기술도 갖고 있는 것으로 알려졌다. 4. 도마 오른 ‘포털 알고리즘 공정성’…“투명하게 공개” “남용 우려”도마 오른 ‘포털 알고리즘 공정성’…“투명하게 공개” “남용 우려” : 네이버 뉴스 (naver.com) ◆ 전문가들, 알고리즘 투명성 위한 규제 필요성 공감 이날 전문가들은 알고리즘의 투명성을 위한 규제 필요성에 대해 공감하면서도 기술적 자율성 보장과 사회적 합의가 선행되어야 한다는 의견을 냈다. 최경진 교수는 “알고리즘은 도구일 뿐이라는 가치중립적 시각과, 알고리즘은 사람의 설계에 따라 다른 결과를 낼 수 있는 가치내재성이 있다는 시각이 있다”고 소개하며 “가치 중립성 차원에서는 자율성을 보장해야 하지만, 한편 가치내재적 측면에서는 투명성을 확보해야 하므로 두가지를 모두 고려한 입법 노력이 필요하다”고 지적했다. ◆ “알고리즘 검증 필요하나, 남용 가능성도 고려해야” 알고리즘 공개 범위에 대해서도 뚜렷한 결론을 내지 못했다. 최경진 교수는 “실제 검증 과정에서 나온 데이터를 일반에 공개하는 게 바람직하냐고 했을 때, 검증은 필요하나 자칫 남용 가능성도 있다는 점을 고려해야 한다”고 제언했다. 김동원 언론노조 정책실장은 “저널리스트나 일반 학자들, 이용자들이 이용할 수 있을 정도 수준의 투명성 보고서를 포털이 제출했으면 좋겠다”면서 “현재 뉴스 배열 알고리즘으로는 심층 기사나 좋은 기사를 솎아낼 수 없다는 한계를 네이버와 카카오가 인정할 필요가 있다”고 말했다. ◆ 네이버·카카오 “자율적인 알고리즘 검증 시행 중” 최재호 네이버 이사는 “앞서 언론학·컴퓨터공학 교수님들 모시고 최초로 알고리즘 검증을 시행한 바 있다”며 6개월간의 분석 끝에 알고리즘에 인위적 개입은 불가능하다는 결론을 냈다. 김희정 카카오 실장은 알고리즘 공개와 관련한 논의들이 사회적 합의를 이룬다면 적극 검토하겠다”고 밝혔다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-28-IT_News/"},{"title":"2021년 5월 12일 수요일 IT뉴스","text":"1. 카드업계 ‘페이’ 상호개방 합의…”네이버·카카오페이에 대응”카드업계 ‘페이’ 상호개방 합의…”네이버·카카오페이에 대응” 11일 카드업계에 따르면 6개 전업 카드사와 BC카드, 농협은행 NH농협카드는 최근 카드사 모바일협의체 회의에서 각사의 간편결제시스템 개방에 원칙적으로 합의한 것으로 전해졌다. 중소 카드사가 간편결제 앱 이용자 감소 가능성에도 개방에 합의한 것은 카카오페이와 네이버페이에 밀릴 수 있다는 위기의식 때문이다. 2. 이쯤되면 고의? 넷플릭스, 또 한국 역사 왜곡·비하 번역 논란이쯤되면 고의? 넷플릭스, 또 한국 역사 왜곡·비하 번역 논란 : 네이버 뉴스 (naver.com) 넷플릭스는 일본해 표기 논란뿐 아니라 해외 콘텐츠 한국어 자막오류, 번역 논란, 조세회피 의혹 등 계속되는 논란에 휘말렸고, 이미 다수의 커뮤니티에서 수많은 자막 오역이 지적돼 온 것. 반크는 “한류 열풍으로 전 세계 한류 팬이 1억명을 돌파하고 특히 넷플릭스에서 방영하는 한국 드라마와 영화에 대한 외국인의 관심이 높아진 지금 영상 매체 속 한국 관련 오류를 조기에 발견하고 시정하는 일이 중요하다”고 지적했다. 3. “2~3일 걸리던 고객층 분석, AWS 클라우드 도입으로 1~2분으로 단축”“2~3일 걸리던 고객층 분석, AWS 클라우드 도입으로 1~2분으로 단축” : 네이버 뉴스 (naver.com) 홍성봉 아모레퍼시픽 상무는 AWS 클라우드를 도입한 아모레퍼시픽의 성과를 소개했다. 홍 상무는 “커머스, 마케팅 담당자의 관점에서, 누가 어떤 제품을 구매했고 이들의 공통점이 무엇인지 파악하는 게 중요하다”며 “하지만 여기엔 많은 검색 조건 등 빅데이터가 필요하다”고 말했다. 홍상무는 “2~3일 걸리던 고객층 분석 작업을 아마존웹서비스(AWS) 클라우드를 도입한 지 1년 반 만에 1~2분으로 단축하는 데 성공했다”며 “AWS의 기술 지원은 앞으로도 기업들의 혁신을 도울 것이다”라고 밝혔다. 4. [실밸레이더] 구글·애플·인텔·아마존이 뭉쳐 반도체 로비 단체 만들었다[실밸레이더] 구글·애플·인텔·아마존이 뭉쳐 반도체 로비 단체 만들었다 : 네이버 뉴스 (naver.com) 11일(현지시각) 뉴욕타임스와 로이터 등 외신은 인텔과 엔비디아, 퀄컴 등 칩 제조업체와 애플, 구글, 마이크로소프트, 아마존 등 이 칩을 구입해 사용하는 테크 기업이 모여 새로운 그룹인 ‘미국 반도체 연합(Semiconductors in America Coalition)을 결성했다고 보도했습니다. 이 기업들이 한 연합체로 뭉친 것은 이례적으로 뉴욕타임스는 “기업들이 반도체 연합을 통해 연방정부의 지원을 받고 반도체 연구와 제조를 추진하려는 목적”으로 함께 뭉쳐서 정부 보조금을 따내기 위한 임시 단체인 것이며, 로이터는 더 노골적으로 “정부의 반도체 보조금을 요구하는 로비 그룹”이라고 했습니다. 5. AWS·구글 등 러스트 도입 박차…C++ 대체하나https://zdnet.co.kr/view/?no=20210511172039 러스트는 C와 C++의 퍼포먼스를 유지하며도 메모리 버그를 방지할 수 있어 두 언어를 대체할 지 주목받고 있으며, 시스템 및 인프라 개발 분야에서 인기몰이 중이다. 현재 가장 러스트를 적극적으로 활용하고 있는 기업은 AWS이고, 소프트웨어 및 하드웨어 개발, 지원 엔지니어링, 시스템 및 보안 엔지니어링을 비롯해 람다, 서버리스 컴퓨팅 등 다양한 분야에 러스트를 도입을 고려하고 있으며, 이를 위해 러스트 전문 개발자 모집에도 박차를 가하는 중이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-05-12-IT_News/"},{"title":"2021년 6월 02일 수요일 IT뉴스","text":"1. 카카오, 주52시간 초과 근무 등 근로기준법 위반카카오, 주52시간 초과 근무 등 근로기준법 위반 : 네이버 뉴스 (naver.com) 카카오는 1일 “중부지방고용노동청 성남지청이 지난 4월 카카오에 대한 근로감독을 실시한 결과 최근 근로기준법 등 6개 항목을 위반한 사실을 확인, 시정할 것을 요구했다”고 밝혔다. 업계에 따르면 일부 직원에게 주52시간 이상 초과 근무를 시킨 것뿐만 아니라, 임산부에게 시간 외 근무를 시켰고 일부 직원에게 연장근무 시간을 기록하지 못하게 했으며 퇴직한 직원에게 수당을 제때 지급하지 않은 것으로 알려졌다. 2. 퀵서비스 진출 카카오 T…물량공세로 선전포고퀵서비스 진출 카카오 T…물량공세로 선전포고 : 네이버 뉴스 (naver.com) 1일 업계에 따르면 카카오모빌리티는 최근 카카오 T 애플리케이션에 ‘퀵’ 탭을 신설하고 사전등록 이벤트를 시작했으며, 내부적으로 서비스 정식 출시 시점은 이달 말에서 다음 달 초가 거론되고 있다. 사전등록 이벤트는 일반인, 기업, 퀵 배송 기사를 대상으로 하고, 일반인의 경우 퀵·택배를 사전 등록할 경우 선착순 2만명에게 카카오 캐릭터가 새겨진 가방과 키링, 스티커, 박스테이프 등 ‘웰컴키트’를 지급한다. 퀵서비스 업계 관계자는 “예상한대로 대기업 카카오가 퀵 시장에 들어오면서부터 자본력을 바탕으로 공격적인 모습을 보이고 있다”며 “플랫폼에 많은 사람을 합류시키고 궁극적으로는 단가를 깎는 등의 상황이 벌어질까하는 우려도 있다”고 말했다. 3. 상사 괴롭힘에 극단선택…네이버 관련 임원 직무정지상사 괴롭힘에 극단선택…네이버 관련 임원 직무정지 1일 업계에 따르면 이번 사건을 조사하는 네이버 리스크관리위원회는 최인혁 최고운영책임자(COO)와 해당 피해 직원에 대한 직장 내 괴롭힘 가해자로 지목된 책임 리더 등의 직무정지를 권고했으며, 네이버는 이 권고를 수용해 임원의 직무를 정지시키기로 했다. 정보기술(IT) 업계에 따르면 네이버 ‘윗선’이 회사 안팎의 반대 의견에도 불구하고 과거 직장 내 괴롭힘 등 문제 소지가 있는 행동을 한 임원의 재입사를 허용했고, 이후 A씨 조직 내 직원들이 우려를 전달했지만 사실상 묵살했다는 의혹이 제기되고 있고, 이번에 직무 정지된 임원들은 이 윗선에 해당되는 것으로 알려졌다. 4. [단독] 디즈니플러스, LG유플러스 ‘낙점’했다…올 가을 한국 상륙[단독] 디즈니플러스, LG유플러스 ‘낙점’했다…올 가을 한국 상륙 : 네이버 뉴스 (naver.com) 1일 미디어 업계에 따르면 디즈니플러스는 최근 IPTV 사업자로 LG유플러스를 낙점하고 계약을 앞두고 있는 것으로 확인됐다. 그동안 디즈니플러스는 서비스 론칭을 앞두고 국내 통신업체들과 협의를 거듭해 왔다. 9월 한국에서 정식 서비스 일정을 맞추기 위해선 상반기 내 계약의 마무리가 필요했고, 특히 LG유플러스가 아이들나라를 비롯한 유아 콘텐츠에 힘을 싣고 있다는 점에서 디즈니의 전략과 일치하는 점도 있다. 5. 넥슨, 1년 이상 전환 배치 중인 직원들 대기 발령…노조 반발(종합2보)넥슨, 1년 이상 전환 배치 중인 직원들 대기 발령…노조 반발(종합2보) : 네이버 뉴스 (naver.com) 1일 넥슨 노사에 따르면 넥슨과 자회사 네오플은 기존 프로젝트가 사라져 다른 업무로 재배치 중인 직원들을 대상으로 임금을 삭감하고 대기 발령을 내자 노동조합이 반발하고 있다. 넥슨 측은 이번 대기 발령 대상자들에게 1년이 넘도록 다른 업무에 지원할 기회를 충분히 줬다는 입장으로 회사 관계자는 “대기발령에 앞서 1년 이상 전환배치에 지원할 수 있도록 적극적으로 지원했으나 지원할 수 있는 포지션에는 대부분 지원한 상황”이라며 “이를 감안해 해당 직원들이 집중적인 역량향상 기회를 가질 수 있도록 한 것”이라고 말했다. 게임업체에서는 하나의 개발 프로젝트가 끝나거나 중도에 무산될 때 인력을 다른 업무로 배치하는 과정에서 종종 노사 간 갈등이 빚어지곤 한다. 6. Google’s speedier internet standard is now an actual standardGoogle’s speedier internet standard is now an actual standard 인터넷 엔지니어링 타스크 포스는 구글의 QUIC(Quick UDP 인터넷 커넥션) 표준을 공식 인터넷 표준으로 채택 이는 더 빠른 데이터 전송 기술을 더 광범위 차원에서 사용할 수 있게 하고 기존 TCP를 대체해 QUIC은 TCP(트랜스미션 컨트롤 프로토콜) 대신 더 빠른 UDP(유저 데이터그램 프로토콜)를 사용하고 또한 더 빠른 복구의 이점도 가져 더 빠른 암호화된 연결과 더 나은 네트워크 스위치 처리도 제공 따라서 안전한 웹사이트 방문, 오디오비주얼 채팅, 모바일 브라우징에 가장 큰 개선을 보일 것","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-02-IT_News/"},{"title":"2021년 6월 04일 금요일 IT뉴스","text":"1. AI는 에디슨이 될수 없나…’특허불허’ 논란 확산AI는 에디슨이 될수 없나…’특허불허’ 논란 확산 : 네이버 뉴스 (naver.com) 3일 특허청은 미국 AI 개발자 스티븐 세일러 씨(출원인)가 발명자를 AI인 ‘다부스(DABUS)’로 표시한 국제특허출원을 국내에 출원했다고 밝혔고,특허청은 “자연인이 아닌 AI를 발명자로 적은 것은 특허법에 위배되므로 자연인으로 발명자를 수정하라”는 보정요구서를 통지했으며, 사실상 AI를 발명자로 인정하지 않은 결정이다. 세일러 씨 출원을 도운 라이언 애벗 영국 서리대 법학과 교수는 BBC와 인터뷰에서 “미래에 AI가 활발하게 발명을 시작한다면 지금처럼 지식재산권을 인정해주는 체계는 무너질 것”이라며 “AI는 발명자로 인정받아야 하며 AI를 개발한 사람이 특허의 권리자가 돼야 한다”고 밝혔다. 2. “쿠팡도 결국 배민은 넘사벽?”…한집배달 장착 배달의민족 ‘파죽지세’“쿠팡도 결국 배민은 넘사벽?”…한집배달 장착 배달의민족 ‘파죽지세’ : 네이버 뉴스 (naver.com) 오는 8일 단건배달 서비스 ‘배민1(원)’을 시작하는 배민은 입점 영업을 시작한지 한달 반 만에 약 5만 곳의 가맹점을 모았다. 배민은 3일 산재보험 사각지대에 놓인 배달기사들을 위해 의료비 및 생계비를 지원하는 ‘우아한 라이더 살핌기금’ 활성화를 위해 근로복지공단과 업무 협약을 맺었다. ‘우아한 라이더 살핌기금’은 지난 2019년 김봉진 우아한형제들 의장이 음식배달 중 교통사고 상해를 입은 라이더에게 긴급 의료비와 생계비를 지원하기 위함으로 사재 20억원을 사랑의열매에 기탁해 조성했으며, 지난해에는 배달업계 최초로 노사 간 단체협약을 진행해 라이더 처우 개선 등의 내용을 담은 협약을 맺기도 했다. 배달의민족은 쿠팡이츠 성장세가 주춤한 사이를 틈타 ‘1위 굳히기’에 나서는 모양세다. 3. 증권사가 15년간 쌓은 400만계좌, 카카오는 1년만에 달성증권사가 15년간 쌓은 400만계좌, 카카오는 1년만에 달성 : 네이버 뉴스 (naver.com) ◇금융시장 상식 깬 테크핀 고객을 지키기 위해 다른 은행과 협업을 꺼리고, 안정적인 운용을 중시하는 기존 금융권과 달리 테크핀 기업들은 타사 상품을 소개하는 것은 물론, 데이터를 기반으로 고객을 세분화한 맞춤형 상품도 공격적으로 출시한다. 네이버는 기존 금융권에 없는 소상공인 맞춤형 금융 서비스까지 자체적으로 운영하고 있으며, 간편송금으로 시작한 토스는 증권에 진출했고, 하반기에는 은행도 선보인다. ◇중국·동남아에선 은행 이상 알리바바의 알리페이와 텐센트의 위챗페이는 중국인 90%가 사용하는 모바일 메신저를 기반으로 은행에 갈 필요 없이 아예 페이 서비스를 은행계좌처럼 활용하게 만들었다. 인구의 70%가 은행계좌가 없고, 자산 대부분이 현금인 동남아에서도 테크핀 기업들이 금융시장을 장악하고 있다. 4. LGU+서 엠넷·tvN 못 보나···11일부터 중단 공지LGU+서 엠넷·tvN 못 보나···11일부터 중단 공지 : 네이버 뉴스 (naver.com) LG유플러스(032640)는 3일 공지사항을 통해 온라인 동영상 서비스(OTT)를 제공하는 ‘U+모바일tv’의 CJ ENM 채널 실시간 방송이 오는 11일부터 종료될 수 있다고 고객에게 공지했다. 중단되는 방송에는 tvN, 엠넷, 투니버스 등 CJ 계열 총 10개 방송이 포함됐으며, 다만 TV 다시보기(VOD) 서비스는 기존과 동일하게 이용 가능할 전망이다. 5. ‘같은 듯 다른’ 금융회사 수십개 모바일 앱, 통합까지 첩첩산중‘같은 듯 다른’ 금융회사 수십개 모바일 앱, 통합까지 첩첩산중 : 네이버 뉴스 (naver.com) 금융사들이 불필요한 모바일 애플리케이션(앱)을 통폐합하는 작업에 나서고 있는 가운데 금융사별로 고객 편의에 따라 수십 개 앱을 제공하는 곳도 있는 데다 단기간에 빠르게 통폐합할 경우 기존 앱 사용 고객의 불편을 초래할 수 있어 ‘원앱(하나의 앱)’ 전략에 난항이 예상된다. 인터넷전문은행을 비롯해 금융 서비스를 제공하는 빅테크 업체들은 소비자의 편리성을 확보하면서 필요한 기능만 제공하는 ‘원앱’ 전략으로 급성장했고, 이에 대응해 전통 금융사들 또한 앱 구조조정에 나서려는 추세다. 시중은행 관계자는 “고객이 뱅킹 앱에 접속해 단순히 계좌 조회만 할 수 있게 하는 서비스로는 경쟁력을 확보할 수 없다”며 “플랫폼 경쟁력을 확보하는 차원에서 은행마다 비금융 서비스 추가에 힘을 싣고 있는 추세”라고 말했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-04-IT_News/"},{"title":"2021년 6월 07일 월요일 IT뉴스","text":"1. “진짜 같은 가짜?” 화제의 23세 ‘김래아’ 누구길래…“진짜 같은 가짜?” 화제의 23세 ‘김래아’ 누구길래… : 네이버 뉴스 (naver.com) 진짜 사람이 아닌 ‘가상 인간’의 기술적 정교함이 극에 달하면서, 사회관계망서비스(SNS)를 통해 ‘팬층’을 확보하고 실제 브랜드 홍보 모델로 발탁되는 등 큰 인기를 끌고 있다. 얼핏 보면 실제 사람 같은 이 여성은 지난 1월 LG전자가 세계 최대 IT·가전 전시회 CES 2021에서 선보인 가상인간으로 ‘래아’(來兒)는 미래에서 온 아이라는 뜻으로 컴퓨터 그래픽으로 만들어진 외형에 인공지능(AI) 기술로 목소리를 입힌 캐릭터다. 2. 세계 10위권 시가총액 기업, 14년후에는?세계 10위권 시가총액 기업, 14년후에는? : 네이버 뉴스 (naver.com) ◆시가총액 10위권 기업 생존력은? 시장 분석가들은 기업가치를 평가할 때 기술적 혁신, 수익률, 기업인수합병, 유무형의 자산 등을 모두 종합적으로 고려하고 있으며, 이에 기업들이 시가총액 10위권을 10년 이상 유지하기 쉽지 않은 것으로 분석되고 있다. 실제로 지난 2004년 시가총액 10위권 기업 가운데 제너럴일렉트릭(GE), 엑슨모빌, 화이자, 시티그룹, 월마트, BP, AIG, 인텔, 뱅크오브아메리카(BoA)의 9개 기업이 현재 10위권 밖으로 밀려났고 AIG는 250위권에도 들지 못했고, IT 플랫폼 기업들이 급성장하며 이 자리를 차지했다. ◆애플 제칠만한 기업은 없나? 시장 분석가들은 14년후에 숙박공유 업체인 에어비앤비, 모바일결제 업체 스퀘어, 결제 서비스 업체 비자, 투자 및 헬스케어 서비스 업체 버크셔해서웨이, 전기차 제조사 테슬라 등이 새롭게 10위권에 진입할 업체로 봤으며, 시장 잠재력과 성장성 측면에서 애플을 추월할만한 기업으로 아마존과 MS, 에어비앤비, 테슬라 등을 거론하고 있다. 3. [팩플] ‘이해진 사람’을 건들수 있나···네이버 앞 3가지 질문[팩플] ‘이해진 사람’을 건들수 있나···네이버 앞 3가지 질문 : 네이버 뉴스 (naver.com) 자수성가한 유능한 창업자, 직급 없이 ‘OO님’으로 부르는 수평적·자율적 문화, 과감한 투자와 기술력. 네이버·카카오로 대표되는 IT기업이 자랑해 온 새로운 기업 문화다. 그러나 이제 창업자의 아우라는 절대권력으로, 자율적이라는 조직 문화는 ‘사적 지배’로 흐르기 쉬운 ‘구조적 결함’에 시선이 모아진다. ① 이사회는 ‘이해진 사람’ 건드릴 수 있나 익명을 요구한 IT업계 인사는 “네이버 계열사 이사진을 창업자 측근 3~4인이 독식하는 걸 보라”고 했으며, 실제로 네이버 사업보고서에 따르면 최 COO는 네이버 내 8개사 임원을 겸하는 등, 소수의 본사 경영진이 계열사 임원직을 많게는 10곳 이상 겸하며, 모두 네이버 창립 때부터 이 GIO와 함께 한 이들이고, 이러한 창업자의 신뢰가 또 다른 권력 독점으로 이어질 수 있다는 지적이다. ② 수평적·자율적인 문화, 구성원도 동감하나 네이버는 2017년 초 임원 제도를 없앴다가 2019년 초 직원 성과급에 직결되며 스톡옵션 배분에도 영향을 줄 수 있는 인사평가권을 갖는, ‘책임리더’를 신설해 부활시켰다. 책임리더가 팀장을 거치지 않고 팀원에 업무지시하는 일이 잦아지면서 ,네이버 노조는 “이런 소통 방식이 직장 내 따돌림에 악용될 수 있다”고 주장하며 이명진 고려대 사회학과 교수는 “체계를 인정하지 않는 업무 지시는 중간 관리자를 지능적으로 고립시킬 수 있다”며 “호칭은 수평적이어도 행동은 군대식”이라고 지적했다. ③ 기술과 서비스, 국내와 글로벌, 다 잡으려다 놓친 것 네이버는 글로벌 진출과 국내 수성이라는 두 마리 토끼를 모두 잡으려 한다. 과감하게 투자하는 기술 기업이면서, 점유율에 민감한 서비스 기업이기도 하며, 노조는 이 사이에서 조직원들이 받는 실적 압박이 높아졌다고 했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-07-IT_News/"},{"title":"2021년 6월 11일 금요일 IT뉴스","text":"1. “리걸테크, 법률소비자 위한 IT서비스” [K-유니콘][“리걸테크, 법률소비자 위한 IT서비스” K-유니콘] : 네이버 뉴스 (naver.com) 정재성 로앤컴퍼니 부대표(사진)는 최근 파이낸셜뉴스와 인터뷰에서 “리걸테크는 법률정보 비대칭을 겪고 있는 법률소비자는 물론 법학전문대학원(로스쿨)에서 배출된 수많은 변호사들이 보다 안정적으로 법률 서비스 시장에 진입할 수 있도록 지원할 것”이라며 “대한변협 등과 합리적 해결방안을 이끌어 법률 서비스 대중화 및 선진화라는 경영목표를 이뤄나가겠다”고 강조했다. 2. [이젠 ESG] ③ 새 가치 입는 IT 업계[이젠 ESG] ③ 새 가치 입는 IT 업계 : 네이버 뉴스 (naver.com) 엔씨소프트를 시작으로 넥슨과 넷마블 등 빅3와 중견 업체들로 ESG 경영이 본격화될 것으로 보이며, 양사 모두 자체 문화재단을 설립해 사회공헌 활동에 매진하고 있다는 공통점도 있다. 넷마블은 2018년 넷마블문화재단을 설립하고 공익사업을 확대하고 있고, 2019년부터 꾸준히 개최해 온 ‘전국 장애학생 e페스티벌’과 정보경진대회는 물론, 2019년 3월에는 게임업계 최초로 ‘장애인선수단’을 창단해 장애인 체육 진흥과 장기적인 자립 지원에 힘쓰고 있다. 넥슨 역시 2018년 2월 넥슨재단을 설립해 푸르메재단 넥슨어린이재활병원, 대전충남 넥슨어린이재활병원 건립을 후원하고 청소년 대상 코딩 대회인 ‘넥슨 청소년 프로그래밍 챌린지(NYPC)를 매년 개최하는 등 다양한 노력을 기울이고 있다. 3. 우티·카카오 T, ‘테슬라 마케팅’ 격전 벌인다우티·카카오 T, ‘테슬라 마케팅’ 격전 벌인다 : 네이버 뉴스 (naver.com) 티가 테슬라 모델3을 활용해 무료 택시 이벤트를 진행하자, 카카오모빌리티는 상위 모델인 테슬라 모델X를 정식 서비스 차종으로 추가했으며 양사가 갈수록 치열해지는 모빌리티 시장에서 이용자 확보에 힘쓰고 있다. 다만 국산 세단을 사용하는 일반적인 국내 택시와 달리, 테슬라를 활용한 마케팅은 차량 비용 부담이 큰 만큼 이러한 마케팅이 지속될 수 있을지에 대해선 의구심이 따르며, 일례로 우티 서프라이즈 택시 행사는 이달 내 종료할 예정이고 우티 관계자는 “이벤트 종료 이후 테슬라 택시를 준비할 계획은 없다”고 했다. 카카오모빌리티도 테슬라 모델X 단 한대만을 운영할 예정이다. 4. 조용하던 ‘애플카 프로젝트’ 다시 가속페달 밟나조용하던 ‘애플카 프로젝트’ 다시 가속페달 밟나 : 네이버 뉴스 (naver.com) 애플이 전기차 스타트업 카누(Carnoo) 공동 설립자인 울리히 크란츠를 전격 영입했고, 크란츠 영입은 여러 가지 면에서 많은 관심을 끌고 있다. 크란츠는 BMW에서 순수 전기차 개발을 주도했던 인물이며, BMW를 떠난 뒤엔 ‘전기차업계의 애플’로 불리던 카누 설립을 주도했다. 5. 넷플릭스가 온라인에 상점을 연 까닭은넷플릭스는 현재 2억 명이 넘는 가입자를 확보해 1위 자리를 지키고 있지만 구독료 외에는 수입이 없어 고심하고 있고, 여기에 디즈니플러스와 피콕, 파라마운트플러스 등 후발 업체들이 계속 넷플릭스의 가입자들을 노리고 있다. 넷플릭스는 온라인상점을 지난해부터 준비한 것으로 보이며, 지난해 3월 나이키에서 근무하던 조시 사이먼을 소비자 제품 판매 담당 부사장으로 영입했고, 이후 소비자 제품팀 인원도 20명에서 60명으로 늘렸다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-11-IT_News/"},{"title":"2021년 6월 14일 월요일 IT뉴스","text":"1. 아마존·애플·페북·구글 미래는… 美하원, 초강도 빅테크 규제안 발의아마존·애플·페북·구글 미래는… 美하원, 초강도 빅테크 규제안 발의 : 네이버 뉴스 (naver.com) 미 하원이 ‘IT 공룡’인 GAFA(구글·아마존·페이스북·애플)를 겨냥한 총 5가지 세부 법안으로 테크 기업의 분사나 사업 종료까지 거론하는 초고강도 규제 패키지를 꺼내들었다. 한편, 빅테크 기업들이 속한 로비 그룹인 ‘체임버 오브 프로그레스’는 “이 법안이 통과하면 소비자들은 인기 제품과 서비스를 사용할 권리를 박탈당할 것”이라고 주장했다. 2. 삼성 야심작 신형 폴더블폰 한달 빨리 나온다…“8월 27일 출시”삼성 야심작 신형 폴더블폰 한달 빨리 나온다…“8월 27일 출시” : 네이버 뉴스 (naver.com) 13일 IT팁스터(정보 유출자) 존 프로서는 “갤럭시Z폴드3와 갤럭시Z플립이 8월 27일 금요일 정식 출시된다. 이날부터 판매가 시작될 것”이라고 말했다. 갤럭시Z폴드3는 언더패널카메라(UPC) 기술, S펜 입력 지원 등 삼성전자의 최신 기술이 집약됐으며, 투톤 디자인과 위아래로 배치된 듀얼(2개) 카메라, 확 커진 커버 디스플레이 등이 특징이다. 커버 디스플레이는 1.1인치에서 1.82인치로 커진다. 3. 파국 치닫는 프로그램 사용료 갈등···OTT 방송 중단 IPTV로 확산하나파국 치닫는 프로그램 사용료 갈등···OTT 방송 중단 IPTV로 확산하나 : 네이버 뉴스 (naver.com) 13일 업계에 따르면 양사 간 사용료 협상이 결렬되어, 지난 12일 자정부터 LG유플러스(032640)의 OTT인 U+모바일tv에서 CJ ENM 채널 실시간 방송 송출이 중단됐다. KT 시즌과의 협상마저 결렬되면 사실상 통신사 OTT에서 CJ ENM의 실시간 방송 송출은 모두 중단되게 되며, 이 같은 갈등은 IPTV와의 협상까지 이어질 가능성이 높다. 강호성 CJ ENM 대표는 지난 달 31일 사내 행사에서 “시장의 80% 이상을 차지하는 IPTV사들이 조금 인색한 것 같다”고 지적했다. 4. [금융D-택트] 카카오가 만드는 보험사는 다를까?[금융D-택트] 카카오가 만드는 보험사는 다를까? : 네이버 뉴스 (naver.com) 카카오손해보험은 빠른 시간 내 보험 종류를 다양화하진 않을 것으로 관측되며, 오히려 소액 단기보험을 위주로 보험 가입의 사용자 경험을 확 바꾸는데 집중할 것으로 보이고, 보험금 청구 과정에도 인공지능(AI) 등을 활용해 피로감을 낮출 것입니다. 가장 우려되는 부분은 카카오톡을 활용한 보험 가입이 ‘보험 모집’으로 봐야할지 ‘보험 광고’로 해석해야할지인데, 카카오톡의 배너를 활용해 카카오손해보험의 상품이 게재되고, 카카오 자회사 서비스를 이용할 때 관련 내용이 나온다면 이는 보험 계약을 적극적으로 체결하길 권유하는 모집 행위일지 단순 광고로 볼 수 있을지 해석이 분분하다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-14-IT_News/"},{"title":"2021년 6월 16일 수요일 IT뉴스","text":"1. 삼성전자, 5G보다 50배 빠른 6G THz 무선통신 시연 성공삼성전자, 5G보다 50배 빠른 6G THz 무선통신 시연 성공 : 네이버 뉴스 (naver.com) 삼성전자는 미국 샌타바버라 캘리포니아 주립대UCSB)와 6세대 이동통신(6G) 테라헤르츠(THz) 대역에서 통신 시스템 시연에 성공했다고 16일 밝혔다. 6G가 상용화되면 통신 성능의 획기적인 개선으로 몰입형 확장현실(XR)이나 홀로그램과 같은 신규 서비스가 모바일 단말에서도 지원이 가능해지고 이동 통신 기술의 적용 영역이 위성 통신이나 도심 항공 모빌리티까지 확장될 것으로 예상된다. THz 대역은 100기가헤르츠(GHz)~10THz 사이의 주파수 대역을 의미한다. THz 대역은 데이터 전송 속도가 최고 20기가비피에스(Gbps)인 5세대 이동통신(5G) 대비 최대 50배 빠른 1테라비피에스(Tbps·1초에 1조 비트를 전송하는 속도)를 목표로 하는 6G 통신의 후보 주파수 대역으로 꼽히고 있다. 2. 윤곽 드러낸 ‘윈도11’··· 개발 취소한 윈도10X의 흔적이 엿보인다윤곽 드러낸 ‘윈도11’··· 개발 취소한 윈도10X의 흔적이 엿보인다 : 네이버 뉴스 (naver.com) 15일(현지시각) 더 버지(The Verge) 등 외신은 중국의 웹사이트 ‘바이두’에 윈도11의 모습이 유출됐다고 보도했으며 유출된 내용은 사용자 인터페이스(UI)와 시작 메뉴 등 스크린샷이다. 한편 MS의 차세대 윈도가 윈도11이었다는 소식이 전해지며, MS가 앞서 윈도10을 출시하며 “윈도10은 윈도의 마지막 버전이 될 것”이라고 발표한 바 있기 때문에 윈도10 이용자들의 불만은 커지고 있다. 3. 삼성도, LG도 모두 美 간다…CES 2022, 코로나 딛고 오프라인 전시 참가 ‘후끈’삼성도, LG도 모두 美 간다…CES 2022, 코로나 딛고 오프라인 전시 참가 ‘후끈’ : 네이버 뉴스 (naver.com) 16일 삼성전자와 LG전자에 따르면 내년 1월 5일부터 8일까지 미국 라스베이거스에서 열리는 CES의 오프라인 전시에 참가한다. 삼성전자는 내년 CES에서 QD디스플레이를 활용한 TV 신제품을 선보일 것으로 예상되고, LG전자는 초고화질 OLED TV를 소개한다는 계획이며 또 AI와 로봇기술, 자동차 전장 등도 전시할 것으로 보인다. 4. 테크핀의 공습…대출시장 빅뱅테크핀의 공습…대출시장 빅뱅 | 한경닷컴 (hankyung.com) 15일 금융권에 따르면 네이버의 금융 자회사 네이버파이낸셜은 한국핀테크산업협회를 통해 정부의 대환대출 중개 플랫폼에 참여하고 싶다는 의사를 금융결제원과 금융당국에 전달했다. 애초 새 플랫폼에는 대출을 취급하는 금융사 외에 기존에 대출 비교 서비스를 영위하던 13개 핀테크업체 ( 토스, 카카오페이, 핀다, 페이코 등)만 참여할 예정이었지만, 금융위 관계자는 “네이버 같은 강력한 플랫폼이 참여하면 대환대출 서비스의 접근성이 더 좋아진다”며 “금융사와 빅테크 간 건전한 경쟁을 통해 금융소비자 혜택이 늘어날 것”으로 기대했다. 정부의 대환대출 중개 플랫폼: 각 금융사의 대출 조건을 소비자가 비교해보고 자유롭게 다른 대출로 갈아탈 수 있는 개방된 플랫폼 5. 대출금리 비교, 실시간 해외 송금… 영토 넓히는 핀테크대출금리 비교, 실시간 해외 송금… 영토 넓히는 핀테크 - 조선일보 (chosun.com) P2P(온라인 대출 중개) 금융은 온라인 플랫폼을 통해 대출 희망자와 돈을 댈 수 있는 개인 투자자를 연결해주는 것이다. 대출 희망자는 5~15%의 중금리로 대출을 받을 수 있고, 투자자는 그에 준하는 수익률을 기대할 수 있지만, 다만 돈을 떼일 수 있다는 우려가 컸다. 지난 10일 ‘8퍼센트’ ‘렌딧’ ‘피플펀드컴퍼니’ 등 3사가 온라인 투자 연계 금융법상 최초 등록됐으며, 금융 당국의 관리, 감독을 받으며 투자자 보호 조치가 시행돼 상대적으로 안심하고 이용할 수 있다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-16-IT_News/"},{"title":"2021년 6월 09일 수요일 IT뉴스","text":"1. 애플, 연결성 강화한 iOS15 공개…갤럭시도 페이스타임 된다애플, 연결성 강화한 iOS15 공개…갤럭시도 페이스타임 된다 올해 WWDC의 키워드는 연결성으로 가장 눈에 띈 변화는 영상통화 서비스인 페이스타임이다. 그동안 아이폰이나 아이패드, 맥북 등 자사 기기에서만 사용 가능했던 페이스타임은 iOS15 업데이트 이후 안드로이드 스마트폰이나 윈도 기기에서도 작동된다. 이처럼 애플이 페이스타임을 강화시킨 이유는 코로나19 여파에 원격수업이나 재택근무 등이 확대된 상황에서 경쟁 서비스인 ‘줌’, ‘팀즈’ 등을 견제하기 위한 조치로 해석된다. 2. 3대 리스크에 갇힌 테슬라, 머스크의 제국 무너지고 있나3대 리스크에 갇힌 테슬라, 머스크의 제국 무너지고 있나 승승장구하던 중국 시장에선 심각한 판매 부진에 빠졌고 글로벌 자동차 업체들은 신형 전기차를 앞세워 테슬라의 아성을 본격적으로 허물고 나섰다. 일론 머스크 창업자 겸 최고경영자(CEO)의 끊임없는 돌출 발언과 구설이 테슬라의 어려움을 가중시키면서 머스크의 핵심 측근들마저 회사를 떠나고 있다. 3. NYT·CNN 등 유력 언론 사이트 무더기 다운NYT·CNN 등 유력 언론 사이트 무더기 다운 뉴욕타임스, 파이낸셜타임스, 블룸버그를 비롯한 세계 유력 뉴스 사이트들이 8일(현지시간) 한 때 무더기로 다운됐다고 CNBC를 비롯한 외신들이 일제히 보도했으며, 트위치, 핀터레스트, HBO 맥스, 훌루 스포티파이, 레딧 등도 비슷한 장애를 겪었다. 이번 사고는 클라우드 서비스 제공업체인 패스틀리(Fastly) 때문에 발생했다. 패스틀리는 웹 사이트의 로딩 속도를 향상시키는 데 도움을 주는 역할을 한다. 또 트래픽 과부하를 완화시켜 분산서비스거부 등의 고격으로 사이트가 다운되는 것을 막아주는 서비스도 제공하고 있다","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-09-IT_News/"},{"title":"2021년 6월 28일 월요일 IT뉴스","text":"1. ‘줄줄이’ IPO·보험사 설립 앞둔 카카오…판교 인재 ‘블랙홀’‘줄줄이’ IPO·보험사 설립 앞둔 카카오…판교 인재 ‘블랙홀’ 연이은 주요 자회사의 기업공개(IPO)와 디지털손해보험사 설립, 모빌리티 영업부문 확대, 콘텐츠 사업 등 전방위로 사업영역을 넓히고 있는 카카오가 인재들을 ‘블랙홀’처럼 끌어들이고 있다. 개발자뿐만 아니라 보험, 은행, 디자인 등 분야를 가리지 않고 전방위 채용이 이뤄지고 있어서 사업 영역이 겹치는 기업들마다 인재유출을 우려하며 예의주시하고 있다. 2. 손정의가 주목한 국내 AI 스타트업…사람 대신 암 진단하고 수학 문제풀이손정의가 주목한 국내 AI 스타트업…사람 대신 암 진단하고 수학 문제풀이 소프트뱅크벤처스는 지난 25일 오후 루닛, 메스프레소, 가우디오랩, 루나소프트, 토스랩, 클래스101 등 주요 투자 스타트업 6개사의 공동 기자간담회를 개최하고 업체별 사업 내용과 계획을 소개했다. 6개사는 AI 기술을 앞세워 새로운 시장을 개척하고 선점할 가능성을 인정받아 소프트뱅크벤처스로부터 투자 유치에 성공했다. 루닛: 루닛은 흉부 엑스레이 사진 속 이상소견을 판별해 폐암과 유방암을 진단해주는 의료 서비스 ‘루닛 인사이트’를 상용화했다. 메스프레소: 메스프레소는 한국, 일본, 베트남, 태국, 인도네시아 등 4개국에서 수험생을 대상으로 AI 수학 교육 서비스를 제공한다. 학생이 수학 문제를 스마트폰으로 찍어 메스프레소의 애플리케이션(앱) ‘콴다’에 올리면, AI가 사진 속 문제를 인식한다. AI는 단순히 문제 속 수식을 계산해주는 걸 넘어, 전체 텍스트를 이해해서 풀이까지 제공한다. 가우디오랩: 가우디오랩은 AI 기반 오디오 기술에 특화한 업체다. 루나소프트: AI 고객상담 서비스 등을 제공하는 루나소프트는 올해 하반기 일본에서 네이버 계열 메신저 라인을 통해 AI 챗봇을 선보일 계획이다. 현재 AI 챗봇은 구매한 상품의 주문·배송조회, 결제·반품문의 등 이커머스(전자상거래) 업체의 고객상담에 활용되고 있다. 토스랩: ‘아시아의 슬랙’으로 기대받는 업무 협업툴 ‘잔디’의 개발사 토스랩은 CJ ENM, 무신사 등 대기업부터 스타트업까지 약 30만팀이 잔디를 도입했고 63개국에 사업 진출했다고 밝혔다. 클래스101: 온라인 강좌 플랫폼 클래스101도 비대면 교육시장 확대에 맞춰 성장하고 있다. 취미, 경제, 부동산, 코딩 등 분야별 전문가를 선별해 창작자(강의자)로 섭외하고 강의에 필요한 기술적 문제 해결부터 준비물까지 챙겨주는 강의 지원 및 중개 서비스를 운영한다. 3. 서울 지하철 실시간 혼잡도, 스마트폰으로 확인한다서울 지하철 실시간 혼잡도, 스마트폰으로 확인한다 27일 서울교통공사에 따르면 공사는 SK텔레콤과 협력해 7월부터 공사 애플리케이션 ‘또타지하철’을 통해 지하철 칸별 실시간 혼잡도를 제공할 예정이다. 혼잡도는 객차별 휴대전화 통신 자료와 교통카드 자료를 바탕으로 산출하며, SK텔레콤이 작년 9월부터 ‘T맵 대중교통’ 앱을 통해 칸별 혼잡도 예측 정보를 제공하고 있지만, 실시간 혼잡도를 제공하는 것은 이번이 처음이다. 4. 당연해진 ‘모바일 디지털헬스’, 의료기관 속 뿌리내리다당연해진 ‘모바일 디지털헬스’, 의료기관 속 뿌리내리다 ICT를 활용한 모바일 디지털 헬스케어는 이미 일상 속에서 흔히 사용되는 기술로 자리잡고 있으며, 특히 그 활용도는 ‘의료기관’에서 두드러지게 나타나고 있다. 보고서에 따르면 현재 모바일 헬스케어는 해외 입국자를 위한 코로나19 자가격리 및 자가진단 관리, 생활치료센터 입소자들을 위한 시스템, 병원 문진용 어플리케이션 등에 이용되고 있으며, 그 중에서도 근래 가장 활성화되고 있는 병원 기반 모바일 헬스케어 특징은 병원 이용 관련 불편한 과정을 줄이고 이용객의 편의를 돕는데 그 기능을 집중했다. 삼성서울병원 PHR앱은 환자들의 병원 이용은 물론, 이후의 결제 및 여러 증명서 관리까지 도움이 될 수 있는 방향으로 설계됐다. 삼성서울병원은 의료/결제 정보를 사용하기 위한 인증체계 및 보안 시스템으로 ‘블록체인’을 도입했다. 서울성모병원은 환자의 대기시간이 밀려 있는 경우 순서가 가까워지면 알람기능으로 알려주는 시스템을 구축, 진료 후 수납부터 모바일 약 처방전 전송도 가능하다. 서울아산병원은 국내병원 중 최초로 ‘내 손안의 차트’라는 이름으로 PHR앱을 제공하고 있다. 아산병원의 PHR 앱은 혈압, 혈당, 체질량 지수, 심혈관 질환 위험도, 대사증후군 등에 대한 정보를 받을 수 있고 병원의 EMR과 연동해 약물 스케줄 관리, 임상 결과 정보 조회를 할 수 있다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-28-IT_News/"},{"title":"2021년 6월 21일 월요일 IT뉴스","text":"1. ‘원하는 곳 어디에서나’ 라인, 하이브리드 워크 제도 공식화‘원하는 곳 어디에서나’ 라인, 하이브리드 워크 제도 공식화 : 네이버 뉴스 (naver.com) 라인플러스가 오는 7월부터 ‘하이브리드 워크 1.0(LINE Hybrid Work 1.0)’ 제도를 공식 시행한다고 18일 알렸으며, 이로써 라인플러스의 공식 근무제도는 전일 완전재택부터 주 N회 재택까지 사무실근무와 재택근무를 조합해 선택할 수 있는 혼합형 근무제로서 라인 임직원은 코로나 종식 후에도 원하는 장소에서 원격으로 일할 수 있게 됐다. 라인은 어디에서나 동일한 업무 생산성을 유지할 수 있도록 그라운드룰을 발전시켜가고 있다. ▲원격근무지에 업무 집중 환경 조성 ▲업무 공유 및 피드백 활성화 ▲원활한 협업을 위한 근무시간 정립 및 공유 등 공통 룰에 더해 조직별 직무 특성, 프로젝트 진행 상황, 협업 체계 등 요소를 고려해 조직별 그라운드룰을 수립해왔다. 2. “페이스북이 스마트워치를?”…빅테크 왜 ‘웨어러블’ 뛰어드나“페이스북이 스마트워치를?”…빅테크 왜 ‘웨어러블’ 뛰어드나 : 네이버 뉴스 (naver.com) ![갤럭시 워치3, 갤럭시 워치 액티브2사용자는삼성 헬스 모니터` 앱을 통해 언제 어디서든 본인의 혈압과 심전도를 측정, 기록할 수 있다. /사진=삼성전자](https://imgnews.pstatic.net/image/009/2021/06/12/0004808163_003_20210612200203500.jpeg?type=w647) 스마트워치는 스마트폰보다도 더 몸에 찰싹 달라붙어 있어, 24시간 내내 한 사람의 모든 일상의 데이터를 수집하며, 개인들의 헬스 데이터는 어떤 것보다 가장 양질의 데이터로 분류되기 때문에, 애플 독주의 시장에서 연합전선을 펼치는 삼성과 구글까지 빅테크들은 저마다 스마트워치 시장을 장악하려고 노력하고 있습니다. 한국보건산업진흥원에 따르면 디지털 헬스케어 시장 규모는 2019년 1063억달러(약 118조원)로 추산하며, 해마다 30%씩 성장하는 시장으로 2026년에는 6394억달러(약 711조원)로 전망되기 때문에 이 시장 파이를 조금이라도 가져가서 매출을 만들어낼 수 있다면 뛰어들지 않을 이유가 없다. 페이스북은 페이스북과 인스타그램 이용자만 전 세계에 32억명이므로 이 중에 일부라도 자사 워치를 이용하게 만들 수 있다면 시장에 뛰어드는 게 여러모로 페이스북에 이득이다. 3. 네이버와 카카오는 왜 SM엔터 지분확보 전쟁에 나섰나네이버와 카카오는 왜 SM엔터 지분확보 전쟁에 나섰나 : 네이버 뉴스 (naver.com) 네이버와 카카오가 웹툰과 웹소설 IP를 최대한 확보하기 위해 관련 회사들에 줄줄이 지분 투자를 하거나 인수를 하는 것의 연장선상에 SM엔터에는 내로라하는 아이돌인 일본에서 꾸준히 엔화를 벌어오는 ‘동방신기’, 아시아를 호령하는 슈퍼주니어를 비롯해 샤이니, 엑소(EXO), 레드벨벳, NCT드림, 에스파(aespa) 등 코어 팬덤을 보유한 아티스트들은 그 자체로 지식재산권, 즉 스토리(IP)가 된다. 팬들은 이들 아티스트의 스토리텔링으로 만들어진 세계를 즐기고, 그 세계의 부산물인 라이선스 기반 상품을 줄줄이 소비하고, 단순히 음반을 사는 것 외에 이들로 만들어진 게임과 책, 굿즈 등을 차례로 구매하고 소장할 수 있는 것이다. 네이버와 카카오 같은 정보통신기술(ICT) 기업과 손잡고 더 구체화하려는 사업은 바로 메타버스를 이용한 ‘온라인 콘서트’ 사업입니다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-21-IT_News/"},{"title":"2021년 6월 23일 수요일 IT뉴스","text":"1. 中 비트코인 채굴장 폐쇄, 그래픽카드 가격 폭락中 비트코인 채굴장 폐쇄, 그래픽카드 가격 폭락 중국 정부가 비트코인 채굴업체 90%를 폐쇄했다는 소식이 전해지면서 중국 내 그래픽 카드 거래가격이 폭락했다고 사우스차이나모닝포스트가 21일 보도했다. 중국 정부의 암호화폐 단속 조치는 주요 채굴 장비 중 하나인 그래픽 카드 거래 가격에도 영향을 미쳤고, 보도에 따르면 엔비디아 쿼드로 P1000 모델은 이날 JD닷컴 스토어에서 2천429위안(약 42만5천원)에 거래됐다. 이 제품은 중국 정부가 비트코인 채굴 단속 의지를 밝히기 전인 5월초까지만 해도 3천위안(약 52만5천원)에 거래됐으며, 5월에 T몰에서 1만3천499위안(약 236만원)까지 치솟았던 에이수스 RTX 3060은 4천699위안(약 82만원)까지 폭락했다. 2. 4대 플랫폼 집중적으로 키우는 네이버… 글로벌시장 공략 본격화4대 플랫폼 집중적으로 키우는 네이버… 글로벌시장 공략 본격화 네이버는 주력 서비스인 웹툰, 이커머스(전자상거래), 메타버스(가상현실), 클라우드 등 4대 플랫폼을 앞세워 해외 시장 공략을 본격화 하고 있으며, 특히 이들 4대 플랫폼 분야에서 얼마만큼 성과를 낼 수 있는지에 따라, 향후 카카오와의 시총 순위 경쟁에 영향을 미칠 전망이다. 3. 블록체인 핀테크 기업 글루와, 아프리카서 디지털 금융블록체인 핀테크 기업 글루와, 아프리카서 디지털 금융 22일 실리콘밸리에 본사를 둔 토종 블록체인 핀테크 기업 글루와는 아프리카 현지 핀테크 업체 엘라와 손잡고 아프리카 금융소외자에게 공과금 납부, 송금, 소액대출 등 금융서비스를 제공한다고 밝혔다. 글루와는 낙후된 금융 인프라 때문에 신용기록이 없고, 이 때문에 대출이나 신용카드 서비스를 이용할 수 없던 아프리카 현지 사람들에게 대출이나 신용카드 결제 등 생활자금 목적의 소액 단기 금융 서비스를 제공하며, 대출 이후 서비스 이용자들의 신용기록을 블록체인망에 기록, 기존 금융회사들이 구축하지 못한 아프리카내 신용기록망을 구축하고, 금융 서비스를 확장해 나간다는 방침이다. 글루와 오태림 대표는 “아프리카 인구의 63% 이상이 24세 미만이고 이들 대부분 은행 문턱을 넘어본 적이 없는 금융소외자(Unbanked)들”이라며 “우리는 블록체인 기술과 글로벌 핀테크 노하우를 활용해 저개발 국가의 취약계층에게 금융서비스를 제공하고 불균형을 해소하는데 주력하고 있다”고 말했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-23-IT_News/"},{"title":"2021년 6월 30일 수요일 IT뉴스","text":"1. 삼성, 비전공자도 개발자 만들어주는 ‘SW아카데미’ 교육생 두배 늘린다삼성, 비전공자도 개발자 만들어주는 ‘SW아카데미’ 교육생 두배 늘린다 삼성전자는 매년 상·하반기 각각 500명의 교육생을 선발했는데, 정부 지원 덕분에 내년부터는 규모를 더 키워 기수당 약 1,150명까지 늘릴 계획으로, 연간 모집 인원은 총 2,300여 명 이상이다. SSAFY는 교육생으로 선발되기 위한 족집게 과외까지 성행할 정도로 취업 준비생들에겐 인기이며, 삼성은 매일 8시간씩 연간 1,600시간의 집중 교육과 더불어 매월 100만 원의 장학금도 지원하고 있다. 2. [임현우의 Fin토크] 토스에 대한 뒷담화들[임현우의 Fin토크] 토스에 대한 뒷담화들 토스가 청년 스타트업으로 한국경제신문에 처음 소개된 게 2014년 10월이었고, 지금은 1000명 넘는 직원을 수용할 공간이 부족해 역삼역 일대에 뿔뿔이 흩어져 일하고 있다. 증권사, 전자결제(PG)회사, 보험판매회사에 이어 아무나 받기 힘든 은행 사업권도 따내며, 이승건 대표가 꿈꿨다는 이른바 ‘디지털 금융지주’의 그림이 완성돼가고 있다. 대형 금융사는 자신들의 위상을 금융상품 납품업체로 떨어뜨리고 있는 플랫폼 기업에 유감이 많다. 토스가 간편송금을 내놓을 당시 은행까지 세운다는 구상은 없었다. ‘혁신금융’ 성과를 원했던 금융당국이 제3 인터넷은행을 밀어붙였고, 네이버가 손사래 치며 빠져나간 자리를 토스가 순발력 있게 꿰찼다. 토스가 최근 투자 유치 과정에서 평가받은 기업가치는 74억달러, 우리 돈으로 8조3000억원이며 우리금융 시가총액(8조6000억원)에 맞먹는다. 토스의 조직문화는 스타트업 특유의 속도전과 실리콘밸리식 무한경쟁이 결합돼 있어, 업무량이 많고 버티기 힘들다는 세간의 평가를 부정하지 않는다. “워라밸을 신경쓰지 않을 정도로 일에 몰입해본 경험이 없는 사람이 세상을 바꿀 서비스를 만들 수 있느냐.” 연봉과 복지는 최고 대우를 해주되 철저한 성과주의로 간다는 것이다. 3. 온라인 럭셔리 편집숍 론칭한 무신사… 정품, 새벽 배송, 당일 출고 강점온라인 럭셔리 편집숍 론칭한 무신사… 정품, 새벽 배송, 당일 출고 강점 무신사 부티크는 무신사가 엄선한 글로벌 유명 럭셔리 브랜드 정품을 만나볼 수 있는 서비스로 유럽, 미국 등 해외 브랜드 쇼룸과 편집숍에서 판매하는 100% 정품 상품만을 선보이며, 무신사가 정품임을 보증하는 ‘부티크 인증서’와 ‘보안 실’을 동봉한다. 이용 편의성을 높인 배송 서비스도 제공하며, 밤 9시 전에 주문한 상품을 익일 오전 7시까지 받아볼 수 있는 새벽 배송 서비스는 서울 및 경기 일부 지역에 한해 무료로 시행한다. 4. 지그재그, 통합 리뷰 기능 ‘제트 리뷰’ 론칭 1년… 1천만 리뷰 데이터 확보지그재그, 통합 리뷰 기능 ‘제트 리뷰’ 론칭 1년… 1천만 리뷰 데이터 확보 지그재그는 지난 2020년 4월 각기 다른 쇼핑몰에서 구매한 상품에 대한 리뷰를 지그재그 아이디로 작성하고 포인트를 적립할 수 있는 통합 리뷰 기능 ‘제트(Z) 리뷰’를 도입한 바 있으며, 서비스 론칭 1년여만에 1천만건을 돌파하며 빠른 성장세를 보이고 있고 구매 결정에 도움을 주는 양질의 리뷰가 2배 이상 증가했다고 29일 밝혔다. 크로키닷컴 관계자는 “건전하고 신뢰도 높은 리뷰 문화를 정착하여 건강한 쇼핑 생태계를 조성하고자 다양한 제도를 운영하고 있다”며 “양질의 리뷰가 판매자의 매출 상승 뿐 아니라 지그재그 내 상품 경쟁력 강화로 이어질 수 있도록 리뷰 서비스를 계속해서 강화할 것”이라고 말했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-30-IT_News/"},{"title":"2021년 6월 18일 금요일 IT뉴스","text":"1. 핀테크에서 붙은 네이버 vs 카카오핀테크에서 붙은 네이버 vs 카카오 네이버와 카카오는 빅테크 기업의 금융 진출이라는 점에서 같지만, 접근 방식에서는 확연한 차이가 나타나는데, 네이버는 기존 금융사들과 제휴하거나 혁신금융으로 지정받는 방식으로 서비스를 넓혀가지만, 카카오는 영업 허가를 받아 직접 뛰어들어 시장을 흔드는 전략을 쓴다. 카카오는 금융 자회사로 카카오페이(송금·결제 등)와 카카오뱅크(은행)를 뒀고, 카카오페이의 자회사로 카카오페이증권, 지난 9일 보험업 예비허가를 받은 카카오손해보험이 있으며, 카카오페이와 카카오뱅크는 자본 확충을 위해 기업공개(IPO)를 추진 중이다. 카카오는 플랫폼을 통해 기존의 금융서비스를 중개·제공하는 역할로는 금융혁신에 한계가 있다고 설명한다. 네이버의 금융 자회사인 네이버파이낸셜은 금융위원회의 규제 샌드박스(규제 유예)에 선정돼, 스마트스토어 사업자를 대상으로 한 신용대출을 하고 있으며, 네이버파이낸셜이 자사 데이터를 바탕으로 신용평가를 하면 미래에셋캐피탈이 대출을 내어주는 식으로 운영된다. 네이버는 검색엔진에서 출발했기 때문에 자사 플랫폼 안에 방대한 데이터를 수집하고 이를 분석하는 기술이 강하고 카카오처럼 여러 계열사를 두지 않는 것은 네이버파이낸셜을 통해 데이터를 한곳에 집적해 서비스를 고도화하려는 취지로 볼 수 있으며, 은행 등 사업에 직접 뛰어들지 않고 기존 금융사와 제휴하는 방식을 쓰는 것은 ‘금융기업’보다는 ‘금융플랫폼 기업’으로서 사업 역량을 강화하려는 전략적 판단이라고 네이버는 설명한다. 2. 구글 워크스페이스, 일반 사용자에게 개방… 새 협업 환경 ‘스페이스’도 도입구글 워크스페이스, 일반 사용자에게 개방… 새 협업 환경 ‘스페이스’도 도입 지난 10월 구글은 구글 G 스위트(G Suite)의 이름을 워크스페이스로 변경하고, 앱을 가로지르는 협업 환경을 만들 것이라고 밝힌 바 있으며, 구글은 우선 유료 요금제에 해당하는 서비스부터 변경 작업을 시작했고, 이제 일반 사용자 대상의 작업이 시작된 것이다. 구글은 또한, 계약직 근로자를 위한 개인용 비즈니스 워크스페이스 계정을 발표했는데, 구글에 따르면 이 새로운 계정에는 지능형 예약 서비스, 전문적 영상회의, 개인화된 이메일 마케팅을 비롯한 여러 프리미엄 기능이 제공된다. 구글 채팅과 지메일 안의 구글 채팅은 다르다. 지원 문서에는 이렇게 명시되어 있다. “채팅과 지메일 안의 채팅에서 같은 기능을 이용할 수 있지만, 지메일에 통합된 것은 친구, 가족, 동료와 이메일 사이사이에 커뮤니케이션할 수 있는 중앙화 된 공간을 제공한다.” 3. KT, 핀테크 1위 웹케시에 236억 지분 투자뱅크샐러드 이은 두 번째 행보…B2C•B2B 금융 플랫폼 사업 기반 확보KT, 핀테크 1위 웹케시에 236억 지분 투자 KT(대표 구현모)는 광화문 이스트 사옥에서 웹케시 그룹에 속한 웹케시, 비즈플레이, 로움아이티 등 3개사를 대상으로 총 236억의 전략적 지분투자와 함께 금융 사업 협력 계약을 체결했다고 17일 밝혔다. 웹케시 그룹은 기업 고객의 사업 규모에 따라 ▲비즈플레이(대‧중견기업) ▲경리나라(중소기업) ▲세모장부(소상공인) 등 B2B 핀테크 솔루션을 제공하고 있으며 KT의 인공지능(AI), 빅데이터, 클라우드 등 플랫폼 기술력과 유무선 인프라와 웹케시 그룹이 보유하고 있는 기업 핀테크 서비스를 연계해 기업 규모와 업종 등 타깃별 신규 플랫폼 서비스를 선보이고 솔루션을 고도화한다는 계획이다. 4. SK하이닉스, 리더 ‘책임 강화’·직원 ‘처우 개선’…체질 개선 고삐SK하이닉스, 리더 ‘책임 강화’·직원 ‘처우 개선’…체질 개선 고삐 : 네이버 뉴스 (naver.com) 구성원의 처우는 개선하고 최고경영자(CEO)에는 사업 성과에 대한 책임을 강화하는 등 선제적인 내부 자정 노력을 통해 조직문화를 새로 정비하고, 더 나아가 인재 확보 경쟁력을 끌어올리겠다는 전략이다. ◆ SK하이닉스, ‘박정호·이석희’ 경영 능력도 평가한다 ◆ 구성원은 ‘처우 개선’…8000만 원 받는 대졸 신입 나온다 최근 SK하이닉스 노사는 임금협상을 진행하고, 기술 사무직, 생산직 등 전체 직군의 기본급을 기존 대비 8.07% 인상하기로 합의했다. 대졸 초임 연봉은 기존 4000만 원대에서 5040만 원으로 인상하여 기본급, PS(초과이익분배금), PI(생산성 격려금) 등을 합산한 SK하이닉스 신입사원 연봉은 최대 8000만 원 수준으로 점쳐진다. SK하이닉스는 현재 연 1회의 PS, 연 2회의 PI를 지급하고 있다. 5. “구글, 무료라더니…” 클라우드 유료화에 열받은 대학들“구글, 무료라더니…” 클라우드 유료화에 열받은 대학들 : 네이버 뉴스 (naver.com) 구글은 지난 2019년 초부터 국내 대학들을 대상으로 이메일 저장 서비스를 무료로 제공하기 시작했고, 당시 구글은 각 대학에 “무제한 메일함 용량과 구글 포토·구글 드라이브 등 클라우드(가상 서버)를 무료로 사용할 수 있게 하겠다”고 홍보하며 가입을 유도하여 서버 운영에 매년 수억~수십억 원을 써야 했던 많은 대학은 자체 운영 서버를 중단하고 구글 서비스를 도입하고 이전까지 다른 클라우드 서비스를 이용하던 대학 교수·학생들도 일제히 구글 서비스에 가입했고, 개인 이메일은 물론이고 연구·교육 데이터도 구글 서버에 올려 보관했다. 하지만 구글이 2년 만에 무료 저장 정책을 뒤집으면서 대학들엔 비상이 걸렸다. 구글은 이달 초 서울대를 비롯한 각 대학에 ‘그동안 무제한으로 제공하던 스토리지(저장) 서비스를 내년 7월부터 기본 제공 용량을 100테라바이트로 제한한다’고 공지했고, 대학이 기본 제공 용량 이상의 저장 공간을 사용하려면 앞으로 별도의 요금을 구글에 내야 한다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-18-IT_News/"},{"title":"2021년 7월 02일 금요일 IT뉴스","text":"1. 강남‧판교 집 필요 없다…야놀자, 원격근무제 무기한 시행강남‧판교 집 필요 없다…야놀자, 원격근무제 무기한 시행 테크 기업들의 인재 경쟁 1라운드가 연봉 인상이었다면, 2 라운드는 오피스로 코로나19 유행이 끝나도 원격근무를 이어가겠다고 밝히는 기업들이 속속 늘고 있다. 가장 최근 이 정책을 밝힌 곳은 여가 플랫폼으로 ‘유니콘(기업가치 1조원 이상 비상장 기업)’ 반열에 오른 야놀자로 야놀자가 이렇게 오피스 개념을 바꾸고 나선 건 인재 유치 때문이며, 야놀자 측은 “상시 원격근무제는 글로벌 테크 기업으로서 도약을 위한 변화의 일환”이라고 설명했다. 앞서 야놀자는 올 하반기에만 연구개발 인력 300명을 채용하겠다고 밝혔다. 2. ‘편견 배제’ 알고리즘으로 ‘유니콘’ 일군 인도인 창업자‘편견 배제’ 알고리즘으로 ‘유니콘’ 일군 인도인 창업자 에잇폴드는 AI로 채용 기업과 지원자의 경력을 분석해 가장 적합한 지원자와 직무를 추천하며, 기업이 직접 서류를 받고 면접을 하지 않아도 최적의 지원자를 매칭해 추천할 수 있다는 점이 특징이다. 에잇폴드의 강점은 AI와 빅데이터 활용 자체보다 ‘편견 배제 알고리즘’에 있으며, 이 알고리즘은 인종적 편견이나 성별, 종교 등을 드러내는 단어는 물론 지원자의 출신 지역이나 학교 이름을 보여주는 정보를 배제한 채 경험과 업무성과 등으로만 데이터를 분석해 낸다. AI를 통해 진정한 ‘블라인드 채용’이 가능하도록 구현한 것이다. 3. ‘IT 인재’ 빨아들이는 ‘핀테크’‘IT 인재’ 빨아들이는 ‘핀테크’ 시중은행과 인터넷전문은행 할 것 없이 IT 인력 채용을 공격적으로 늘리고 있는데, 희비는 엇갈리는 것으로 나타난다. 인터넷은행들은 성과를 내고 있는 반면 기존 주요 은행들은 상대적으로 인력 확보에 어려움을 겪고 있다. 업계에서는 젊고 유능한 IT 개발자들일수록 향후 진로를 생각해 시중은행 업무를 기피한다고 보며, 현재까지도 은행에서는 IT 개발보다는 관리에 초점이 맞춰져 있어 업무역량을 높일 기회가 많지 않고, 순환근무를 통해 지점으로 나가는 등 다른 업무에 배치될 수도 있기 때문이고, IT기업에 비해 상대적으로 경직된 조직문화에 대한 거부감도 있는 것으로 파악된다. 4. 넥슨도 물린 비트코인…코인 급락에 회계상 손실 458억 기록넥슨도 물린 비트코인…코인 급락에 회계상 손실 458억 기록 넥슨 본사인 일본 법인이 지난 4월에 매수한 비트코인의 시세가 급락하면서 약 458억원 규모의 평가손실을 인식했고, 이는 원금의 40%에 달하는 규모다. 한편, 국제회계기준(IFRS) 해석위원회는 지난 2019년 가상자산은 화폐도 금융상품도 아니라는 유권해석을 내놨으며, 판매나 중개를 위해 보유하는 경우는 재고자산으로 보고 그 외에는 모두 무형자산에 해당한다고 결론내어 공정가치(시장가격)가 취득원가보다 하락하면 그 차액을 분기마다 손실(손상차손)로 반영해야 한다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-02-IT_News/"},{"title":"2021년 7월 05일 월요일 IT뉴스","text":"1. 패션 시장 실험 본격화하는 네이버…”동대문 스마트물류에 무료반품까지”패션 시장 실험 본격화하는 네이버…”동대문 스마트물류에 무료반품까지” 최근 네이버는 브랜디 등과 협업해 ‘동대문 스마트 물류’ 시스템을 구축해 동대문 패스트패션 경쟁력에 가속을 달아줄 물류 실험을 진행 중이며, 네이버에 따르면 현재 동대문 패션 상품을 판매하는 7만여명의 판매자 가운데 400여명이 브랜디나 신상마켓 등 스타트업과 연계한 ‘동대문 스마트 물류 서비스’를 이용하고 있다. 동대문 스마트 물류 서비스는 도매시장 사입과 포장, 물류의 전 과정을 대행한다. 판매자들은 상품이나 쇼핑몰 관리, 고객대응, 마케팅 등에 집중할 수 있다. 아울러 네이버는 백화점 및 아울렛윈도를 통해 ‘무료 반품 및 서비스’ 실험도 진행 중으로, 사이즈나 컬러 등 교환 반품 니즈가 높은 일부 패션 상품을 대상으로 오는 7월 말까지 무료 반품 서비스를 시범 운영 중이다. 편리한 무료반품 교환 서비스가 실제 매출 및 주문량 증대로도 이어지고 있다는 게 회사 측의 설명이다. 2. “월 9900원에 OTT와 커피 4잔을 한번에”…KT+할리스 구독상품 나왔다“월 9900원에 OTT와 커피 4잔을 한번에”…KT+할리스 구독상품 나왔다 KT는 전국에 580여 개 매장을 운영하는 커피 브랜드 ‘할리스’와 제휴해 ‘시즌×할리스 구독’ 서비스, 월 9900원에 KT의 OTT 서비스인 시즌(Seezn) 플레인과 할리스 카페아메리카노(레귤러) 4잔을 이용할 수 있다. KT 관계자는 “기존 구독 서비스가 단일 상품이나 서비스를 단순 할인하는 방식이었다면, 이번 KT×할리스 구독 서비스는 MZ세대(1980년대 이후 태어난 젊은 층)에게 인기인 영상 스트리밍과 커피 수요를 모두 충족해 호응도가 높을 것”이라고 기대했다. 3. 연이은 악재…쿠팡, 검색순위 조작·납품업체 갑질 의혹연이은 악재…쿠팡, 검색순위 조작·납품업체 갑질 의혹 물류센터 화재 및 열악한 근로환경 등으로 논란의 중심에 있는 쿠팡이 이번엔 검색순위 조작과 납품업체 갑질 의혹으로 공정거래위원회에 조사를 받게 됐다. 쿠팡이 애플리케이션(앱)에서 자체브랜드(PB) 상품을 다른 납품업체 상품보다 우선 노출되도록 검색 알고리즘을 조작했다는 혐의를 받는 것으로 알려졌다. 또한 쿠팡이 납품업체에 광고 구매를 강요하고 이를 수용하지 않으면 로켓배송 등 혜택 적용에서 제외했다는 의혹을 확인 중인 것으로 전해진다. 4. 카카오T 앱 개편에도 자리 지키는 ‘카풀’…재개 노리나?카카오T 앱 개편에도 자리 지키는 ‘카풀’…재개 노리나? 4일 업계에 따르면 카카오모빌리티는 이달 카카오T 앱을 전면 개편했는데 주목할 점은 2018년 출시 후 택시업계와의 마찰로 제대로 서비스 한번 해보지 못한 카풀이 앱 개편에도 첫 화면 한 자리를 차지하고 있는 것이다. 이에 카카오모빌리티 관계자는 카풀의 사업성에 대해 고민 중이지만, 가까운 시일 내 서비스를 선보이는 건 아니라고 선을 그었다 5. [넘버스]카카오모빌리티에 투자한 LG의 ‘빅픽처’는①LG의 이번 투자는 카카오모빌리티의 주행 데이터를 확보해 모빌리티 사업의 소프트웨어 경쟁력을 강화하려는 전략으로 보입니다. LG가 라이드셀 투자로 모빌리티 사업을 추진할 플랫폼을 확보했다면, 카카오모빌리티는 국내 이용자의 빅데이터를 확보하기 위한 것으로 추정됩니다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-05-IT_News/"},{"title":"2021년 07월 09일 금요일 IT뉴스","text":"1. 라인, 글로벌 CBDC 정조준…블록체인 플랫폼 공개라인, 글로벌 CBDC 정조준…블록체인 플랫폼 공개 라인플러스는 이번에 오픈한 라인 파이낸셜 블록체인 홈페이지를 통해 CBDC를 위한 블록체인 시스템, 전 세계 각국의 CBDC 발행 현황 및 CBDC 에 대한 개념도 소개해 누구나 쉽게 볼 수 있도록 하고 있다. 라인 파이낸셜 블록체인은 금융 플랫폼에 최적화된 블록체인 플랫폼으로 CBDC 사업이 요구하는 결제 완결성을 보장하고, 빠른 속도와 많은 결제량을 처리할 수 있는 확장성을 제공하며 특히 라인이 글로벌 서비스를 운영한 기술력을 바탕으로 결제 정보에 대한 기밀성을 보장한다. 중앙은행 발행 디지털화폐(CBDC) 2. 스포츠에 집중하는 카카오게임즈…코로나 타격에도 베팅 ‘턱턱’, 왜?스포츠에 집중하는 카카오게임즈…코로나 타격에도 베팅 ‘턱턱’, 왜? 9일 관련 업계에 따르면 카카오게임즈는 글로벌 레저·스포츠 커뮤니케이션 전문 기업 세나테크놀로지와 손잡고, 스포츠 커뮤니케이션 플랫폼 영역을 개척하기 위해 카카오게임즈는 약 1000억을 들여 해당 기업을 계열사로 편입시켰고, 카카오 VX가 전개하는 스포츠 및 헬스케어 등 서비스와의 연계를 통한 스포츠 사업으로 확장해나간다는 계획이다. KB금융지주가 지난달 발표한 ‘코로나19가 갈라놓은 골프연습장과 스크린골프장의 차별화’ 보고서에 따르면, 지난해 골프 인구는 515만명으로 전년 대비 46만명가량 증가했다. 그간 골프 시장을 눈여겨봐왔던 카카오는 자회사 카카오게임즈 산하에 2012년 설립됐던 옛 마음골프를 인수한 뒤 이름을 카카오 VX로 바꿨다. 카카오 VX는 성장력과 인지도를 동시에 키우는 데 무서운 속도를 내고 있으며, 이를 뒷받침하는 건, 게임기업으로 성장했던 경험을 바탕으로 LBS(위치기반), VR(가상현실), AI(인공지능) 등 첨단 기술을 융합해 대중을 대상으로 하는 신사업 영역을 펼쳐나가고 있었던 카카오게임즈의 전략적 투자다. 3. 티빙, 독일 분데스리가 독점 중계 “유로2020 열기 이어간다”티빙, 독일 분데스리가 독점 중계 “유로2020 열기 이어간다” 티빙은 2021-22시즌 독일 분데스리가 경기 국내 독점 중계권을 확보하고, 다음달부터 티빙과 채널 tvN, XtvN을 통해 생중계한다. 총 150경기를 생중계하며, 이 중 65경기는 티빙에서만 단독 중계된다. 티빙 콘텐츠사업국 황혜정 국장은 “유로 2020에 보여주신 뜨거운 열기에 보답하고자 유럽 빅리그 중 하나인 분데스리가 생중계를 확정했다”며 “앞으로도 스포츠 생중계와 같이 다양한 장르의 독점 수급 라이브러리를 확대하며 콘텐츠 경쟁력을 강화할 계획”이라고 말했다. 4. “코로나19 퍼지면 안돼”…다시 전면 재택근무 돌입하는 게임사들“코로나19 퍼지면 안돼”…다시 전면 재택근무 돌입하는 게임사들 9일 게임업계에 따르면 크래프톤, 넥슨, 넷마블, 엔씨소프트 등 주요 게임사들은 코로나19 확산을 막기 위해 오는 12일부터 전면 재택근무에 돌입한다. 5. “별점테러 그만”…네이버, 맛집 ‘키워드 리뷰’ 연내 도입(종합)“별점테러 그만”…네이버, 맛집 ‘키워드 리뷰’ 연내 도입(종합) 네이버가 최근 사회적 문제가 되는 ‘별점 테러’, ‘리뷰 갑질’ 등을 막기 위해 매장 후기 시스템을 키워드 중심으로 전환하며, 당장은 리뷰 결과가 사용자에게 공개되지 않지만, 축적한 데이터를 3분기 중 가게의 ‘플레이스 페이지’에 반영할 예정이라고 네이버는 설명했다. 네이버는 8천명이 넘는 사용자와 약 1천명의 사업자 의견을 반영해 후기를 남길 수 있는 키워드를 선정했고, 선정된 키워드에는 부정적인 내용이 포함되지 않았기에 비판적인 피드백은 기존의 ‘텍스트 리뷰’를 활용해 남겨야 한다. 앞으로는 사장님에게만 전하는 비공개 리뷰 기능도 추가될 예정이다. 6. 핀테크 준비부족…마이데이터 본격 시행, 연말로 연기 가닥핀테크 준비부족…마이데이터 본격 시행, 연말로 연기 가닥 당초 금융당국은 8월 초 시행을 목표로 준비했지만 신종 코로나바이러스 감염증(코로나19) 사태로 준비가 부족했다는 핀테크 업체들의 요청을 수용해 연기를 결정했다. 핀테크 업체들은 코로나19 여파로 비대면 IT(정보기술) 개발 수요가 커지면서 개발인력이 부족해졌고, 다양한 통합인증수단을 제공하기로 하면서 마이데이터 시스템 구축에도 추가로 시간이 필요하다고 주장했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-09-IT_News/"},{"title":"2021년 07월 07일 수요일 IT뉴스","text":"1. 올해 상반기 네이버페이 결제금액 17.7조원올해 상반기 네이버페이 결제금액 17.7조원 모바일 앱 시장 분석 서비스 업체 와이즈앱은 올해 상반기 ‘네이버페이’로 결제된 쇼핑, 콘텐츠 금액이 작년 같은 기간 대비 41% 증가한 액수로 약 17조7000억원이라고 7일 추정해 발표했다. 네이버페이 사용자 수는 지난 6월 한 달 동안 1711만명으로 이들은 월 평균 18만1680원을 결제했으며, 6월 기준 연령별 결제금액 분포는 20대가 17.4%, 30대가 37.5%, 40대가 26.0%였다. 50대 이상은 19.4%였다. 2. ‘초대형IB’ 꿈꾸는 카카오페이…’1조+@’ 쏟아 증권·보험 등 전방위 확장‘초대형IB’ 꿈꾸는 카카오페이…’1조+@’ 쏟아 증권·보험 등 전방위 확장 7일 금융감독원 전자공시시스템에 따르면 카카오페이는 증권신고서에 “이번 공모자금을 활용해서 자회사 카카오페이증권의 리테일사업 확장을 위한 자본 확충을 가속화할 계획”이라며 “중장기적으로는 프라임 브로커리지 등 IB사업 진출도 목표로 하고 있다”고 밝혔다. 카카오페이는 지난달 금융위원회로부터 디지털 손해보험사 설립 예비허가를 받았고, 이를 기반으로 내년 1분 기중 공식 론칭을 계획하고 있고 현재 기존 보험업계에 몸담고 있는 전문가들을 영입하는 작업이 한창이다. 3. 마블 코믹스 ‘블랙 위도우’ 네이버웹툰으로 나온다마블 코믹스 ‘블랙 위도우’ 네이버웹툰으로 나온다 이번 작품은 네이버웹툰을 통해 선보이는 ‘마블 웹툰 프로젝트’ 첫번째 시리즈로 마블 코믹스의 원작은 웹툰 형태에 맞게 재창조한 세계 최초의 타이틀이다. 네이버웹툰은 ‘블랙 위도우’를 시작으로 어벤저스, 스파이더맨, 헐크 등 대작들을 9월부터 네이버웹툰과 네이버 시리즈에서 감상할 수 있다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-07-IT_News/"},{"title":"2021년 07월 12일 월요일 IT뉴스","text":"1. [단독] “타도 오늘의집”…집꾸미기-하우저 전격합병[단독] “타도 오늘의집”…집꾸미기-하우저 전격합병 연 42조원에 달하는 인테리어 시장은 코로나19 사태 이후 e커머스로 급격히 전환하면서 선두 다툼이 치열해지고 있으며, 업계 1위 오늘의집을 따라잡기 위해 2위인 집꾸미기와 3위 하우저가 전격 합병한다. 집꾸미기는 인테리어 콘텐츠 커뮤니티를 운영하며 이를 기반으로 커머스 영업을 하는 인테리어 거래 플랫폼 하우저는 빅데이터를 활용해 가구, 가전 물류를 효율화하는 인테리어 스마트 물류 플랫폼이다. 거래 플랫폼과 물류 플랫폼을 합쳐 시너지를 낸다는 방안으로 두 회사의 기업가치는 500억원 수준으로 알려졌지만, 벤처캐피털(VC) 업계 관계자는 두 회사의 시너지를 생각하면 훨씬 더 높은 가치를 받을 것”이라고 말했다. 2. 야놀자 “손정의 회장 1조 투자설? 확인해줄 수 없어”야놀자 “손정의 회장 1조 투자설? 확인해줄 수 없어” 여가 플랫폼 야놀자 측이 최근 1조원에 이르는 손정의 일본 소프트뱅크그룹 회장의 대규모 투자설과 관련해 “확인해줄 수 없다”고 12일 입장을 밝혔다으며 앞서 투자유치설에 대해 ‘사실무근’이라고 했다가 ‘노코멘트’로 입장을 선회해 그 배경에 관심이 쏠린다. 야놀자는 올해 IPO는 물론 해외상장도 모색 중으로, 최근 장외거래시장에서 9~10조원 이상 가치로 거래되고 있는 유니콘(기업가치 1조원 이상 비상장기업)이다. 3. 무디스 “카뱅, 1년 후 대출시장 점유율 65%까지 확대”무디스 “카뱅, 1년 후 대출시장 점유율 65%까지 확대” 신용평가회사 무디스는 카카오뱅크가 대출 시장에서 향후 큰 폭의 성장을 하고, 전통 은행들에 빅테크의 위협을 분명하게 보여주게 될 것이라고 분석했고, 최근 발표한 보고서에서 “카카오뱅크가 주택담보대출과 중소상공인 대출 상품을 출시할 경우 전체 원화대출 시장서 차지하는 비중이 향후 12~18개월간 현재의 14%에서 65%까지 확대될 것”이라고 예상했다. 또한 무디스는 올해 하반기 상장 후 카카오뱅크의 자본이 3월말 대비 약 76~90% 늘어날 것으로 예상했고 아울러 카카오뱅크가 첨단 기술을 활용하는 동시에 오프라인 점포 없이 운영해 다른 은행 대비 상대적으로 낮은 비용구조를 유지하고 있다는 점이 긍정적이라고 평가했다. 4. 셧다운제 폐지 법안 쏟아지는데…버티는 여가부셧다운제 폐지 법안 쏟아지는데…버티는 여가부 심야시간대에 청소년들의 인터넷게임 접속을 제한하는 셧다운제 폐지 법안이 연이어 발의되면서 논의에 속도가 붙고 있으며, 셧다운제는 시행 후 약 10년 동안 실효성 논란에 휩싸여왔으며 사실상 실패한 법이라는 평가가 지배적이다. 최근 촉발된 마이크로소프트(MS)의 게임 ‘마인크래프트’ 사태는 다시 한 번 셧다운제 폐지 논의에 불을 지폈다. 마인크래프트는 교육용으로도 사용되는 청소년 인기 게임으로 알려져 있다. 한국행정학회가 2017년 한국콘텐츠진흥원에 제출한 ‘청소년 게임이용시간 제한제도 개선방안 연구’ 용역 과제 보고서에 따르면 게임이용시간 자체에 대한 통제의 정책적 효과가 예상보다 크지 않은 것으로 나타났다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-12-IT_News/"},{"title":"2021년 6월 25일 금요일 IT뉴스","text":"1. 이용률 반토막 공유킥보드…업체별 돌파구는?이용률 반토막 공유킥보드…업체별 돌파구는? 24일 관련업계에 따르면, 전동킥보드 업체 대부분은 안전모를 비치하거나 이용자에게 안전모를 제공·판매하는 방식으로 개인형 이동장치(Personal Mobility, PM)관련 규제 대응에 나섰다. 요금제의 경우 현행의 잠금해제비(기본료)+분당 과금 방식을, 택시 미터기 요금처럼 시간과 거리를 반영한 요금을 도입함으로써 이용자들이 공유킥보드를 급하게 타지 않도록 하는 방안이 논의되고 있으며 또 일반인들이 불법 이용자들을 신고할 수 있도록 킥보드마다 번호판을 도입하는 것도 여러 선택지 중 하나로 거론된다. 2. “제페토에서 만나요”…메타버스 눈독 들이는 금융권“제페토에서 만나요”…메타버스 눈독 들이는 금융권 신기술이 불러올 금융권 변화에 대응하고 MZ세대에 발맞추기 위해 가상의 공간인 ‘제페토’에서 금융권 임원들이 모여 회의를 하거나 메타버스 기반의 차세대 금융 인프라 연구에 나서는 등 움직임이 본격화되고 있다. 금융권이 메타버스에 이처럼 높은 관심을 갖는 배경은 현실과 가상을 이어주는 메타버스 플랫폼이 미래세대의 소통창구로 자리잡을 가능성이 높아서이며, 하나금융연구소도 “메타버스 시대의 금융업은 업무 방식이나 고객 니즈, 서비스에 있어 온라인과 오프라인 통합이 강화된 구조”라며 “장기적인 관점에서 MZ세대를 위한 콘텐츠 개발과 복합점포 등이 필요할 것”이라고 전망했다. 3. ‘갤럭시Z폴드3’ 이미지 유출…S펜 등장, UDC는 글쎄‘갤럭시Z폴드3’ 이미지 유출…S펜 등장, UDC는 글쎄 삼성전자 차기 폴더블(접이식) 스마트폰 ‘갤럭시Z 폴드3’와 ‘갤럭시Z 플립3’의 공식 홍보용 사진으로 추정되는 제품 모습이 처음 등장했으며, 소문대로 Z 폴드3는 S펜(스타일러스) 지원이 확실시되지만, 화면 아래 카메라를 두는 언더디스플레이카메라(UDC)는 빠진 것으로 보인다. 제품은 8월 중순께 열릴 것으로 예상되는 ‘갤럭시 언팩’에서 모습을 드러낼 것으로 전망되며, 이 행사에서는 스마트워치 갤럭시워치4·워치 액티브4, 무선 이어폰 갤럭시버즈2가 함께 공개될 것으로 알려졌다. 4. 토스, 4600억원 신규 투자 유치..”기업가치 8조2000억원”토스, 4600억원 신규 투자 유치..”기업가치 8조2000억원” 토스 관계자는 “투자자들이 토스가 2000만 유저를 바탕으로 뱅킹, 증권 등의 개인 금융 서비스를 하나의 앱에서 제공하는 것과 PG업계 최상위권 계열사인 토스페이먼츠를 통한 사업자 대상 서비스 등 B2B사업까지 보유한 독특한 모바일 금융 플랫폼이란 점에 매력을 느꼈다”고 전했다. 이승건 토스 대표는 “코로나19 이후 금융의 디지털 전환 속도가 급격히 빨라지고 있어 모바일 금융 플랫폼의 성장 기회가 크다”며 “은행, 증권 등 주요 영역에 토스가 직접 플레이어로 진출하면서 금융 서비스와 상품을 고객 관점에서 완전히 새롭게 설계할 수 있게 됐다”고 강조했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-06-25-IT_News/"},{"title":"2021년 07월 14일 수요일 IT뉴스","text":"1. 20% 넘어선 국내 클라우드 이용률… 유료화·서비스 종료로 선택지는 줄어20% 넘어선 국내 클라우드 이용률… 유료화·서비스 종료로 선택지는 줄어 개인용 클라우드 이용률은 높아졌지만 이용할 수 있는 클라우드 선택지는 줄어드는 모습이다. 구글이 최근 클라우드 서비스 유료화를 시작했고, 경쟁에서 밀려난 이통3사 등은 ‘변화된 시장 환경’을 이유로 클라우드 서비스를 종료하고 있다. LG유플러스는 올해 12월 개인 클라우드인 ‘U+박스’를 종료하고, SK텔레콤도 오는 9월27일 개인용 클라우드 서비스인 ‘클라우드 베리’를 종료하기로 했으며, 앞서 KT는 지난해 개인 클라우드 서비스를 종료했고 삼성전자도 갤럭시 스마트폰 이용자에게 제공하던 삼성 클라우드 서비스를 최근 종료하고, 마이크로소프트 원드라이브로 데이터를 이전하도록 했다. 2. “카카오택시에 상대도 안돼?”…‘우티’의 굴욕“카카오택시에 상대도 안돼?”…‘우티’의 굴욕 SK텔레콤의 모빌리티 기업 ‘T맵 모빌리티’와 우버가 함께 만든 택시 호출 플랫폼 ‘우티’가 고전하고 있는데 출범 초기 이용자가 증가하며 순항하는 듯 했으나, 한 달만에 30만 명이 줄어들며 주춤하는 모양새다. 택시 호출 중개 시장은 ‘모빌리티’ 경쟁의 최전선이다. 대중화된 택시 호출 서비스에서 충분한 이용객을 확보해야 향후 대리 운전, 렌트카, 차량 공유, 전동 킥보드 등 개인형 이동수단(PM) 등 이동·운송 서비스 확장이 용이하기 때문이다. 3. 새 주인 찾는 인터파크, 누가 탐낼까?새 주인 찾는 인터파크, 누가 탐낼까? 국내 1세대 이커머스 플랫폼인 인터파크가 매물로 나오면서 인수 후보에 관심이 쏠리고 있다. 시장에서는 항공과 티켓 판매 서비스를 제공 중인 네이버와 카카오도 인수 후보로 거론되고 있고 NHN티켓링크를 자회사로 두고 있는 NHN 또한 인터파크를 인수해 업계 1위로 올라설 수 있는 기회가 될 수 있다. NHN 자회사인 여행박사와 시너지를 낼 수 있는 기회이기도 하다. 4. 도쿄올림픽, 모바일은 어디서?…네이버·카카오 등 중계권 협상도쿄올림픽, 모바일은 어디서?…네이버·카카오 등 중계권 협상 14일 업계에 따르면 네이버, 카카오, 웨이브, 아프리카TV, KT 시즌(Seezn) 등이 현재 지상파 3사와 도쿄올림픽 온라인 중계권 협상을 진행 중인 것으로 알려졌으며, 최근까지 쿠팡의 단독 중계권을 거의 확보한 듯한 형국이었으나, 협상 내용이 밝혀진 뒤 ‘보편적 시청권’ 논란이 일면서 쿠팡이 철회 의사를 밝힌 것으로 알려졌다. 하지만 코로나19 확산과 스타선수의 부재 등으로 도쿄올림픽에 대한 국민적 관심이 예년 같지 않아, 쿠팡이 올려놓은 중계권료를 지출하는 데 큰 부담을 느끼고 있는 것으로 전해졌다. 5. 5년전 美증시 입성한 라인의 ‘나비효과’…”카카오 안부럽다”5년전 美증시 입성한 라인의 ‘나비효과’…”카카오 안부럽다” 5년 전 상장 당시 이해진 창업자(현 글로벌투자책임자)는 “라인이 이제는 도쿄와 뉴욕에 상장되며 글로벌 브랜드의 힘을 갖게 된 것이 너무 기쁘다”며 “조금 더 공격적으로 할 수 있는 자금이 확보되고, 성장할 수 있는 계기 마련됐다. 기술 쪽에 가장 많이 투자할 것”이라고 말하기도 했다. 이같은 네이버의 행보가 쿠팡의 뉴욕 상장 등 여타 IT 기업의 글로벌 진출에 긍정적 영향을 줬다는 분석도 나온다. 국내 스타트업 하이퍼커넥트 ‘아자르’가 중동에서 큰 성공을 거둔뒤, ‘틴더’를 운영하는 매치그룹에 약 2조원에 매각되는 등 국내에서의 성공만이 답이 아니라는 점을 알려줬다는 것이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-14-IT_News/"},{"title":"2021년 07월 16일 금요일 IT뉴스","text":"1. 구글코리아, ‘머신러닝 부트캠프’ 개최구글코리아, ‘머신러닝 부트캠프’ 개최 머신러닝 부트캠프는 머신러닝 개발자 지망생들에게 교육과 취업 기회를 제공하고, 머신러닝 개발 인력 부족으로 어려움을 겪고 있는 국내 기업이 인력풀을 확보할 수 있도록 지원하는 프로그램이며, 지난해 진행한 프로그램에는 약 3천명의 개발자가 지원했으며 이중 코세라 딥러닝 특화과정을 수료한 150여명의 참가자는 머신러닝 자격증을 취득해 현재 다양한 산업군에서 머신러닝 개발자로 근무하고 있다. 올해 머신러닝 부트캠프에는 실습형 교육 과정이 새롭게 추가됐다. 참가자는 글로벌 인공지능 경진대회 플랫폼 캐글(Kaggle)의 과제 중 하나를 선택해 일정한 순위권에 오르는 것을 목표로 실습형 교육 과정을 경험, 프로젝트를 주도적으로 진행해 직접 성과를 내게 된다. 2. 개발자로 만족한다 39.2%···연봉 불만 1~3년차가 가장 높아개발자로 만족한다 39.2%···연봉 불만 1~3년차가 가장 높아 디지털 전환(DX) 바람으로 소프트웨어(SW) 개발자 몸 값이 상한가지만 개발자로서 만족한다는 응답이 39.2%에 불과하다는 조사 결과가 나왔으며, 연봉에 불만이 가장 높은 개발자는 1~3년차인 것으로 나타났고 5년차 미만 개발자들은 근무 연차와 상관 없이 4000만원 이상 5000만원 미만 수준의 연봉을 희망 연봉 1순위로 답해, 개발자의 최소 희망 몸값은 4000만원 수준으로 점쳐졌다. 한편 개발자들은 자신의 연봉을 높이기 위해 교육, 프로젝트 준비, 스터디 모임 등 자기개발에 힘쓰고 있는 것으로 나타났다. 복수 의견으로 조사한 연차 별 연봉 인상을 위한 노력을 묻는 질문에 대다수 현업 활동 개발자는 토이 프로젝트를 1순위로 꼽았고, 단 10년차 이상 개발자는 동영상 강의로 프로젝트 준비를 갈음했으며 3년차 미만 개발자는 부족한 이론 지식을 습득하기 위한 스터디 모임에 중점을 둔 것으로 확인됐다. 3. 야놀자, 실탄 2兆 장전…제2의 쿠팡 대박 신화 시작됐다야놀자, 실탄 2兆 장전…제2의 쿠팡 대박 신화 시작됐다 1조원에 달하는 자금을 유치할 것이라는 업계 소문보다 2배 가까운 ‘실탄’을 확보한 야놀자는 미국 나스닥 상장 추진과 함께 연간 3천조원 규모의 글로벌 여행·호스피탈리티 시장을 공략할 것으로 전망된다. 이미 해외에 호텔 등 객실관리 시스템을 구축한 야놀자는 국내에서 쌓은 경험을 글로벌 시장에 이식함으로써 글로벌 여가 플랫폼 입지를 더욱 튼튼히 다질 것으로 기대를 모은다. 한 사모펀드(PE)운용사 관계자는 이번 투자 유치를 두고, 야놀자가 일본·동남아 시장 공략을 위한 초석을 다진 것으로 전망했다. 4. 반려동물 통합 케어 플랫폼 ‘펫닥’, 100억 원 규모 시리즈C 투자 유치반려동물 통합 케어 플랫폼 ‘펫닥’, 100억 원 규모 시리즈C 투자 유치 반려동물 통합 케어 플랫폼 서비스 ‘펫닥’이 100억 규모의 시리즈C 투자 유치를 했다. 펫닥은 이번 투자를 바탕으로 수의사들과 시너지 효과를 내고, 안전하고 신뢰할 수 있는 반려동물 식품과 헬스케어 서비스를 제공한다는 계획이다. 5. MZ세대 10명 중 9명, “핀테크로 간편결제 사용…만족도 높아”5년전 美증시 입성한 라인의 ‘나비효과’…”카카오 안부럽다” 20･30 MZ세대들이 대표적인 핀테크 서비스인 간편결제(송금) 서비스를 이용하기 위해 카카오페이, 네이버페이, 토스 등 핀테크 플랫폼을 주로 사용하고, 핀테크 서비스를 이용하는 이유는 간단하고 편리한 절차 등 편의성이 가장 큰 것으로 나타났다. 전금법 개정안 통과로 달라질 금융 생활에 대해 2030세대는 대체로 긍정적인 의견을 밝혔고 특히 핀테크 플랫폼, 카드사 등에 계좌를 개설하고 급여를 이체받아 바로 결제 및 송금, 공과금 및 카드청구금 납부 등이 가능한 종합지급결제사업자 도입에 대해 긍정적인 의견이 84.6%에 달했다. 이 외 소액후불결제 도입, 선불충전금 한도 상향 등에 대해서도 절반 이상이 필요하거나 유용하다 등 긍정적 의견을 보였고, 고위험 거래에 대한 2개 이상의 인증 의무 등 보안강화에 대해서도 “지금보다 불편해져도 금융거래 안전을 위해 필요하다”는 의견이 62%에 달했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-16-IT_News/"},{"title":"2021년 07월 19일 월요일 IT뉴스","text":"1. 턱밑까지 추격한 샤오미… 폴더블폰이 삼성 구할까턱밑까지 추격한 샤오미… 폴더블폰이 삼성 구할까 중국 샤오미가 올 2분기 전 세계 스마트폰 시장 2위에 오르며 삼성전자의 턱밑까지 치고 올라온 가운데, 애플이 9월 출시할 아이폰 차기작이 아이폰 역사상 최고 히트작이 될 것이라는 전망이 나오고 있어서 삼성전자가 중저가 시장에서는 샤오미에 밀리고, 수익성에서는 애플과 격차가 더 커지는 샌드위치 신세가 될 가능성이 높다는 것이다. 삼성전자는 특히 갤럭시Z폴드3와 갤럭시Z플립3의 가격을 각각 전작보다 40만원가량 낮춘 199만원과 128만원으로 책정하는 방안도 고민 중으로 폴더블폰 가격을 아이폰이나 갤럭시S 시리즈 수준까지 낮춰 새로운 수요를 개척하겠다는 것이며 하반기 전략 스마트폰인 갤럭시노트를 올해 출시하지 않는 승부수까지 던지면서 사실상 ‘폴더블 올인’ 전략을 구사하는 것이다. 2. 크래프톤, 인도 웹소설 플랫폼 ‘프라틸리피’에 515억 원 투자… 올해 인도 IT기업에 802억 투자 집행크래프톤, 인도 웹소설 플랫폼 ‘프라틸리피’에 515억 원 투자… 올해 인도 IT기업에 802억 투자 집행 크래프톤이 인도 최대 웹소설 플랫폼 ‘프라틸리피(Pratilipi)’에 총 4,500만 달러(한화 약 515억 원)의 투자를 진행했다. 크래프톤 손현일 투자본부장은 “프라틸리피의 서적, 코믹스, 오디오 플랫폼를 통해 인도 현지 IP의 성장을 지켜보면서 인도 현지 IP가 인도 뿐 아니라 전 세계적으로 성공할 수 있다는 장기적인 잠재력을 믿게 됐다”며, “프라틸리피는 이미 웹소설 분야의 다국어 플랫폼을 보유하고 있기 때문에 향후 시장에서 크게 성장할 기업이라고 보고 있다”고 말했다. 프라틸리피는 3,000만 명의 월간 활성 이용자(MAU)와 37만 명의 작가를 확보하고 있는 인도 최대 웹소설 플랫폼이다. 12개의 인도 언어로 서비스를 제공하고 있으며, 최근에는 웹소설 뿐만 아니라 일반서적, 애니메이션, TV시리즈 등 다양한 형태의 콘텐츠 제공을 위해 관련 기업들과의 협업을 가속화하고 있다. 또, 프라틸리피 FM, 프라틸리피 코믹스 등을 출시하며 서비스 범위도 확장 중이다. 3. 의약품 주문통합 플랫폼 ‘바로팜’, 팁스 프로그램 선정의약품 주문통합 플랫폼 ‘바로팜’, 팁스 프로그램 선정 의약품 주문통합 플랫폼인 ‘바로팜’이 중소벤처기업부가 주관하는 민간투자주도형 기술창업지원(TIPS) 프로그램에 선정됐다. 현재 200여개 약국이 바로팜 서비스를 이용하고 있고 이번 투자를 통해 수도권 위주의 서비스에서 전국적인 서비스로 확대해 나갈 예정이며 올 하반기 1000개 약국에 바로팜 서비스를 제공하는 것을 목표로 하고 있다. 현직 약사이자 바로팜 김슬기 대표는 “바로팜은 의약품 주문통합 플랫폼으로서 업무에 지친 약사님들에게 간편한 주문 시스템을 제공하고 지속적으로 약국 주문 관련 불편한 부분을 약사님들과 함께 고민해 나갈 예정이다. 이를 통해 약국경영에 도움을 주는 다양한 서비스들을 선보일 것”이라고 말했다 팁스: 팁스는 우수 기술을 보유한 유망 스타트업을 발굴해 정부가 2년 간 최대 7억 원을 지원 및 투자하는 대표적인 민간 투자 주도형 기술 창업 지원 프로그램이다. 바로팜: 바로팜은 의약품을 주문하는 도매사이트들을 한 곳에서 관리하는 ‘의약품 주문 통합 솔루션’을 제공하는 플랫폼이다. 현재 의약품 통합 주문, 주문 알림톡 발송, 약국 관련 주문사이트 바로가기 통합 제공, 의약품 정보 식별 및 약물 상호작용 검색 기능 제공 등 다양한 서비스를 약국에 제공하고 있다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-19-IT_News/"},{"title":"2021년 07월 28일 수요일 IT뉴스","text":"1. 2분기 스팸건수, 1분기보다 9만건 ↑…대출·보험 유형2분기 스팸건수, 1분기보다 9만건 ↑…대출·보험 유형 스팸 차단 애플리케이션 ‘후후’를 제공하는 후후앤컴퍼니는 2021년 2분기 후후 이용자들이 신고한 스팸 통계를 28일 발표했고, 전분기 대비 9만여건 증가한 692만건의 스팸 신고가 접수됐다. 주식·투자, 불법게임·도박 관련 스팸은 줄었지만, 대출·보험 가입 권유형 스팸이 급격히 늘었다. 개별 스팸 내용을 질적으로 분석해 본 결과 금융기관을 사칭해 대출·보험 등 금융 상품 상담을 명목으로 전화를 유도하는 수법이 증가했고금융과 전혀 관계 없는 보이스피싱 집단도 금융기관의 이름을 사칭할 수 있는 만큼 고객들의 세심한 주의가 필요하다. 2. 네이버 쇼핑에 AI ‘하이퍼클로바’ 적용…“상품명 자동 교정”네이버 쇼핑에 AI ‘하이퍼클로바’ 적용…“상품명 자동 교정” 네이버에 따르면 상품 코드나 상세 스펙, 이벤트 내용 등 많은 정보가 포함돼 복잡하고 긴 상품명이 쇼핑판에 노출되는 경우 이를 직관적이고 쉬운 상품명으로 하이퍼클로바가 자동 교정한다. 예를 들면 ‘0000(브랜드명) 남성 21SS 천연소가죽 멀티라인 슬림 댄디 스니커즈 FQKD1314GRT’와 같은 긴 상품명을 ‘0000(브랜드명) 천연소가죽 스니커즈’로 자동 변환해 사용자에게 노출하는 방식이다. 이밖에도 하이퍼클로바를 활용해 수천, 수만개의 쇼핑 리뷰를 한줄로 요약해주는 쇼핑 리뷰 요약 시스템도 서비스 적용을 앞두고 있다. 네이버 관계자는 “하이퍼클로바는 방대한 한국어 학습량을 기반으로 스스로 핵심 내용을 요약하고 새로운 문장을 생성하는 데 뛰어난 능력을 보이고 있다”며 “이를 바탕으로 마치 사람이 큐레이션을 위해 문구를 작성한 것처럼 상품명을 교정할 수 있다”고 말했다. 3. 야놀자, 고속버스 예매 서비스 오픈…”여행 슈퍼앱 전략 가속”야놀자, 고속버스 예매 서비스 오픈…”여행 슈퍼앱 전략 가속” 야놀자는 국내외 숙박·레저·레스토랑·교통(항공·철도·렌터카) 등 여행을 위한 모든 서비스를 통합 제공하고 있다. 특히 숙박, 레저 등 기존 사업과의 시너지를 위해 2019년 글로벌 항공권 검색 서비스를 시작으로 철도, 렌터카 등 교통 카테고리를 확대해 왔으며, 새로 선보인 고속버스 예매 서비스 역시 여행 슈퍼앱 전략의 일환으로, 보다 고도화된 모빌리티 환경을 구축하기 위해 마련했단 설명이다. 야놀자 앱 내 교통·항공 카테고리에선 전국 프리미엄·우등·일반 등 모든 등급의 고속버스를 확인할 수 있으며, 노선 검색부터 예매, 발권 등 고속버스 이용을 위한 모든 과정을 지원한다. 4. 카뱅 ‘휴면예금·보험금 찾기’ 출시 이틀만에 11억원 지급카뱅 ‘휴면예금·보험금 찾기’ 출시 이틀만에 11억원 지급 카카오뱅크가 ‘휴면예금·보험금 찾기’ 서비스 출시 이틀 만에 지급액이 11억원을 돌파했다고 23일 밝혔으며, 카카오뱅크에 따르면 이틀 간 서비스를 조회한 이용자 수는 17만명이다. 약 5만8000건의 휴면예금과 휴면보험금이 원권리자에게 지급됐다. 카카오뱅크 관계자는 “고객들의 보다 편리한 금융생활을 위해 유용한 서비스를 지속 출시할 계획”이라고 말했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-28-IT_News/"},{"title":"2021년 07월 21일 수요일 IT뉴스","text":"1. 네이버-CJ, 풀필먼트 센터 확충…’당일배송·새벽배송’ 뛰어든다(종합)네이버-CJ, 풀필먼트 센터 확충…’당일배송·새벽배송’ 뛰어든다(종합) 네이버는 CJ대한통운과 함께 네이버 스마트스토어 판매자를 중심으로 전국 빠른 배송 서비스를 구축한다고 21일 밝혔고, 기존 네이버 스마트스토어를 중심으로 운영해온 곤지암·용인·군포 풀필먼트 센터에 이어 추가로 20만평 규모의 풀필먼트 센터를 설립한다. 네이버는 지난 12일 풀필먼트 데이터 플랫폼 ‘NFA’를 열었고, 이어 네이버는 지난 20일 특수 물류 전문 업체 발렉스와 손잡고 프리미엄 배송 실험을 시작했으며, ‘희망일 배송’까지 네이버의 NFA를 통해 다양한 배송 서비스 지원을 확대할 계획이다. 풀필먼트는 물류 전문업체가 판매자 대신 주문의 포장과 배송까지 담당하는 서비스를 말한다. NFA는 네이버의 인공지능(AI)을 기술력을 이용해 물류 데이터 분석, 사업자별 물류 수요예측 등의 기능을 제공하는 서비스다. 프리미엄 서비스는 고가의 전자제품을 금고와 폐쇄회로(CC)TV, GPS 등이 설치된 보안 차량으로 상품을 안전하게 배송하는 서비스다. 2. 암 진단 AI ‘왓슨’ 빈자리 누가 채우나…치료까지 넘보는 한국 AI스타트업암 진단 AI ‘왓슨’ 빈자리 누가 채우나…치료까지 넘보는 한국 AI스타트업 지난 2011년 IBM이 선보였던 인공지능(AI) 왓슨은 암 진단 정확도를 높일 주역으로 주목받았지만, 10년이 지난 현재, 기대만 못 한 정확도에 위기를 겪고 있으며, 의료AI 스타트업들이 암 치료에 도전하면서 왓슨이 설 자리는 더 좁아진 모양새다. 대표적인 곳이 국내 의료AI 스타트업인 루닛으로, 지난 19일 루닛은 미국의 바이오 헬스케어기업인 ‘가던트헬스(Guardant Health)’로부터 약 300억원 규모의 시리즈C 후속 투자를 받았다. 가던트헬스는 암 정밀 분석법인 액체생검 분야에서 선도적인 위치에 있으며, 미국 혈액종양내과 전문의 중 80%가 이곳 제품을 쓰는 것으로 알려져 있다. 3. 마이크로소프트, 윈도365로 기업 업무환경 바꾼다마이크로소프트, 윈도365로 기업 업무환경 바꾼다 윈도365는 윈도10 환경을 클라우드서비스 애저에 구축하고, 웹브라우저를 통해 접속하는 가상데스크톱인프라(VDI) 서비스로, PC가 아닌 맥, 아이패드, 안드로이드 스마트폰 등에서도 웹브라우저를 통해 윈도 환경에 접근해 업무를 수행할 수 있고 하드웨어의 종류나 성능, 장소 제약 없이 윈도를 사용할 수 있어 원격 업무환경 지원에 용이하다. 대기업에서 필요한 재택근무 시스템은 윈도와 문서도구 외에도, 전사적자원관리(ERP), 공급망관리(SCM), 고객관계관리(SCM) 등 대규모 IT서비스와 연계가 필요하여 파트너사에 의뢰해 직접 VDI를 구축하거나, 윈도365에 필요한 기능을 더하는 추가 작업이 필수적이다. 나무기술의 권세창 과장은 “대기업과 금융권에서 VDI를 사용하기 위해선 윈도10 외에도 수백 종의 협업 도구를 포함하고 있어 윈도365 단독으로 제공하긴 어려울 것”이라며 “IT서비스 기업에게 윈도365는 대기업 VDI 구성을 위한 하나의 옵션으로 보는 것이 더 적합할 것”이라고 설명했다. 4. [유튜피아] 진격의 ‘틱톡’에 따라잡힌 유튜브…’틱톡 따라하기’ 맞불[유튜피아] 진격의 ‘틱톡’에 따라잡힌 유튜브…’틱톡 따라하기’ 맞불 동영상 플랫폼 절대 강자 ‘유튜브’가 흔들리고 있다. 이미 일부 국가의 경우 ‘틱톡’의 이용시간이 유튜브를 앞지른 것으로 나타났다. 유튜브가 ‘숏폼’ 콘텐츠를 전면에 내세우며 틱톡 따라잡기에 나섰다면, 틱톡은 동영상의 제한 길이를 늘려 ‘유튜브’ 따라잡기에 나섰다. 틱톡은 지난 1일 영상의 길이 제한을 기존 1분에서 3분으로 대폭 늘린다는 계획을 내놨다. 15초 길이의 짧은 영상에서 60초까지 영상 길이를 늘렸던 틱톡이 3분짜리 동영상으로 유튜브를 정조준한 것이다. 5. “왜 불편하게 바꾸나” T멤버십 놓고 와글와글“왜 불편하게 바꾸나” T멤버십 놓고 와글와글 현재 SK텔레콤 T멤버십 프로그램은 제휴 브랜드인 파리바게뜨·CU 등에서 1000원 상당의 물품을 구매하고 등급에 따라 50~100원 할인된 금액만을 결제하는 방식이지만, 앞으로는 할인 금액만큼의 포인트를 우선 적립하고, 원하는 제휴 브랜드 매장만을 골라서 적립한 금액을 한 번에 사용할 수 있다. 김대종 세종대 경영학부 교수는 “포인트 적립으로 멤버십을 바꾸는 것은 포인트가 몇 년 후 소멸된다는 점, 구매 당시 바로 할인을 받을 수 없다는 점에서 당연히 소비자에게 불리한 방식”이라고 말했다. 일각에서는 일정 수준 이상 포인트를 모아야 사용할 수 있는 ‘최소 사용 금액’ 도입을 우려하는 목소리도 나온다. 예컨대 제휴 브랜드에서 적립된 포인트를 사용하려고 해도 ‘포인트 1000원 이상 사용 가능’ 같은 기준이 정해져 있어 이 금액을 넘는 적립액을 쌓기 위한 소비를 지속적으로 해야 한다는 것이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-21-IT_News/"},{"title":"2021년 07월 23일 금요일 IT뉴스","text":"1. NHN페이코, 오프라인 결제 인프라 확대…’페이코 단말기’ 보급한다NHN페이코, 오프라인 결제 인프라 확대…’페이코 단말기’ 보급한다 NHN페이코는 자체 개발한 ‘페이코(PAYCO) 결제 단말기’의 보급을 통해 오프라인 결제 인프라(기반시설) 확대에 나선다고 21일 밝혔다. 페이코 결제 단말기(C2100)는 서명 패드와 각종 결제 리더기를 일체화한 올인원 단말로 IC, 마그네틱, NFC, QR·바코드, 비자(VISA) 콘택트리스(비접촉식) 결제를 모두 지원하고 전후면에 고해상도 LCD와 IC카드 슬롯을 각각 탑재해 가맹점주, 고객의 양방향 결제가 가능한 것이 특징이다. 신종 코로나바이러스 감염증(코로나19)로 수요가 확대된 QR·바코드 결제는 별도 리더기 없이 내장 카메라를 통해 지원하고 카드를 긁거나 삽입하지 않고 단말기에 대는 것만으로 결제가 이뤄지는 비자 콘택트리스 결제도 가능하다. 비자 콘택트리스는 EMV 규격 기반의 IC칩 보안 기술 및 비자 토큰 서비스(VTS·Visa Token Service)를 적용해 편의성과 보안성을 높인 결제 기술이다. NHN페이코는 동반성장위원회 지원사업을 시작으로 향후 주요 VAN사와 협력해 단말기 보급을 본격적으로 확대해 나갈 계획으로 다양한 업종에서 페이코 결제 인프라를 지속적으로 확대하기로 했으며, 기존 단말기가 QR·바코드 결제를 지원하지 않아 페이코 결제 도입이 어려웠던 매장이 가맹점으로 유입되는 효과가 있을 것으로 기대된다. 2. 네이버, 매출 절반이 ‘신사업’ e커머스·핀테크 성장 힘준다네이버, 매출 절반이 ‘신사업’ e커머스·핀테크 성장 힘준다 올 2·4분기 매출 1조6635억원 중 절반 이상을 △e커머스(3653억원) △핀테크(2326억원) △콘텐츠(1448억원) △클라우드(949억원)에서 벌어들인 것으로 이는 검색·디스플레이 광고가 핵심인 서치플랫폼 매출(8260억원)을 넘어선 규모다. 스마트스토어 당일배송-신용대출네이버 스마트스토어 46만 판매자들 대상으로 ‘네이버 풀필먼트 얼라이언스(NFA)’를 출시하고, CJ대한통운과 전국 당일배송 풀필먼트 체계를 구축하기로 했으며, 핀테크 부문 관련 네이버파이낸셜 신용평가모델을 더욱 정교화해 더 많은 네이버페이 이용자들이 다양한 혜택을 누릴 수 있도록 할 것이라고 했으며, 네이버는 사업자 전용 신용대출 등 기업간거래(B2B) 분야 핀테크 역량도 강화한다. 미래먹거리 ‘제페토’, 매출 70% 늘어메타버스 플랫폼 ‘제페토’ 관련, “전 세계 이용자가 2억명에 달하는 제페토는 최근 삼성전자, 현대차, 구찌, 디올 등의 광고 확대로 매출이 전년 대비 70% 이상 성장했다”면서 “이용자가 직접 아바타 아이템을 만들 수 있는 ‘제페토 스튜디오’에서 게임까지 제작할 수 있는 기능을 연내 출시할 계획”이라고 밝혔다. 3. “야놀자가 우리몫 다 뺏는다” 모텔 사장님들 뿔났다“야놀자가 우리몫 다 뺏는다” 모텔 사장님들 뿔났다 여행 플랫폼 ‘야놀자’의 광고 수수료 체계가 ‘지역 톱’ ‘지역 인기’ ‘지역 리스트’ 등 성격이 겹치는 카테고리를 여러 개 만들어 각각 광고료를 책정하는 정책 때문에 숙박업주들에게 과도한 부담을 지우고 있다는 불만이 커지고 있다. 22일 헤럴드경제 취재를 종합하면, 숙박업소 단체 대한숙박업중앙회의 일부 지회는 야놀자의 광고 및 수수료 체계의 불공정함을 지적하기 위한 단체 행동을 준비하고 있고 일부 업주는 공정거래위원회 국민신문고에 민원을 접수하고 야놀자 측 소명을 기다리고 있는 상황이다. 4. “콘텐츠 대전 시작됐다”…네이버 vs 카카오, 주도권 싸움 치열“콘텐츠 대전 시작됐다”…네이버 vs 카카오, 주도권 싸움 치열 네이버는 왓패드 웹툰 스튜디오를 앞세워 글로벌 창작자 약 570만명이 만든 10억개 이상의 원천 콘텐츠를 바탕으로 드라마·영화·애니메이션 등 다양한 영상화 프로젝트를 선보인다는 구상으로 특히 1000억원 규모의 펀드를 조성하고 남미·유럽·동남아시아 등 글로벌 영상화 사업에서 두각을 나타낼 방침이다. 다음웹툰컴퍼니도 8월부터 ‘카카오웹툰 스튜디오’로 거듭나며, 기존 다음웹툰은 물론 ‘이태원 클라쓰’ ‘나 혼자만 레벨업’ ‘사내맞선’ ‘나빌레라’ ‘승리호’ ‘경이로운 소문’ ‘취향저격 그녀’ 등 카카오페이지의 콘텐츠 IP도 통합해 제공한다. 5. 저커버그 “메타버스는 모바일 인터넷의 진정한 후계자”저커버그 “메타버스는 모바일 인터넷의 진정한 후계자” 마크 저커버그는 22일(현지시각) 미 IT 전문매체인 더버지와 인터뷰를 갖고 “메타버스는 매우 거대한 주제”라며 “메타버스는 모바일 인터넷의 후계자”라고 했으며, “많은 사람들이 메타버스를 단순히 게임의 한 부분이 될 것이라고 생각하지만, 그것을 뛰어넘을 것”이라며 “나는 메타버스가 기술 산업의 다음 장을 여는 큰 부분이 될 것이라고 본다”고 했다. 저커버그가 생각하는 메타버스는 현재 테크 기업들이 내놓은 메타버스 플랫폼과는 다른 형태로 현재 게임 로블록스나 네이버의 제페토 등 메타버스를 기반으로 한 플랫폼이 존재하지만 그는 “메타버스는 공공장소 같은 온라인 공간이 돼야 한다”며 “사람들이 공동으로 상호작용하는 모든 것이 메타버스여야 한다. 각 회사마다의 자체 메타버스는 없어야 한다”고 주장했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-23-IT_News/"},{"title":"2021년 07월 30일 금요일 IT뉴스","text":"1. 30일부터 핀테크 기업 선불충전금 정보 등 개방30일부터 핀테크 기업 선불충전금 정보 등 개방 금융위원회, 금융결제원, 핀테크산업협회은 30일부터 주요 은행, 우체국 앱에서도 본인이 보유한 핀테크 기업의 선불충전금 목록, 거래내역 등을 확인할 수 있게 된다고 28일 밝혔다. 금융위는 23개 핀테크 기업(토스, 네이버페이, 카카오페이 등)의 선불충전금 정보가 우선 조회 가능하며 나머지 회사의 선불충전금 정보도 8월말까지 순차적으로 제공될 예정이라고 설명했다. 이에 맞추어 기존에 금융회사만 이용 가능했던 어카운트인포 서비스도 핀테크 기업이 이용할 수 있도록 개방되며,. 핀테크 기업의 고객들도 오픈뱅킹에 계좌 등록 시 일일이 계좌를 입력할 필요 없이 전 금융회사의 본인계좌를 자동 조회 및 일괄 등록이 가능해진다. 2. 핀다, 새로운 CI·UX 도입…”기존 금융권과 차별화”핀다, 새로운 CI·UX 도입…”기존 금융권과 차별화” 핀다의 기업 CI는 곡선, 볼드, 심플 세 가지 키워드로 정리되며 곡선 디자인은 전통 금융에 대한 허들을 낮춰 접근이 쉬운 핀테크의 부드러움을 내포하며, 볼드 디자인은 핀테크 기업으로서 믿을 수 있는 전문가의 이미지를 담았고, 심플함은 직관적이고 간편한 핀다 서비스의 본질을 반영했다. 사용자와의 지속적인 소통을 위한 UX도 새롭게 선보였으며, UX는 크게 메인 화면, 알림 탭, 더보기로 구성되고 메인 화면에는 핀다의 주요 서비스인 비교대출과 대출관리 서비스가 함께 담겨 가장 좋은 대출 한 번에 받기, 나를 위한 대출관리 등으로 리뉴얼됐다. 3. 초대규모AI가 상품평 한 줄 요약… 네이버, ‘Ai리뷰 요약’ 선봬초대규모AI가 상품평 한 줄 요약… 네이버, ‘Ai리뷰 요약’ 선봬 네이버는 스마트스토어 내 상품 리뷰를 분석해 대표적인 제품 특성을 한 줄의 문장으로 추출하는 ‘Ai리뷰 요약’ 기능을 선보인다고 30일 밝혔으며, ‘Ai리뷰 요약’은 국내 최초 초대규모(Hyperscale) 인공지능(AI) ‘하이퍼클로바’ 기반으로 제공된다. 그동안 국내외 쇼핑서비스가 상품 리뷰에 필터를 적용하거나 일부를 선별해 상단에 보여주는 데 그친 것과 달리 ‘하이퍼클로바’가 방대한 리뷰를 분석해 하나의 자연스러운 문장으로 만들어 낸다. 이로써 사용자가 여러 리뷰를 읽지 않아도 실구매자들의 상품평가를 한눈에 파악할 수 있다는 설명이다. 4. 도토리 충전은 다날로… 싸이월드와 전략적 제휴·투자 계약도토리 충전은 다날로… 싸이월드와 전략적 제휴·투자 계약 다날은 싸이월드제트에 재무적 투자자(FI))로 참여하면서 싸이월드 내 결제수단인 ‘도토리’ 결제·충전 등 전자결제 대행을 맡게 되고 이에 따라 결제 시스템 구축에 들어갔으며 앞으로 결제 관련 기술지원을 제공할 예정이다. 최근 다날이 투자한 배달대행 플랫폼 기업 만나코퍼레이션과 싸이월드제트 간 협업도 논의하며, 메타버스 싸이월드에서 주문한 상품을 실제 오프라인에서 받아볼 수 있도록 배송 서비스를 지원하는 방안 등을 검토할 계획이고 이밖에 싸이월드 BGM(배경음악)서비스에도 다날의 자회사 다날엔터테인먼트가 보유한 10만여곡의 저작권이 도움이 될 전망이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-30-IT_News/"},{"title":"2021년 08월 06일 금요일 IT뉴스","text":"1. 네거티브 규제·자유로운 고용…美 실리콘밸리는 ‘韓과 정반대’네거티브 규제·자유로운 고용…美 실리콘밸리는 ‘韓과 정반대’ 실리콘밸리의 가장 큰 장점은 스타트업 친화적 규제 환경으로 대표적인 게 근로시간이다. 미국 캘리포니아주 노동법은 ‘면제 근로자(exempt employee)’ 제도를 운영하고 있으며 핵심 내용은 주요 부서장과 최저임금의 두 배 이상을 받는 근로자 등 화이트칼라 직장인은 시간 규제를 하지 않는 것이다. ‘떠오르는 스타트업 대국’ 중국은 정부가 스타트업 육성을 주도하고 있다. 2015년부터 추진한 창업생태계 구축전략 ‘대중창업, 만중혁신’이 근간으로 데이터 접근, 세제 혜택, 시험특구 지정, 연구비 지원 등의 규모와 정도가 강력하고 일관되다는 게 특징이다. 2. [LGU+컨콜] 디즈니플러스 한국 출시 임박…“협상 긍정적”[LGU+컨콜] 디즈니플러스 한국 출시 임박…“협상 긍정적” 디즈니가 국내 인터넷TV(IPTV) 등에 콘텐츠 공급 중단을 본격화하면서 한국시장 진입에 속도를 내는 만큼, 누가 디즈니플러스 카드를 가져갈 수 있을지 이목이 집중되었는데, LG유플러스가 긍정적 협상을 진행하고 있다고 밝혔다. LG유플러스 안드로이드 IPTV 셋톱박스 비중은 97%에 달한다. 이는 디즈니가 요구하는 고객 편의성 측면에 부합한다는 설명이고, 또, LG유플러스는 넷플릭스‧HBO 등 해외 콘텐츠 기업과 협업한 바 있다. 3. ‘유니콘’ 앞둔 당근마켓, 중고나라와 달랐던 건‘유니콘’ 앞둔 당근마켓, 중고나라와 달랐던 건 중고거래 플랫폼 ‘당근마켓’이 대규모 투자를 유치했고 이 과정에서 기업가치를 3조원으로 인정받았다. 투자은행(IB) 업계에 따르면 당근마켓은 시리즈D 라운드에서 1800억원을 조달하게 된다. 2003년 국내 처음으로 온라인 중고마켓을 열었던 ‘중고나라’는 지난 3월 한 사모펀드 컨소시엄에 팔리면서 기업가치가 1210억원 남짓으로 드러났다. 투자자들이 당근마켓으로 몰리는 덴 이유로는 “중고나라가 지금까지 해온 전자상거래에 집중한다면, 당근마켓은 지역 커뮤니티를 바탕으로 새로운 가치를 창출하려고 한단 점에서 다르다고 봤다”고 말했다. 예를 들어 급하게 아이를 돌봐줄 사람이 필요할 때 당근마켓의 동네 커뮤니티에서 사람을 찾을 수 있단 것이다. 4. KT엠모바일 알뜰폰, 네이버 인증서 도입…비대면 서비스 강화KT엠모바일 알뜰폰, 네이버 인증서 도입…비대면 서비스 강화 KT엠모바일은 소비자 만족도를 높이고 비대면 온라인 개통 서비스 경쟁력을 강화하고자 올해부터 ‘네이버 인증서’ 도입을 추진했다. 이번 서비스는 지난 6월 과학기술정보통신부로부터 정보통신기술(ICT) 규제 샌드박스 ‘비대면 이동통신 가입 서비스에 대한 임시 허가’ 승인을 거쳐 출시됐다. 특히 이번 신규 인증 서비스 적용으로 신용카드 발급이 어려웠던 학생, 군인 등 신규 가입자들의 불편을 해소할 수 있을 전망이다. 기존 신용카드를 소유하고 있지 않은 고객들은 범용 공인인증서를 유료 발급받거나 본인 인증을 위한 ARS 확인을 대기해야 하는 등 복잡한 절차를 거쳐야 했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-06-IT_News/"},{"title":"2021년 08월 04일 수요일 IT뉴스","text":"1. 삼성도 ‘K-메타버스 연합군’ 합류했다…업계 “큰 도움 될 것”삼성도 ‘K-메타버스 연합군’ 합류했다…업계 “큰 도움 될 것” 삼성전자는 메타버스의 주요 구성 요소인 가상현실(VR)·증강현실(AR)·인공지능(AI) 등 기술 역량을 두루 갖추고 있으며, “업종·기업 간 ‘초협력’으로 혁신적인 메타버스 플랫폼을 만들자”는 취지로 결성된 메타버스 얼라이언스에 삼성전자가 합류했다. 삼성전자가 얼라이언스에 참여한 것은 메타버스 산업의 성장세가 빨라 삼성도 준비가 필요하다는 판단에 따른 것으로 알려졌으며, 메타버스 산업엔 페이스북, 애플, 구글 등 글로벌 기업도 참전해 있는 상태다. 다만 삼성전자는 회사 자체적으로 메타버스 사업을 본격화하는지 여부에 대해서는 “다각도로 연구하는 단계일 뿐”이라고 했다. 2. [팩플] “노른자위 자리 꿰찼다”…카톡, 카카오뷰(View) 출시[팩플] “노른자위 자리 꿰찼다”…카톡, 카카오뷰(View) 출시 카카오톡의 신규 서비스 ‘카카오뷰(View)’가 3일 출시됐다. 카톡 하단 메뉴 한가운데 위치하던 샵(#)탭 자리를 새로운 콘텐트 큐레이션 서비스인 뷰(view)가 대체하는 것. 2018년 출시한 #탭은 뉴스 편집권 등 논란에 휩싸이며 수차례 개편 논의가 있었고, 2019년 10월 카톡 샵탭의 실검 폐지를 선언한 조수용 대표는 당시 “언론사를 구독하는 방식이 아닌 세상에 제공된 다양한 콘텐트를 개인이 재구성하도록 할 것”이라고 밝혔다. 카카오뷰는 브런치·카카오TV·티스토리 등 카카오 서비스를 모아 보는 플랫폼이 생긴 셈으로 카톡 트래픽이 각종 카카오 서비스로 연결되는 시너지 효과가 생긴다. 그리고 외부 페이지로 연결 되는 아웃링크를 허용해 창작자 입장에선 큰 품 들지 않고 새로운 콘텐트 유통 채널로 활용하기 쉽다. 3. 구글, 자체 칩 탑재한 픽셀6 공개…”칩 제작만 4년, 우리가 상상했던 스마트폰”구글, 자체 칩 탑재한 픽셀6 공개…”칩 제작만 4년, 우리가 상상했던 스마트폰” 세계 최대 검색엔진 기업인 구글이 10월 선보일 차기 스마트폰 픽셀6 시리즈에 자체 제작한 ‘프로세서 칩’을 탑재한다. 구글의 AI 기술 역량을 이번 모바일 텐서칩에 녹여냈다는 게 외신의 평가다. 한편 구글이 자사 스마트폰에 투입해온 퀄컴의 칩을 버리고 프로세서 칩을 자체 제작했다고 밝히면서 이날 퀄컴 주가는 소폭 하락했지만, 칩에 대한 구글의 ‘홀로서기’까지엔 시간이 더 필요할 전망으로 SoC를 구성하는 여러 요소 중 AI 기능을 돕는 모바일 TPU는 구글이 설계했지만, 나머지 핵심 장치인 중앙처리장치(CPU), 그래픽처리장치(GPU) 등은 아직까지 자체 설계 기술을 확보하지 못한 것으로 알려졌다. 4. LGU+, 가상세계서 AOMG 비대면 콘서트 개최LGU+, 가상세계서 AOMG 비대면 콘서트 개최 LG유플러스(대표 황현식)는 힙합 레이블 ‘AOMG(대표 박재범)’와 비대면 ‘확장현실(XR) 콘서트’를 선보인다고 4일 밝혔다. 통신사와 힙합 레이블이 협업하는 증강현실(AR) 온라인 공연은 국내 처음으로, 이번 콘서트에서 관람객은 AOMG 소속 아티스트 ‘사이먼 도미닉’ 등이 마치 영화 속 한 장면처럼 가상세계를 오가는 듯 펼치는 초실감형 공연을 감상할 수 있게 된다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-04-IT_News/"},{"title":"2021년 08월 02일 월요일 IT뉴스","text":"1. “코로나 후 데이터 유출피해 사상 최고액”“코로나 후 데이터 유출피해 사상 최고액” 2일 IBM이 지난해 5월부터 올해 3월까지 세계 500여개 기업·조직을 대상으로 한 조사에 따르면 데이터 유출 사고 평균 피해액은 지난 조사보다 약 10% 증가한 평균 424만달러(약 48억8000만원)였다. 이 가운데 국내 기업 28곳의 피해액은 평균 41억1000만원으로 집계됐고, 한국에서 가장 큰 피해를 본 업종은 금융업이었고, 서비스와 정보통신(IT) 분야가 뒤를 이었다. 그리고 사용자 인증 정보를 도용한 공격 방식이 가장 많았으며 클라우드 구성 오류나 피싱 등도 있었으며, 피해액이 가장 컸던 공격법은 비즈니스 이메일 유출로, 평균 피해액이 67억6000만원에 달했다. 2. 네이버, 올 1~7월 AI 논문 51개 채택…매년 기록 경신네이버, 올 1~7월 AI 논문 51개 채택…매년 기록 경신 네이버는 세계적인 인공지능(AI) 학회에서 올 들어 7월까지 총 51건의 정규 논문이 채택됐다고 2일 밝혔으며, 이중 상반기에만 43건의 논문이 등재돼 작년 한 해 논문 발표 기록 43편을 반 년만에 따라잡았다. 네이버는 또 학회에 채택된 논문 중 40% 이상은 네이버의 실제 서비스에 다양하게 적용돼, 사용자 경험을 높이는데도 크게 기여했다고 전했고, 특히 음성 분야의 최고 학회인 ICASSP와 Interspeech에서는 각각 9개의 논문이 채택되는 성과와 가장 최근에는 최고 권위의 컴퓨터비전 학회인 ICCV에서 8개의 논문의 발표가 확정돼, 비전 분야에서 기술력을 인정받기도 했다. 3. 토스 ‘송금 수수료’, 오늘부터 완전 무료토스 ‘송금 수수료’, 오늘부터 완전 무료 기존에는 토스도 월 10회에 한해서만 수수료를 무료로 지원해왔으나, 오는 9월 토스뱅크 출범을 앞두고 차별화된 경쟁력을 확보하기 위해 모든 고객에게 송금 수수료 ‘평생무료’ 혜택을 부여하는 결정을 내렸다. 토스는 송금·결제·투자·보험 등 고객이 필요로 하는 모든 금융 경험을 토스 앱 하나로 제공한다는 이른바 ‘금융의 슈퍼앱(Super App)’ 비전을 제시해오고 있다. 한편 간편송금 시장 규모는 매년 급증하고 있으며 한국은행에 따르면 지난해 간편송금 서비스 이용액이 일 평균 3565억원(연 환산 약130조)으로, 이 가운데 92%가 토스와 같은 전자금융업자를 통해 이뤄지고 있다. 4. 카카오 이어 네이버쇼핑도…‘대세는 구독’카카오 이어 네이버쇼핑도…‘대세는 구독’ 지난 7월 30일 네이버는 8월부터 스마트스토어에 입점한 생필품·식품·키즈·뷰티·디지털·건강·꽃배달 상품을 대상으로 정기구독 서비스를 지원한다고 밝혔고, 스마트스토어 판매자들에게 △사전 고객 알림 △자동결제 △배송주기 설정 기능을 활용할 수 있는 시스템을 제공하는 것이 골자다. 앞서 카카오도 구독시장에 진출했다. 월 4900원에 카카오톡 이모티콘을 무제한 사용하는 ‘이모티콘 플러스’, 클라우드 서비스인 ‘톡서랍 서비스’ 등도 운영 중이며, 지난달에는 다양한 상품·서비스 등을 정기구독할 수 있는 플랫폼 ‘구독 온(ON)’을 정식으로 내놨다. 이들이 구독경제 시장을 넘보는 이유는 성장성 때문으로 정기적으로 제품·서비스를 결제하기 때문에 ‘캐시카우’으로 삼을 수 있고, 사용자를 붙잡아 두는 ‘록인(Lock-in·묶어두기)효과’도 노릴 수 있다. 시장 전망도 밝다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-02-IT_News/"},{"title":"2021년 07월 26일 월요일 IT뉴스","text":"1. 바람소리까지 차단 vs10만원대로 ‘가성비’ 충족‘…노이즈 캔슬링’ 경쟁 속으로바람소리까지 차단 vs10만원대로 ‘가성비’ 충족‘…노이즈 캔슬링’ 경쟁 속으로 올해 새로 출시되는 무선이어폰들도 노이즈캔슬링 기능이 큰 관심사다. 소니는 지난달 ‘헤드폰급’ 노이즈캔슬링 성능을 자부한 신제품 ‘WF-1000XM4’를 내놨으며, 는 바람 소리를 억제하는 기능을 추가해 야외에서도 노이즈캔슬링 효과가 커졌다고 강조했다. 삼성전자는 내달 11일 온라인 언팩(신제품 공개) 행사에서 무선이어폰 ‘갤럭시 버즈2’를 공개할 예정인데, 노이즈캔슬링 기능을 넣고도 가격을 10만원대 후반으로 책정해 가성비를 높일 것이란 관측이 나오고 있다. 애플은 오는 9월 선보일 것으로 예상되는 무선이어폰 ‘에어팟3’에서 외려 노이즈캔슬링을 빼고, 10만원대 후반으로 가격을 낮출 것이란 외신 보도가 나오고 있다. 2. 새벽 1시, 자는데 SNS ‘로그인’ 문자가…새벽 1시, 자는데 SNS ‘로그인’ 문자가… 2단계 인증의 중요성에 대해, 화이트 해커(정보 보안 전문가)이자 유튜버인 **노말틱(Normaltic)**은 이렇게 설명했다. 그는 **”해커 입장에서 2단계 인증을 만나게 되면 진짜 심각하게 짜증난다”**며 **”비밀번호는 바꾸기 전까진 고정된 정보이지만, 2단계 인증 정보는 로그인 할 때마다 바뀌는 값이기 때문”**이라고 했다. 그러면서 노말틱은 **”그 2단계 인증 시스템을 해킹하지 않는 이상 계정을 해킹하기 어렵다”**며 **”그만큼 강력한 것”**이라고 했다. 특히 이메일 계정만큼은 1순위로 2단계 인증을 해야 한다고 했다. 초기화 된 비밀번호가 다 이메일 계정으로 가기 때문에, 거의 모든 계정을 해킹할 수 있어서다. 3. 토스·쿠팡·배민 등 플랫폼업체 개인정보·상담내용 유출토스·쿠팡·배민 등 플랫폼업체 개인정보·상담내용 유출 25일 채팅 상담 해피톡 운영사 엠비아이솔루션에 따르면 21일 오후 2시 해커가 자사 서버에 침입해 개인정보를 비롯한 채팅 상담 데이터를 유출시켰다고 밝혔으며, 토스(비바리퍼블리카), 쿠팡, 배달의민족 등 대형 플랫폼의 고객 이름, 전화번호 등 개인정보와 함께 상담내용까지 총 8만여건이 유출된 것으로 파악됐으며, 정보유출 피해를 입은 고객사는 700여개에 달한다. 해피톡은 해당 고객사에게 피해사실을 공지하고, 보상 및 향후 대응에 대해 협의를 진행 중이고, 토스의 경우 고객 1500여명의 개인정보가 유출되어 피해자 한 명당 10만원의 보상금을 선제적으로 지급하는 등 조기 진압에 나섰다. 배달의민족도 음식점 점주와 커넥터(라이더)가 회사 측과 주고받은 상담 내역 1만312건이 유출됐다. 4. 택시·대리·퀵 이어 렌터카…’카카오T’ 플랫폼 마지막 퍼즐 끼웠다택시·대리·퀵 이어 렌터카…’카카오T’ 플랫폼 마지막 퍼즐 끼웠다 26일 IT업계에 따르면 공정위는 모빌리티 플랫폼 카카오T 운영사인 카카오모빌리티가 현대캐피탈의 온라인 차량대여 플랫폼 사업 딜카를 양수하는 기업결합 건을 경쟁제한 우려가 적다고 판단해 지난 8일 승인했다. 카카오모빌리티의 렌터카 업계 경쟁사로는 쏘카나 그린카 등 카셰어링 기업들이 거론되고 있지만, 실제 사업모델은 큰 차이가 있을 가능성이 크며, 카셰어링 기업의 경우 회사가 보유한 차량을 빌려주는 방식이지만, 카카오는 대리운전이나 택시, 퀵서비스처럼 ‘연결’에 중점을 둔 서비스를 제공할 것으로 예상된다. 실제 카카오모빌리티는 피유엠피, 지바이크 등과 업무협약을 맺고 퍼스널 모빌리티 서비스 연동을 추진 중이다. 5. 음성기반 일대일 커리어 대화 연결 플랫폼 ‘커피챗’, 중기부 팁스 프로그램 선정음성기반 일대일 커리어 대화 연결 플랫폼 ‘커피챗’, 중기부 팁스 프로그램 선정 음성 기반 커리어 대화 연결 플랫폼 커피챗은 중소벤처기업부의 기술창업투자 프로그램인 팁스(TIPS)에 선정됐고, 올해 5월 본엔젤스벤처파트너스에서 시드 투자를 받은 후 이번 7월 팁스 프로그램에 추천을 받고 최종 선정됐다. 커피챗은 내가 궁금한 곳에 있는 사람과 일대일 익명 기반 자유로운 음성 대화를 제공하는 커리어 대화 연결 플랫폼으로 개개인의 커리어에 적합한 파트너와 음성 대화가 가능하도록 회사/직무/업계/학교별 파트너 검색 기능과 실시간 파트너 업데이트를 제공하고 있으며, 커피챗 실시간 리뷰, 맞춤 파트너 추천받기 등으로 서비스를 처음 이용하는 고객의 편의를 위한 서비스를 선보이고 있다. 박상우 커피챗 대표는 “고객마다 각기 다른 커리어 생애 주기에 맞게 최적화된 정보를 얻을 수 있도록 정교한 AI 알고리즘 구축과 지속적 모델링 고도화를 추진할 예정”이라고 밝혔다. 또한, “다양한 국가의 고객들이 커피챗을 통해 커리어와 관련된 모든 고민을 해결할 수 있는 올인원 커리어 플랫폼으로 나아가는 것이 목표” 라고 전했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-07-26-IT_News/"},{"title":"2021년 08월 09일 월요일 IT뉴스","text":"1. [단독] 네이버, 카페24 최대주주 된다…지분 20% 인수 계약[단독] 네이버, 카페24 최대주주 된다…지분 20% 인수 계약 1999년 설립된 카페24는 쇼핑몰 개설, 광고·마케팅, 결제, 물류 등 다양한 서비스를 제공하며, 개인과 법인 등 고객 190만 명을 보유하고 있다. 솔루션업계 경쟁사인 네이버, 쿠팡, NHN 등을 모두 넘어서는 국내 최대 규모다. 네이버는 2014년부터 카페24의 경쟁 플랫폼이라고 할 수 있는 스마트스토어를 운영해왔고 두 플랫폼이 협력하게 되면 상호 고객 데이터를 교환해 서비스 고도화를 노릴 수 있을것이며, 카페24의 이용 고객을 스마트스토어에 그대로 연동해 더 많은 판매자를 확보할 수도 있다. 카페24 이용자는 190만 명이고, 스마트스토어는 45만 명이다. 네이버가 카페24가 절실했던 가장 큰 이유는 글로벌 진출로 일본에선 라인, 야후 등 네이버 계열사의 쇼핑 플랫폼에서 전자상거래를 시작할 계획이고, 스페인에선 올해 초 약 1500억원을 투자한 왈라팝을 전자상거래 플랫폼으로 확대할 방침이다. 2. 무료로 이용자 모으더니…카카오, 플랫폼 ‘유료 본색’ 드러냈다무료로 이용자 모으더니…카카오, 플랫폼 ‘유료 본색’ 드러냈다 카카오모빌리티가 택시 스마트호출료에 이어 전기자전거 요금 인상을 추진한다. 카카오측은 전기자전거 요금제 변경이 단거리 고객 수요에 맞춘 결정이라는 입장이지만, 일각에선 카카오가 플랫폼 장악력을 악용해 도미노식 가격 올리기에 나섰다는 비판을 제기한다. 카카오모빌리티가 기업공개(IPO)를 앞두고 무리하게 수익화에 나선 것으로 보는 시각도 있으며, 명확한 수익모델을 증명하고자 일정을 서두르고 있다는 것. 업계 관계자는 “택시, 전기자전거 외에 다른 모빌리티 서비스들도 유료화될 가능성이 크다”고 말했다. 3. 인공지능 장착 ‘의식주 스타트업’ 급증인공지능 장착 ‘의식주 스타트업’ 급증 AI가 빠른 속도로 발전하는 가운데, 코로나19 사태가 일상을 ‘언택트’로 바꿔놓고 디지털 기술에 익숙한 MZ세대(밀레니얼·Z세대, 1980~2000년대 초 출생)가 소비 주체로 급부상하면서 이른바 ‘라이프 테크’ 스타트업이 업계 게임체인저로 전면에 나서는 양상이다. 패션은 그동안 주관적인 개인 취향이 중요한 데다 AI가 패션업계 특유의 변화무쌍한 사진·이미지 데이터를 다루는 게 쉽지 않아서 오프라인 힘이 셌기 때문에 AI와 거리가 먼 분야로 꼽혔다. 하지만 AI와 클라우드가 더 많은 데이터를 축적·분석하면서 패션 분야에서는 머리부터 발끝까지 모든 것에 첨단기술이 동원되고 있기 때문에 이를 하나둘씩 극복해내면서 되레 전통 패션회사의 구원투수로 등장할 태세다. 4. NH농협은행 ‘올원뱅크’서 꽃 배달하고 고기 산다NH농협은행 ‘올원뱅크’서 꽃 배달하고 고기 산다 NH농협은행은 올원뱅크에서 ‘올원플라워’ ‘NH농협은행 실명인증’ ‘농협 LYVLY(라이블리)’ 등 다양한 특화 서비스를 새롭게 선보인다고 8일 밝혔다. 올원플라워는 한국화훼농협의 꽃다발, 화환, 난 등 화훼 상품을 올원뱅크에 등록된 농협계좌와 카드로 간편하게 결제할 수 있는 서비스다. 농협은행 실명인증은 금융위원회 혁신금융서비스로 지정된 ‘마이아이디(MyID)’와 연계해 비대면 실명확인 절차를 간소화한 특화 서비스다. 농협 라이블리는 농협이 직접 만든 PB브랜드로, 상품 기획부터 생산 관리까지 직접 진행하는 축산 전문 온라인 쇼핑몰이다. 5. B2C를 넘어서…쿠팡, B2B 이커머스·배달앱 본격 가동B2C를 넘어서…쿠팡, B2B 이커머스·배달앱 본격 가동 쿠팡은 최근 쿠팡비즈 회원에 관한 내용을 새로 추가한 개정 이용약관을 공지했으며, 지난 7월 ‘쿠팡비즈’ 등 사업자 전용 서비스와 관련 있어 보이는 상표들을 출원해 놨다. 쿠팡비즈는 개인 사업자 또는 중소 법인을 대상으로 사무용품과 문구류, 간식류 등을 제공하는 서비스일 것으로 예상되고 있다. 구체적인 내용은 아직 베일 속이나 머지않은 시점에 정식 서비스를 가동할 것으로 점쳐진다. 쿠팡은 지난 4월 음식점 식자재를 납품해주는 ‘쿠팡이츠딜’을 일부 지역에서 시범 운영했고 최근 이를 정식 가동했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-09-IT_News/"},{"title":"2021년 08월 16일 월요일 IT뉴스","text":"1. KAIST, 보건의료 AI 활용 가이드라인 첫 개발KAIST, 보건의료 AI 활용 가이드라인 첫 개발 KAIST 한국4차산업혁명정책센터(KPC4IR)는 싱가포르국립대 리스크공공이해연구소, 영국 과학기술 비영리기관인 센스 어바웃 사이언스와 함께 ‘사회를 위한 보건의료 분야 AI 활용 가이드’를 개발했다고 15일 밝혔다. 이 가이드에는 의료 영상 분석과 빅데이터로 질병 예측, 신약 개발 시간 단축 등 의료 분야의 AI 활용 사례가 담겼으며, AI의 신뢰성을 확보하는 5가지 기준도 담았다. 2. 딥브레인AI, 텐센트 제치고 中 AI 사업 따내딥브레인AI, 텐센트 제치고 中 AI 사업 따내 국내 인공지능(AI) 스타트업 딥브레인AI(옛 머니브레인)가 독자 개발한 ‘AI 아나운서’를 중국 대형 방송사인 베이징방송과 칭하이방송에 공급했다. 텐센트 자회사 소고우와의 치열한 경쟁을 뚫었다 딥브레인AI는 AI 아나운서뿐 아니라 영상 합성으로 제작한 아바타가 사람과 대화할 수 있는 기술도 보유하고 있다. 영상 합성에 음성인식, 자연어 처리 등의 기술까지 결합한 기술로, 이 기술로 만든 AI 은행원, AI 직원 등은 간단한 고객 응대·안내가 가능하고 세븐일레븐 무인편의점에 등장한 AI 직원이 딥브레인AI 작품이다. 3. 페이스북 메신저, 종단 간 암호화 기능 강화페이스북 메신저, 종단 간 암호화 기능 강화 페이스북 메신저의 음성 및 영상 통화에 종단 간 암호화(End-to-End Encrypted) 기능을 강화했다고 밝혔다. 페이스북은 페이스북 메신저에서 하루 1억5000만건 이상의 영상 통화가 이뤄지는 만큼 보안 수준을 한층 상향할 필요가 있었다고 설명했으며, 페이스북이 인수한 왓츠앱의 경우 이미 모든 커뮤니케이션 기능에 종단 간 암호화 기능이 적용돼 있으며, 애플 페이스타임이나 줌, 시그널 등 유사 앱 역시 해당 기능을 적용하고 있다. 4. “올해 국내 IT 인프라 시장, 클라우드 비중 50% 넘어설 것”“올해 국내 IT 인프라 시장, 클라우드 비중 50% 넘어설 것” 올해 클라우드 환경으로 도입되는 IT인프라가 전체 시장에서 차지하는 비중이 50%를 넘어설 것이란 조사 결과가 나왔다. 이번 보고서에 따르면, 최근 국내 기업들은 보다 유연하고 민첩한 비즈니스를 지원하기 위해 전통적인 IT인프라 기반 시스템 환경에서 퍼블릭 및 프라이빗 클라우드 환경으로 전환하는 추세로 복잡해지는 고객 요구사항과 꾸준히 증가하는 컴퓨팅 리소스 및 데이터에 대한 효율적 관리 필요성이 클라우드로의 전환을 가속화시키고 있다는 것이 한국IDC 분석이다. 코로나19 팬데믹 상황이 장기화되는 것도 국내 기업들이 디지털화에 속도를 내도록 하는 요인으로 클라우드로의 전환에 보수적이었던 금융권에서는 프라이빗 클라우드 뿐만 아니라 퍼블릭 클라우드에 대한 관심도 높아지고 있으며, 정부 클라우드 장려 정책도 국내 생태계를 강하게 만들고 있다고 한국IDC는 전했다. 5. “인공지능 발명가 인정하라” 역사적 특허청원 결실“인공지능 발명가 인정하라” 역사적 특허청원 결실 스스로 발명을 할 수 있는 인공지능(AI)을 개발해 전 세계 특허청을 상대로 AI를 발명가로 등록시키려고 하는 AI 다부스를 개발한 스티븐 세일러 이매지네이션엔진스 대표는 지난달 남아프리카공화국이 AI에 특허를 부여했고 이달 호주 연방법원이 “AI도 발명가 자격이 있다”고 발표했다. 상당수 국가의 법률상 발명자 지위는 자연인인 사람만 누릴 수 있으며, 한국 특허청도 올해 6월 다부스의 특허출원 심사에서 ‘자연인으로 발명자를 수정하라’는 보정 요구서를 보냈다. 세일러 대표는 인공지능의 미래에 대해 “인공지능이 발명에 개입하면서 사람 역할이 줄어들고 우리 사회는 중대한 영향을 받을 것”이라고 내다봤으며 그는 “다부스는 사람의 마음이 어떻게 작동하는지 잘 보여준다”면서 “다부스는 특허 이슈를 떠나 철학적인 논쟁을 불러일으키고 있다”고 말했고 세일러 대표는 “코페르니쿠스의 지동설이 신학에서 과학으로 전환하는 것을 의미했듯이, 인공지능이 발명을 시작하는 것을 계기로 마음에 대한 개념도 궁극적으로 바뀔 것”이라고 말했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-16-IT_News/"},{"title":"2021년 08월 11일 수요일 IT뉴스","text":"1. [스타트업] 쿠팡 상장후 韓 스타트업에 해외투자자 러브콜 쏟아져[스타트업] 쿠팡 상장후 韓 스타트업에 해외투자자 러브콜 쏟아져 “쿠팡과 마켓컬리 효과로 한국 스타트업에 해외 자본의 투자가 쏟아질 겁니다.” 박 대표는 “쿠팡 상장 이후 해외투자자들이 한국 스타트업에 대해 계속 문의해 오고 있다”면서 “한국은 시장이 작고 엑시트(투자 회수)가 어렵다는 의심이 이제 통하지 않는다”고 설명했다. 박 대표는 “이미 한국에 유니콘이 될 수 있는 기업이 많은데도 외국인 투자가 들어오지 못한 것은 실리콘밸리 식 글로벌 스탠더드를 맞추기 못했기 때문”이라면서 “중국·이스라엘이 이런 기준을 맞췄기 때문에 이곳의 스타트업들이 많은 투자를 받을 수 있었다”고 설명했다. 쿠팡과 마켓컬리가 해외 투자를 받을 수 있었던 것도 이런 전 세계 VC 세계의 규칙에 맞게 지배구조와 계약서 등을 만들었기 때문이라는 것이다. 2. 온라인 가격 비교 플랫폼 ‘다나와’도 매각 착수온라인 가격 비교 플랫폼 ‘다나와’도 매각 착수 다나와는 2000년 2월 카메라 가격 비교 사이트로 시작한 플랫폼이으로 컴퓨터, 정보 기기와 관련해 데이터베이스(DB)를 보유하고 있으며 현재는 모든 카테고리를 망라하는 종합 가격 비교 사이트로 성장했다. 다나와는 2011년 1월 코스닥 시장에 상장했다. 지난해 매출(연결 기준)은 2320억원, 영업이익 378억원을 냈고, 다나와 측은 “최대 주주가 보유하고 있는 지분 매각을 포함해 다양한 전략적인 방안을 검토 중”이라며 “이와 관련해 NH투자증권을 자문사로 선정한 후 필요한 사전 절차를 진행하고 있지만 현재까지 구체적으로 결정되거나 확정된 사항은 없다”고 했다. 3. 예스24, 모바일앱서 선물하기 서비스 시작예스24, 모바일앱서 선물하기 서비스 시작 예스24 모바일 앱(APP)에서 상품을 선택하고 ‘선물하기’를 통해 결제하면 상대방 카카오톡 또는 문자로 메시지 카드가 발송되며, 선물을 받은 사람은 휴대전화로 전송된 메시지 내 ‘선물 받기’ 링크를 통해 메시지 카드 확인 및 선물 수령이 가능하다. 최세라 예스24 도서사업본부 상무는 “장기화된 코로나19로 인해 직접 만나 안부를 전하거나 감사, 축하 등 마음을 전하기 어려운 요즘, 언택트 소비 트렌드를 반영해 예스24 모바일 ‘선물하기’ 서비스를 선보이게 됐다”며, “소중한 사람들과의 교류가 어려운 상황인 만큼 조금이라도 따스한 마음을 전하는 데 도움이 되길 바란다”고 말했다. 4. 서울시 25개 전통시장, 당근마켓에서 만난다서울시 25개 전통시장, 당근마켓에서 만난다 국내 대표 지역생활 커뮤니티 당근마켓이 서울시 전통시장 활성화를 위해 서울신용보증재단과 손을 잡았으며, 이번 협약의 핵심은 당근마켓을 통해 서울시 내 25개 전통 시장의 500여 개 상점을 각 시장 인근에 거주하는 주민들과 연결해, 전통시장의 온라인 진출과 경쟁력 강화를 도모하는 것이다. 그 첫 시작으로 당근마켓은 9월 중 현재 서울 시내 약 150곳에 운영 중인 당근마켓 내 근처 ‘동네 장보기’ 테마관을 서울 전 지역으로 확대하고, 전통시장 상인들의 비즈프로필을 연결해 전통시장 상품과 소식을 제공할 계획이다. 전화문의는 물론 채팅, 댓글을 통해 고객들과 친밀감을 쌓으며 단골을 확보할 수 있어, 매출 견인에 실질적인 도움이 될 것으로 기대를 모으고 있다. 5. 자동차 업계, 금융업에 ‘러브콜’…핵심은 데이터자동차 업계, 금융업에 ‘러브콜’…핵심은 데이터 기아는 핀테크 ‘뱅크샐러드’에 100억원을 투자하겠다는 방침을 발표했으며 구체적인 계획은 밝히지 않았지만 핵심은 ‘데이터’로 기아와 뱅크샐러드는 차량에서 얻는 데이터와 차량 안에서 고객이 쓰는 자산관리 데이터를 잇는 오픈 플랫폼 구축하고, 모빌리티 산업을 위한 광범위한 데이터 기술 협력을 꾀한다는 계획이다. 기아 관계자는 “자동차 제조업체가 단순히 자동차만 만드는 것에서 미래 모빌리티 등 다양한 탈 것들에 대해 관심을 갖고 있다”며 “고객 취향을 알 수 있는 데이터를 얻기 위해 이번 투자를 단행했으며, 캐롯손해보험처럼 자동차와 금융이 관련된 부분을 고려하고 있다”고 설명했다. 금융이 자동차를 구매하는 시점 혹은 빌리는 시점부터 폐차를 하는 순간까지 밀접하게 연관된 업종으로 금융과 자동차산업 간 시너지를 낼 수 있는 강력한 무기는 데이터이다. 고객에게 신차를 추천할 경우 이들의 예산은 얼마인지 혹은 얼마나 과거 차를 운행해왔는지 등을 파악한다면 성공으로 이어질 가능성도 높아진다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-11-IT_News/"},{"title":"2021년 08월 18일 수요일 IT뉴스","text":"1. “당근하세요?”…50만→1500만명 폭발적 성장“당근하세요?”…50만→1500만명 폭발적 성장 당근마켓이 1800억원 규모의 투자 유치를 마무리하며 유니콘기업 (기업가치 1조원 이상의 비상장 기업) 반열에 올랐으며, 누적 투자액수는 2270억원으로, 투자 유치 과정에서 기업가치 3조원을 인정받았다. 당근마켓은 신규 투자 자금을 기반으로 하이퍼로컬 혁신을 가속화한다는 방침이며, 지속적인 기술 고도화와 함께 사업 확장을 위한 인력 채용, 해외 시장 진출 확대, 국내외 마케팅 강화 등에 집중하며 로컬 슈퍼앱으로서의 비전을 완성해 나갈 계획이다. 그 일환으로 올 하반기 당근페이와 함께 지역 커머스 강화에 본격 나서고 있으며, 농수산물, 신선식품 등 지역 상권과 주민들을 더욱 긴밀하게 연결하는 온-오프라인 연계 비즈니스 활성화에 힘을 쏟을 예정이다. 2. 네이버 “예스24 인수, 완전 사실무근”…예스24 주가는 급등네이버 “예스24 인수, 완전 사실무근”…예스24 주가는 급등 네이버(035420)가 온라인 문화상품 유통 플랫폼 및 인터넷 서점 사업을 하는 ‘예스24’ 인수 추진 보도에 대해 “완전 사실무근”이라고 밝혔다. 해당 소식이 전해진 후 예스24(053280)는 주가가 급등해 이날 오전 11시35분 현재 전 거래일보다 3500원(21.54%) 오른 1만9750원에 거래됐다. 3. [이슈진단+] 사업확장 제동 걸린 카카오T·직방·로톡…”소비자 편익 우선”[이슈진단+] 사업확장 제동 걸린 카카오T·직방·로톡…”소비자 편익 우선” 플랫폼 사업자들은 빠르고 쉬운 서비스로 소비자 편의성이 높아지고 기존 사업자와의 상생도 가능하다는 입장과 기존 사업가 단체들은 플랫폼의 업계 진출이 결국 기존 사업가의 수익 감소로 이어질 것을 우려로 갈등이 심화되고 있다. 로톡은 그간 변호사 광고, 상담 예약, 온라인 상담, AI 형량 예측 등 법률 서비스를 제공해왔지만, 대한변협은 로톡의 법률 서비스가 플랫폼이 변호사의 업무와 역할을 침해한다며, 지난 5월 ‘변호사 광고에 관한 규정’ 개정안을 내놨다. 로톡 측은 “변호사법을 위반한 적이 없고, 오히려 로톡을 통해 이용자들이 손쉽게 변호사를 찾고 상담하기가 쉬워졌다”는 입장이다. 부동산 업계에서는 부동산 플랫폼 **’직방’**의 직접 중개를 두고 한국공인중개사협회가 반발하고 있다. 온택트파트너스란, 직방이 공인중개사와 제휴를 맺고 플랫폼상에서 거래 계약까지 성사하는 제도로 직방이 공인중개사의 수수료 절반을 사용료로 받는것으로 중개사협회는 이를 “직방의 직접 중개”라면서 “광고 플랫폼이었던 직방이 사실상 중개까지 나서는 것은 중개사 생존권을 위협하는 것”이라고 주장했다. 수수료 절반을 직방이 가져가는 온택트파트너스 제도가 중개업자의 수익 감소로 이어질 뿐 아니라, 향후 영세 부동산 업체들이 대형 플랫폼인 직방과 경쟁을 해야할 수도 있다는 우려다. 업계 관계자들과 학계는 산업의 디지털 전환은 시대적 흐름이며, 갈등 과정에서 소비자 편익을 우선적으로 고려해야 한다는 목소리를 내놨다. 한 IT업계 관계자는 “디지털 전환은 시대적인 흐름”이라며 “변화의 흐름을 무조건 거부할 것이 아니라 어떤 부분이 이점이고 어떤 부분은 변화해야 할지 플랫폼과 업계 양측이 논의를 해나가야 한다”고 제언했다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-18-IT_News/"},{"title":"2021년 08월 20일 금요일 IT뉴스","text":"1. 아이폰에 지문 인식 다시 생기나…코로나19가 바꾼 생체인식 시장아이폰에 지문 인식 다시 생기나…코로나19가 바꾼 생체인식 시장 신종 코로나바이러스 감염증(코로나19) 팬데믹(대유행)이 생체인식 시장의 기술 지형을 바꿔놓고 있다. 마스크를 착용한 상태에서 페이스ID가 작동하지 않는 데 따른 불편함을 해소하기 위해서 애플은 다음 달 출시할 새로운 아이폰 모델에 지문인식을 다시 탑재할 것이라는 소문이 파다하다. 개인이 사용하는 스마트폰을 제외한 분야에서는 코로나19로 비접촉식 인증 방식에 대한 수요가 폭증하면서 안면 인식 기술이 생체인식 시장을 점령하고 있다. NEC가 올해 도쿄 올림픽에 공급한 네오페이스 워치는 인공 신경망 모델을 적용해 2차원 얼굴 이미지를 3차원으로 전환해 인식하며, 0.3초 만에 160만 개의 얼굴을 검사할 수 있다. 정확도는 99.7%다. 2. 도미노피자, 주문하면 드론으로 배송한다도미노피자, 주문하면 드론으로 배송한다 국토교통부는 드론업체 피스퀘어와 글로벌 피자 체인 도미노피자와 협업해 세종시에서 21일부터 피자 드론 배송 상용화 서비스를 개시한다고 밝혔으며, 드론배송 상용화 구간은 도미노피자 세종보람점에서 세종호수공원까지로 21일부터 10월 31일까지 토요일과 일요일 오후 1시부터 6시까지 시간당 2~3회로 예상하고 있다.. 그동안 국토부는 드론 산업 육성을 위해 ▲드론 특별자유화구역(33개 구역 지정) ▲드론 규제 샌드박스 사업(13개 업체) ▲드론 실증도시(10개 도시) 지정 등 드론을 활용한 서비스를 개발하고 실증하는데 집중해 왔으며 특히, 국내기술로 개발된 드론의 국제 경쟁력 강화와 신서비스 창출을 위해 제도완화, 자금지원, 수요-공급 매칭 등 체계적인 지원을 하고 있다. 3. [OTT온에어] 디즈니+ 한국 진출…풀어야 할 규제 산적[OTT온에어] 디즈니+ 한국 진출…풀어야 할 규제 산적 디즈니플러스가 올 11월 국내 시장 진출을 본격화함에 따라 관련 업계에서는 현재 국내 OTT 시장 쟁점인 망 사용료, 음악 저작권료 문제를 어떻게 풀어갈지 관심이다. 디즈니는 국내 통신사에 콘텐츠 전송 네트워크(CDN)사업자를 통해 일종의 ‘망 사용료’를 지불하는 것으로 나타났다. CDN은 다양한 데이터를 미리 저장해 놓거나, 전송방식을 효율화해 최적의 경로로 사용자에 콘텐츠를 전달하는 서비스다. 디즈니플러스 콘텐츠에 쓰인 음악은 신탁단체에 신탁하지 않는 업무상 저작물이 대부분인 것이 넷플릭스·국내 OTT와 차이점이다. 그러나 디즈니플러스가 현지화를 위해 조달할 국내 오리지널 콘텐츠에 대해서는 신탁단체를 통한 저작권료 징수가 발생할 것으로 보인다. 디즈니플러스는 지난 4월 미디어 그룹 NEW의 콘텐츠 제작사업 계열사 스튜디오앤뉴와 5년간 장기 콘텐츠 파트너십을 맺었다. 이를 통해 양사는 매년 한편 이상의 오리지널 시리즈와 콘텐츠를 선보이기 위해 협력하기로 했다. 4. SKT 이프랜드, 오픈 메타버스 플랫폼으로… 마켓 시스템∙공간제작 기능 등 적용SKT 이프랜드, 오픈 메타버스 플랫폼으로… 마켓 시스템∙공간제작 기능 등 적용 SK텔레콤이 19일 메타버스 공간에서 기자 간담회를 열고 ‘이프랜드(ifland)’를 통한 메타버스 청사진을 발표했다. 이프랜드는 SKT가 선보이는 메타버스 플랫폼으로 앞으로 마켓 시스템 및 공간제작 플랫폼 등을 적용하고 대학축제·K팝 팬미팅 등 대형 이벤트 등을 통해 코로나19 시대 비대면 트렌드를 주도한다는 계획이다. 5. 7월 한국인이 가장 많이 쓴 금융 앱 삼성페이…자주 쓴 앱 업비트7월 한국인이 가장 많이 쓴 금융 앱 삼성페이…자주 쓴 앱 업비트 삼성전자 모바일 결제 서비스 삼성페이가 한국에서 가장 많이 쓰는 금융앱이라는 조사 결과가 나왔다. 7월에 가장 자주 실행한 금융 앱은 ‘업비트’로 실행횟수가 26.1억회로 조사됐고, 토스 11.3억회, 카카오뱅크 8.8억회, 키움증권 영웅문S 7.8억회, 모바일증권 나무 6.6억회, 삼성페이 5.4억회, 증권통 5.1억회, 신한 쏠 5.0억회 순이었다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-20-IT_News/"},{"title":"2021년 08월 25일 수요일 IT뉴스","text":"1. 10년간 고집한 ‘게임셧다운제’…여가부 돌연 “폐지”10년간 고집한 ‘게임셧다운제’…여가부 돌연 “폐지” 밤 12시부터 오전 6시까지 심야 시간에 청소년의 게임 이용을 차단하는 규제인 ‘강제적 셧다운제’가 10년 만에 폐지 수순을 밟으며, 게임 이용 시간을 직접 설정할 수 있는 ‘게임시간선택제’가 그 자리를 대신한다. 이번 변화를 두고 직접적 당사자인 게임 업계에서는 일단 폐지를 반기면서도 다양한 의견이 나오고 있고, 72개 게임사를 회원으로 둔 한국게임산업협회는 “갈라파고스 규제인 강제적 셧다운제의 폐지 결정을 적극 지지하고 환영하며 관련 법안 개정이 신속하게 이뤄지기를 기대한다”는 입장을 냈다. 한국게임학회장을 맡은 위정현 교수는 “실효성이 없는 법적 규제 자체를 아예 없애고 부모와 학생, 각 가정이 국가에 위임한 스스로의 권한을 찾아와야 한다”고 했다. 2. 토스도 ‘본인확인’서비스…이통사 독무대 깬다토스도 ‘본인확인’서비스…이통사 독무대 깬다 모바일 금융 플랫폼 토스를 운영하는 비바리퍼블리카가 본인확인기관으로 지정됨에 따라 이동통신 3사가 독점하던 본인 확인 시장에 핀테크 기업이 발을 들인 것이며, 토스와 함께 도전장을 내민 KB국민은행은 이번에 탈락했다. 핀테크와 금융사가 인증 시장에 도전장을 내미는 이유는 인증이 금융 서비스를 완결하는 핵심이기 때문으로 돈이 오가는 금융 거래와 온라인 상거래를 이용할 때는 회원 가입과 비밀번호 변경 등 모든 절차에 본인 확인과 인증 절차가 필수적인데 토스가 본인확인기관으로 지정되면서 본인 확인부터 인증에 이르는 모든 절차를 직접 관리하게 된다. 3. 컴투스, 메타버스사 ‘위지윅’ 최대주주로…”글로벌 콘텐츠사로 가속화”컴투스, 메타버스사 ‘위지윅’ 최대주주로…”글로벌 콘텐츠사로 가속화” 위지윅은 증강현실(AR)·가상현실(VR)·가상융합현실(XR) 등의 기술을 결합해 미래 산업으로 부상하는 메타버스 프로젝트를 적극 추진하고, 지식재산(IP) 생산부터 2차 제작까지 전 과정을 하나의 스튜디오에서 통합 진행하는 위지윅만의 종합 제작 시스템도 구축하고 있으며, 이번 인수로 컴투스는 차세대 미디어 콘텐츠 산업에서 독보적 위치에 올라선 위지윅의 IP와 제작 역량을 확보해 글로벌 종합 콘텐츠 기업으로의 성장을 가속화할 수 있게 됐다. 영화, 드라마, 웹소설 등 위지윅의 여러 작품을 글로벌 게임으로 제작하고, 컴투스의 인기 게임들을 다양한 콘텐츠로 확장하는 등 트랜스 미디어 전략으로 탄탄한 IP 밸류체인을 만들어갈 계획이다. 위지윅은 세계 최고 수준의 컴퓨터그래픽(CG)·시각특수효과(VFX) 기술로 넷플릭스 ‘승리호’를 비롯해 국내외 다양한 영화, 드라마 등을 만들어온 콘텐츠 제작사다. 4. 페북 ‘얼굴정보’ 수집이 꼼수로 적발된 이유페북 ‘얼굴정보’ 수집이 꼼수로 적발된 이유 25일 개인정보보호위원회는 페이스북을 비롯한 넷플릭스, 구글 등 해외 플랫폼 사업자들을 대상으로 개인정보보호법 위반 행위를 적발, 과징금 총 66억6천만원과 과태료 2천900만원을 부과하는 등 시정명령을 내렸고, 과징금의 대부분이 페이스북의 불법 얼굴인식 정보 생성 및 수집에 따른 것이다. 페이스북은 이용자 정보를 수집 및 활용, 관리하는 방식을 안내하는 ‘데이터 정책’을 2018년 4월 수정, 얼굴인식 기능이 활성화될 수 있다는 내용을 명시했고, 이 기능이 활성화돼 있으면 이용자가 프로필에 등록한 사진, 영상 등을 토대로 얼굴에 대한 수치화된 정보(템플릿)를 생성, 수집하게 된다. 하지만 문제는 이용자가 가입 전 얼굴인식 기능을 비활성화할 수 없었다는 점이다. 이용자가 가입하자마자 이런 설정을 수정하지 않고 무심코 프로필에 얼굴 이미지를 등록하게 되면, 추가적인 동의 절차 없이 얼굴 정보가 수집된 것이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-25-IT_News/"},{"title":"2021년 08월 13일 금요일 IT뉴스","text":"1. 디즈니, 예상 뛰어넘는 실적…테마파크 개장·디즈니+ 효과디즈니, 예상 뛰어넘는 실적…테마파크 개장·디즈니+ 효과 디즈니가 테마파크 재개장과 스트리밍 서비스 호조에 힘입어 예상을 뛰어넘는 2분기 실적을 기록했고, 2분기 매출은 170억달러(약 19조8500억원)로, 작년 동기 대비 45% 상승했다. 월가 예상을 뛰어넘는 수치에 디즈니 주가는 시간외거래에서 4% 올랐다. 전 세계 모든 디즈니 테마파크가 문을 연 덕분에 테마파크는 2분기에만 43억달러(약 5조172억원)를 벌어들였고, 디즈니의 스트리밍 서비스인 디즈니플러스(Disney+)는 2분기에 월가 추정치를 상회하는 가입자 1억1600만명을 기록했다. 2. 비난 여론에 한발 물러선 카카오, 택시·바이크 요금 다시 내린다비난 여론에 한발 물러선 카카오, 택시·바이크 요금 다시 내린다 앞서 카카오모빌리티는 지난 2일부터 ‘스마트호출’ 비용을 기존 1000원(야간 2000원) 정액제에서 ‘0~5000원’의 탄력요금제로 변경했으나 독점적인 지위를 바탕으로 일방적인 서비스 요금 인상을 단행한다는 비판 목소리가 택시 업계 및 이용자를 중심으로 커졌고 ‘스마트호출’의 요금 범위를 ‘0~2000원’으로 재조정한다고 13일 공지했다. 이날 카카오모빌리티는 바이크 요금도 중장거리 이용자의 부담이 커진다는 의견에 따라 이용자 부담이 늘지 않는 방향으로 재조정할 예정이라고 발표했다. 구체적인 내용은 결정되면 별도 공지를 통해 안내할 계획이다. 3. MG새마을금고중앙회, RPA 도입으로 업무 혁신 꿈꾼다MG새마을금고중앙회, RPA 도입으로 업무 혁신 꿈꾼다 RPA 소프트웨어는 컴퓨터가 특정한 알고리즘으로 동작하도록 구성하며, 정량적 데이터를 다루는 분야일수록 정확도와 활용도가 높아서 금융업계의 관심도 높았지만, 보안이나 개인정보 등의 문제로 초기 도입부터 실용화 단계까지 오랜 시간과 노력이 필요해 경영진의 확실한 의사가 있어야 RPA를 추진할 수 있다. 현재 MG새마을금고중앙회는 계정계 시스템에서 보고서 작성, 자료 검증작업, 예탁금 처리, 회계 결산 등의 업무에 RPA를 도입한 상태로 보고서 작성의 경우, 업무 화면을 조회하고 결과 자료를 엑셀로 다운로드한 후 편집하는 모든 과정이 RPA를 통해 자동으로 진행된다. 업무 가능 범위도 단순 보고서화를 넘어서 PPT 파일, 워드 파일 작성 등 모든 작업이 가능해 기존에 하루가 걸리던 작업이 1~2시간 이내에 완료할 수 있게 됐으며 RPA를 활용해 내부망 시스템에 쌓인 보안 자료를 정리하는 ‘클린봇’이나 보안 패스워드를 관리하는 ‘패스워드봇’ 등을 구축하는 등 활용 범위를 확장하고 있다. RPA(Robotic Process Automation, 로봇 프로세스 자동화) 유아이패스는 RPA(Robotic Process Automation, 로봇 프로세스 자동화) 소프트웨어를 개발하는 전문 기업으로, 일반인들에게는 생소하지만 ICT 기술을 활용하는 기업들 사이에서는 널리 알려져 있다. 4. DGB금융그룹, 핀테크사 뉴지스탁 인수… 10번째 자회사 편입DGB금융그룹, 핀테크사 뉴지스탁 인수… 10번째 자회사 편입 DGB금융그룹이 핀테크 기업인 뉴지스탁(대표 문경록, 문호준)의 지분 74.03%를 인수해 그룹의 10번째 자회사로 편입한다. 국내 금융그룹이 핀테크사를 인수한 최초의 사례이다. 뉴지스탁 문경록 대표는 “핀테크 서비스와 제도권 금융업의 경계가 허물어지고 있는 이 시기에, 핀테크 스타트업 최초로 10대 금융지주 중 하나인 DGB금융그룹과 함께하게 되어 큰 기대를 하고 있으며”, DGB금융그룹 김태오 회장은 “뉴지스탁 인수를 통해 그룹의 디지털 자산관리 경쟁력을 대폭 업그레이드하고 핀테크 산업 활성화에 기여할 수 있을 것으로 기대한다”고 밝혔다. 뉴지스탁은 ‘개인투자자도 수익을 낼 수 있는 환경을 만들자’는 가치를 내걸고 2011년 설립됐으며, 현재 10만명 이상의 고객을 확보하고 12개 주요 증권사들과 제휴하고 있는 국내 1위의 알고리즘 주식투자 플랫폼 기업이다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-13-IT_News/"},{"title":"[CSS] 하드웨어 가속을 적극 활용하자 (translate3d)","text":"이채현 💡 CSS 하드웨어 가속 하드웨어 가속은 왜 필요할까?복잡한 계산이 필요한 인터렉션은 렌더링에 많은 시간이 걸리게 된다. 이런 부분을 CPU가 아닌 GPU가 계산하도록 만들면 렌더링 시간을 줄일 수 있게 된다. *하드웨어 가속을 사용하려면 어떤 스타일을 사용해야 할까?*대표적으로 animation(keyframes), will-change 속성이 있지만 두 속성은 사용하는 데 있어서 한계가 있다. 다양한 케이스에 대응하기 쉽고 초기 렌더링에도 크게 영향을 주지 않는 방법으로는 transform: translate3d 스타일을 사용하면 된다. will-change, translate3d속성은 브라우저에게 **&quot;얘는 3D 요소니까 하드웨어 가속을 써야 해!&quot;**라고 알려주며 대상이 되는 요소를 자체 레이어로 승격시키고 GPU 메모리에 할당이 되어 하드웨어가 계산을 하게 된다. translate3dtranslate3d()는 x, y, z 3차원의 값을 조정할 수 있다. translate3d의 동작원리는 translate와 동일하다. Y축으로 100% 원한다면 아래와 같이 작성가능하다. 1234567.anim { transform: translate3d(0, 100%, 0 );}.anim2 { transform: translateY(100%);} translate3d vs translateX, translateYtranslate3d는 하드웨어 가속, 즉 GPU를 사용하기 때문에 CSS 퍼포먼스가 일반적인 translate()보다 더 좋다. 따라서 더 좋은 퍼포먼스를 원한다면 translate3d를 사용하는 것이 좋을 듯 싶다. 하드웨어 가속 사용 시 고려 사항하드웨어 가속을 사용하면 웹 페이지의 렌더링 속도가 빨라지지만 잘못 사용하면 오히려 렌더링 속도가 느려지거나 브라우저에 문제가 일어날 수 있다. 주의 사항하드웨어 가속을 사용하면 다양한 성능 향상을 기대할 수 있지만, 그렇다고 모든 요소를 대상으로 적용하면 안 된다. 하드웨어 가속 대상을 지정할 때 다음의 사항을 기억하기 바란다. 무분별한 하드웨어 가속은 오히려 브라우저를 느리게 한다. 요소에 하드웨어 가속 속성이 부여되면 즉시 대상 영역이 GPU에 업로드되며, 이때 업로드되는 영역이 크면 화면이 깜빡이는 현상이 발생될 수 있다. 요소에 하드웨어 가속 속성이 부여되면 레이어로 분리되며, 레이어는 변경되는 내용이 없는 한 요소를 GPU 메모리에 다시 업로드하지 않는다. 하드웨어 가속 속성을 사용한 요소의 내용이 변경되면 GPU 메모리가 갱신되므로 요소의 내용을 미리 변경한 다음 하드웨어 가속 속성을 부여한다. 성능이 낮은 기기에서 하드웨어 가속을 사용하면 오히려 성능 저하를 가져올 수 있다. 적용 시 고려 사항하드웨어 가속을 사용할 때는 다음과 같은 점을 고려한다. 하드웨어 가속을 적용하는 요소의 크기는 작을수록 좋고, 요소의 개수는 화면에서 5~6개로 구성하는 것이 좋다.특히, 요소의 속성값에 따라 요소의 영역이 커질 수 있기 때문에 주의해서 적용해야 한다. 예를 들어 text-indent나 left 같은 속성에 999em이나 9999px과 같이 화면 영역을 지나치게 벗어나게 값을 설정하면, 콘텐츠 영역의 크기가 늘어나고 하드웨어 가속에 의해 구성된 레이어도 커지게 돼 불필요한 메모리를 사용하게 된다. DOM 요소의 내용이 자주 변경되지 않는 영역에 하드웨어 가속을 적용한다.내용 변경이 아닌 이동이나 크기 변경이 자주 발생하는 영역에 하드웨어 가속을 적용하고, 이동이나 크기 변경은 transform 속성을 사용한다. 기기에 따라 선별적으로 하드웨어 가속을 적용한다.JMC(Jindo Mobile Component)는 기기가 하드웨어 가속에 적합한 기기인지 확인할 수 있게 useCss3d() 메서드를 제공한다. 참고 자료: 카카오웹툰은 하드웨어 가속과 IntersectionObserver를 어떻게 사용했을까? NAVER D2","link":"/categories/%EC%9B%B9%EC%95%B1/CSS/CSS-Tip-1-22-07-04/"},{"title":"2021년 08월 30일 월요일 IT뉴스","text":"1. [미래기술25]네이버, 카카오…기업들도 다 뛰어들었다[미래기술25]네이버, 카카오…기업들도 다 뛰어들었다 국내 대표 인터넷·IT서비스 기업들도 블록체인 시장에 앞다퉈 뛰어들고 있으며, 시장조사 업체 마켓앤마켓에 따르면 지난해 30억 달러(3조5070억원)였던 글로벌 블록체인 시장 규모는 매년 67.3%씩 커져 오는 2025년 397억달러(46조4093억원)에 이를 전망입니다. 가장 활발한 움직임을 보이는 기업은 카카오로 최근 싱가포르에 블록체인 자회사 ‘크러스트’를 설립하며 글로벌 사업을 본격화했으며, 이뿐만 아니라 그라운드X는 대체 불가능 토큰(NFT) 사업에 공을 들이고 있다. 네이버 관계사인 라인도 지난 12일 암호화폐 ‘링크’를 국내 거래소(빗썸)에 처음으로 상장시키며 유동성 확대에 나서고 있습니다. 블록체인 생태계 확장의 일환으로 해석됩니다. 2. “IT기업·전문가 덕 ‘’먹통 백신예약 정상화”“IT기업·전문가 덕 먹통 백신예약 정상화” 김성훈 한국사회보장정보원 차세대개발본부장은 최근 본보와의 인터뷰에서 “백신 사전예약시스템 개선은 시급성과 기술적 난해함 때문에 군사작전을 방불케 하는 작업이었다”면서 “그러나 기업들이 앞다퉈 최정예 인력들을 보내줬고, 전문가들이 심야 회의와 새벽 퇴근, 주말 반납을 반복해 가며 매달린 덕분에 고도로 복잡한 문제를 풀 수 있었다”고 밝혔다. LG CNS는 질병청 시스템 전체를 상세진단한 후 최적화해 성능을 높이고, 쌍용정보통신은 질병청 예약시스템 전체를 개선했다. 한국오라클은 서버 2대를 클러스터링 구조로 연결한 데이터베이스 서버를 5대가 연결된 방식으로 바꿨다. 중소기업 시스템어소시에이츠는 전국을 수배해 서버·스토리지를 조달해 인프라를 확장했다. 와탭랩스와 에스티씨랩도 서버 구조 재배치에 참여했다. 바토스는 데이터베이스 설정작업과 테스트를 통해 문제 없는 가동을 도왔다. 큐본·데이타헤븐·이글로벌시스템은 예약처리 성능과 보안 강화작업을 했다. 3. ‘갤 Z플립3’는 어떻게 2030 앱등이들을 돌려 세웠나‘갤 Z플립3’는 어떻게 2030 앱등이들을 돌려 세웠나 아이폰 고집하던 2030도 갤럭시 Z플립3로 전향 아이폰, 애플워치, 에어팟, 아이패드 등 전자기기를 모두 애플 제품으로 구성하면 다른 브랜드로 넘어가는 게 쉬운 일이 아니다. 애플 제품끼리는 연동이 쉬워 사진 및 동영상 등 데이터를 옮길 때 편리하다. 폰꾸미기로 2030 겨냥… “나만의 핸드폰을 만드는 기분” 삼성전자는 갤럭시 Z플립3을 출시하면서 이전 플립 시리즈보다 4배 커진 커버 디스플레이를 강조했으며 커버 디스플레이는 플립을 닫았을 때 외부에 보이는 작은 화면으로 스마트폰을 열지 않고도 알림이나 메시지를 확인할 수 있고 위젯을 활용해 일정과 날씨를 확인할 수 있다. 특히 커버 디스플레이에 GIF 이미지도 적용 가능한 것이 2030이 열광하는 포인트 중 하나다. Z플립3 구매자들의 나만의 휴대폰 만들기는 우연이 아닌 기획의 산물이다. 4. 무신사, 스타일쉐어·29CM 지분 100% 인수 완료… “브랜드 패션 시장 시너지 강화”무신사, 스타일쉐어·29CM 지분 100% 인수 완료… “브랜드 패션 시장 시너지 강화” 무신사는 지난달 7일 스타일쉐어의 지분 전량(100%)을 확보하는 주식매매계약(SPA)과 주식의 포괄적 교환계약을 체결했고 이후 매매 대금 지급을 완료해 최종 인수 절차를 마무리했다. 스타일쉐어는 무신사 자회사로, 29CM는 완전손자회사로 편입되며 기존 인력은 전원 고용 승계하며 세 플랫폼을 합치지 않고 독립 운영한다. 5. NHN, 2021 게임부문 신입·경력사원 공개 채용NHN, 2021 게임부문 신입·경력사원 공개 채용 NHN은 금일부터 9월 14일까지 약 보름간 원서접수를 받고, 이후 서류전형-1차 면접-2차 면접 순으로 전형과정을 진행한다. 이번 게임부문 채용은 NHN, NHN빅풋, NHN픽셀큐브, NHN RPG 등 총 4개 법인으로 구분된다. NHN은 지난 4월 진행한 기술 경력 공채에 이어 이번 채용에서도 경력직 부문의 자기소개서 항목을 없애며 입사 절차를 간소화했다. 해외 여행에 결격 사유가 없고, 2022년 2월 졸업 예정자 또는 기졸업자(신입), 또는 게임기획/개발/디자인 경력직이라면 누구나 지원할 수 있다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-30-IT_News/"},{"title":"[JS] [번역] 40가지의 유용한 JavaScript팁, 트릭과 모범사례","text":"이 글에서는 브라우저 / 엔진 또는 SSJS (Server Side JavaScript) 인터프리터에 관계없이 모든 JavaScript 개발자가 알아야 할 JavaScript 팁, 트릭 및 모범 사례를 제공합니다. 이 글의 코드 스니펫은 V8 JavaScript 엔진 (V8 3.20.17.15)을 사용하는 최신 Chrome 버전 30에서 테스트되었습니다. 1. 변수를 처음으로 선언 할 때마다 var를 붙인다선언되지 않은 변수는 자동으로 전역 변수로 정의된다. 전역변수를 피하자! 2. == 대신에 === 사용== 및 != 연산자는 필요한 경우 자동 유형 변환을 수행한다 === 및 !== 연산자는 변환을 수행하지 않고, 값과 유형을 비교한다. (그래서 ==보다 빠르다, == 및 != 연산자는 되도록 사용하지 않도록하자! ) 12345678[10] === 10 // is false[10] == 10 // is true'10' == 10 // is true'10' === 10 // is false [] == 0 // is true [] === 0 // is false '' == false // is true but true == &quot;a&quot; is false '' === false // is false 3. undefined, null, 0, false, NaN, ''(empty string) 는 논리 값에 False 4. 세미콜론을 사용하여 행 구분세미콜론을 사용하여 라인종료하는 것이 좋다. 대부분의 경우 JavaScript 파서에 의해 삽입되기 때문에 잊어 버리면 경고하지 않는다. 세미콜론을 왜 사용해야하는지에 대한 자세한 내용은… 참조 5. 객체 생성자 (object constructor) 생성123456function Person(firstName, lastName) { this.firstName = firstName; this.lastName = lastName;}var Saad = new Person(&quot;Saad&quot;, &quot;Mousliki&quot;); 6. typeof, instanceof, constructor를 사용할 때 주의 typeof : JavaScript 단항 연산자는 변수의 기본 유형을 나타내는 문자열을 반환하는 데 사용되며 typeof null “객체”를 반환 한다는 사실을 잊지 말고 대부분의 객체 유형 (Array, Date 등)에서도 “객체”를 반환한다. constructor : 내부 프로토 타입 속성의 속성으로 코드에 의해 재정의 될 수 있습니다. instanceof : 모든 프로토 타입 체인을 검사하는 또 다른 JavaScript 연산자입니다. 생성자가 발견되면 true를 반환하고 그렇지 않으면 false를 반환합니다. 1234var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];typeof arr; // return &quot;object&quot;arr instanceof Array; // truearr.constructor(); //[] 7. 자신을 실행하는 Function (자체 호출) 만들기이를 종종 자체 호출 익명 함수, 즉시 실행 함수 또는 IIFE (Immediately Invoked Function Expression)라고합니다. 이 함수는 함수를 작성할 때 자동으로 실행되며 다음과 같은 형식을 갖습니다. 1234567(function () { // some private code that will be executed automatically})();(function (a, b) { var result = a + b; return result;})(10, 20); 8. 배열에서 임의의 항목 가져오기123var items = [12, 548, &quot;a&quot;, 2, 5478, &quot;foo&quot;, 8852, , &quot;Doe&quot;, 2145, 119];var randomItem = items[Math.floor(Math.random() * items.length)]; 9. 특정 범위의 난수 가져오기이 코드 조각은 테스트를 위해 더미 데이터를 생성하는 예를 들어 월급의 하한과 상한을 지정하고 그 범위에서 임의의 값을 얻고 싶은 경우에 유용합니다. 1var x = Math.floor(Math.random() * (max - min + 1)) + min; 10. 0부터 최대값을 갖는 배열 생성1234var numbersArray = [], max = 100;for (var i = 1; numbersArray.push(i++) &lt; max; ); // numbers = [1,2,3 ... 100] 11. 알파벳중에서 무작위 문자열 생성123456789function generateRandomAlphaNum(len) { var rdmString = &quot;&quot;; for ( ; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2) ); return rdmString.substr(0, len);} 12. 숫자 배열 섞기12345var numbers = [5, 458, 120, -215, 228, 400, 122205, -85411];numbers = numbers.sort(function () { return Math.random() - 0.5;});/* the array numbers will be equal for example to [120, 5, 228, -215, 400, 458, -85411, 122205] */ 더 나은 옵션은 기본 정렬 JavaScript 함수를 사용하는 것보다 코드에 의해 임의의 정렬순서를 구현하는 것일 수 있다. 참조 13. 문자열 trim 함수문자열에서 공백을 제외하는 trim 함수는 Java, C#, PHP 등 다양한 언어로 구현되어 있지만, JavaScript에는 존재하지 않는다. 그래서 String 개체에 추가할 수 있다. 123String.prototype.trim = function () { return this.replace(/^s+|s+$/g, &quot;&quot;);}; 14. 배열을 다른 배열에 추가12345var array1 = [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458];var array2 = [&quot;Doe&quot; , 555 , 100];Array.prototype.push.apply(array1, array2);/* array1 will be equal to [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458 , &quot;Doe&quot; , 555 , 100] */ 15. arguments 객체를 배열로 반환1var argArray = Array.prototype.slice.call(arguments); 16. 주어진 argument가 숫자인지 확인123function isNumber(n) { return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);} 17. 주어진 argument가 배열인지 확인123function isArray(obj) { return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;;} 위 코드에서 toString() 메소드가 재정의되면, 예상한 결과를 얻지 못할 수 있다.그래서… 1Array.isArray(obj); // its a new Array method 18. 배열 안의 숫자의 최대 값과 최소값 얻기123var numbers = [5, 458, 120, -215, 228, 400, 122205, -85411];var maxInNumbers = Math.max.apply(Math, numbers);var minInNumbers = Math.min.apply(Math, numbers); 19. 배열 비우기12var myArray = [12, 222, 1000];myArray.length = 0; // myArray will be equal to []. 20. 배열에서 item을 제거할 때 delete 사용하지 말것배열의 item를 제거 할 때는 delete 대신 split을 사용하자.delete 는 배열에서 item을 제외하는 것이 아니라, undefined으로 바꾼다. 12345var items = [12, 548, &quot;a&quot;, 2, 5478, &quot;foo&quot;, 8852, , &quot;Doe&quot;, 2154, 119];items.length; // return 11delete items[3]; // return trueitems.length; // return 11/* items will be equal to [12, 548, &quot;a&quot;, undefined × 1, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119] */ 위 대신에 다음과 같이 사용 12345var items = [12, 548, &quot;a&quot;, 2, 5478, &quot;foo&quot;, 8852, , &quot;Doe&quot;, 2154, 119];items.length; // return 11items.splice(3, 1);items.length; // return 10/* items will be equal to [12, 548, &quot;a&quot;, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119] */ 21. 배열의 length 속성을 사용하여 자르기위의 배열을 비우기 예와 같이 length 속성을 사용하여 자를 수 있다. 12var myArray = [12, 222, 1000, 124, 98, 10];myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124]. 또한 배열의 length보다 큰 값을 넣으면 배열의 길이가 변경되고, 새로운 item이 undefined 값으로 추가 된다.배열 길이는 읽기 전용 속성이 아니다. 12myArray.length = 10; // the new array length is 10myArray[myArray.length - 1]; // undefined 22. 조건 판정에 논리적 AND / OR 사용123var foo = 10;foo == 10 &amp;&amp; doSomething(); // is the same thing as if (foo == 10) doSomething();foo == 5 || doSomething(); // is the same thing as if (foo != 5) doSomething(); 논리적 OR은 함수 argument에 기본 값을 설정하는데 사용할 수 있다. 123function doSomething(arg1) { arg1 = arg1 || 10; // arg1 will have 10 as a default value if it’s not already set} 23. Use the map() function method to loop through an array’s items1234var squares = [1, 2, 3, 4].map(function (val) { return val * val;});// squares will be equal to [1, 4, 9, 16] 24. 소수점 이하 N자리수 반올림12var num = 2.443242342;num = num.toFixed(4); // num will be equal to 2.4432 25. 부동 소수점 문제1230.1 + 0.2 === 0.3; // is false9007199254740992 + 1; // is equal to 90071992547409929007199254740992 + 2; // is equal to 9007199254740994 0.1 + 0.2 는 0.30000000000000004과 같다. IEEE 754 표준에 따라 JavaScript의 숫자는 모두 내부적으로 64bit 부동 소수점 형으로 다루어지는 것을 알 필요가 있다. 자세한 설명은 블로그 게시물 참조 toFixed()및 버튼 toPrecision()을 사용하면이 문제를 해결할 수 있습니다. 26. for-in 루프를 사용할 때 객체의 속성확인이 코드 조각은 객체의 프로토타입의 속성을 열거하고 싶지 않은 경우에 편리하다. 12345for (var name in object) { if (object.hasOwnProperty(name)) { // do something with name }} 27. 쉼표 연산자1234var a = 0 ; var b = (a + , 99 ); console . log (a); // a will be equal to 1console . log (b); // b is equal to 99 28. 요소의 쿼리와 계산을 필요로 하는 Cache 변수jQuery 셀렉터의 경우는 DOM 요소를 캐시 할 수 있다. 1234var navright = document.querySelector(&quot;#right&quot;);var navleft = document.querySelector(&quot;#left&quot;);var navup = document.querySelector(&quot;#up&quot;);var navdown = document.querySelector(&quot;#down&quot;); 29. isFinite() 를 지나기 전에 인수 확인하기1234567isFinite(0 / 0); // falseisFinite(&quot;foo&quot;); // falseisFinite(&quot;10&quot;); // trueisFinite(10); // trueisFinite(undefined); // falseisFinite(); // falseisFinite(null); // true !!! 30. 배열에서 음수 인덱스 사용하지 않기123var numbersArray = [1, 2, 3, 4, 5];var from = numbersArray.indexOf(&quot;foo&quot;); // from is equal to -1numbersArray.splice(from, 2); // will return [5] splice에 전달 된 인수가 음수가 아닌지 확인해야 함 31. 직렬화와 역직렬화 (JSON 작업)12345var person = { name: &quot;Saad&quot;, age: 26, department: { ID: 15, name: &quot;R&amp;D&quot; } };var stringFromPerson = JSON.stringify(person);/* stringFromPerson is equal to &quot;{&quot;name&quot;:&quot;Saad&quot;,&quot;age&quot;:26,&quot;department&quot;:{&quot;ID&quot;:15,&quot;name&quot;:&quot;R&amp;D&quot;}}&quot; */var personFromString = JSON.parse(stringFromPerson);/* personFromString is equal to person object */ 32. eval(), Function 생성자 사용하지 말기eval이나 Function 생성자의 사용은 JavaScript 엔진이 실행가능한 소스코드로 변환해야하기 때문에 cost가 높다. 12var func1 = new Function(functionCode);var func2 = eval(functionCode); 33. with() 사용하지 말기 (The Good Part)with()를 사용하면 전역 범위에 변수가 삽입된다. 따라서 다른 변수와 이름이 같으면 혼동을 일으켜 값을 덮어 쓸 수 있다. 34. 배열에 for-in 루프 사용하지 말기1234var sum = 0;for (var i in arrayNumbers) { sum += arrayNumbers[i];} 위 대신에 다음과 같이 사용 1234var sum = 0;for (var i = 0, len = arrayNumbers.length; i &lt; len; i++) { sum += arrayNumbers[i];} 또한, i와 len의 인스턴스화는 for 루프의 첫번 째 명령문에 있기 때문에 한번 실행된다. 이렇게 하는 것이 아래처럼 하는 것보다 빠르다 1for (var i = 0; i &lt; arrayNumbers.length; i++) 그 이유는 arrayNumbers의 length를 루프마다 다시 계산하기 때문이다. 35. setTimeout()와 setInterval()는 문자열이 아닌 함수를 전달setTimeOut() 또는 setInterval()로 문자열을 전달하면 실행속도가 느린 eval과 같은 방식으로 평가된다. 12setInterval(&quot;doSomethingPeriodically()&quot;, 1000);setTimeout(&quot;doSomethingAfterFiveSeconds()&quot;, 5000); 위 대신에… 12setInterval(doSomethingPeriodically, 1000);setTimeout(doSomethingAfterFiveSeconds, 5000); 를 사용 36. 일련의 if / else 대신 switch / case 문 사용2개 이상의 case가 있을 경우, switch / case를 사용하는 편이 빠르고 우아하다. 10개 이상의 case가 있는 경우는 특히 피해야한다. 37. 숫자 범위 판정에 switch / case 사용숫자 범위의 판정은 아래와 같이 실형 가능하다. 12345678910111213141516171819function getCategory(age) { var category = &quot;&quot;; switch (true) { case isNaN(age): category = &quot;not an age&quot;; break; case age &gt;= 50: category = &quot;Old&quot;; break; case age &lt;= 20: category = &quot;Baby&quot;; break; default: category = &quot;Young&quot;; break; } return category;}getCategory(5); // will return &quot;Baby&quot; 38. 주어진 객체를 프로토 타입 객체로 생성하기줘진 객체를 프로토 타입 객체로 생성하는 함수는 다음과 같이 설명 할 수 있다. 123456function clone(object) { function OneShotConstructor() {} OneShotConstructor.prototype = object; return new OneShotConstructor();}clone(Array).prototype; // [] 39. HTML 이스케이프 함수123456function escapeHTML(text) { var replacements= {&quot;&lt;&quot;: &quot;&amp;lt;&quot;, &quot;&gt;&quot;: &quot;&amp;gt;&quot;,&quot;&amp;&quot;: &quot;&amp;amp;&quot;, &quot;&quot;&quot;: &quot;&amp;quot;&quot;}; return text.replace(/[&lt;&gt;&amp;&quot;]/g, function(character) { return replacements[character]; });} 40. 반복문 내에서 try-catch-finally 절은 사용하기 말기try-catch-finally 절은 현재 범위에 매번 새로운 변수를 생성한다.이것은 catch 절에서 포착되는 예외를 할당하기 때문이다. 123456789var object = [&quot;foo&quot;, &quot;bar&quot;], i;for (i = 0, len = object.length; i &lt; len; i++) { try { // do something that throws an exception } catch (e) { // handle exception }} 위 대신에 다음과 깉이 사용 123456789var object = [&quot;foo&quot;, &quot;bar&quot;], i;try { for (i = 0, len = object.length; i &lt; len; i++) { // do something that throws an exception }} catch (e) { // handle exception} 정리이 밖에도 팁 및 우용한 모범사례가 많이 있습니다. 만약 다른 것을 추가하는 것을 바라고, 의견이나 지적이 있으면 댓글을주세요. 출처40 Useful JavaScript Tips, Tricks and Best Practices","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS%20%5B%EB%B2%88%EC%97%AD%5D%2040%EA%B0%80%EC%A7%80%EC%9D%98%20%EC%9C%A0%EC%9A%A9%ED%95%9C%20JavaScript%ED%8C%81,%20%ED%8A%B8%EB%A6%AD%EA%B3%BC%20%EB%AA%A8%EB%B2%94%EC%82%AC%EB%A1%80-2019-04-17s/"},{"title":"[JS] Babel로 별칭 경로 설정하기","text":"이채현 💡 Javascript Babel Alias 프로젝트의 규모가 커지면 디렉토리 구조도 복잡해진다. 그 때문에 아래와 같이 컴포넌트의 위치를 찾기 어려워진다. 1import { whereIsThis } from &quot;../../../../../aaa/bbb/ccc&quot;; 위와 같이 작성한 것을 상대경로라고 한다. 상대 경로를 사용해서 모듈을 불러오면 모듈이 어느 경로에 위치하는지 파악하기가 난해해지는 경우가 생긴다. 뿐만 아니라, 이 자바스크립트 파일을 다른 디렉토리로 옮기려면 상대 경로를 그에 따라 모두 수정해줘야 해서 코드 리펙토링(refactoring)이 상당히 불편하다. 물론 절대경로를 사용하면 되지 않을까 생각할 수 있지만, 개발자들마다 해당 프로젝트를 다른 디렉토리에 저장해놓을 것이기 때문에 현실적으로 적용하기 어려운 방법이다. 별칭 경로위와 같은 문제는 자바스크립트 트랜스파일(transpile) 도구인 Babel(바벨)을 사용하면 이 문제를 비교적 간단하게 해결할 수 있습니다. Babel의 플러그인을 사용해서 별칭(alias) 경로를 설정해주면 된다. 1$ yarn add -D babel-plugin-module-resolver Babel의 module resolver 플러그인을 개발 의존성으로 설치 후, .babelrc설정 파일을 열고, plugins항목에 module-resolver설정을 추가해준다. 12345678910111213141516171819presets: ['@babel/preset-env', ...],plugins: [ ... [ 'module-resolver', { root: ['./src'], alias: { '#api': './src/api/', '#assets': './src/asset/', '#common': './src/common/', '#component': './src/component/', '#constant': './src/constant/', '#container': './src/container/', }, }, ], ...], alias 부분에서 ./src/api 를 #api로 표기함에 따라 12345import { alias } from &quot;./src/api/.../alias&quot;;// 위 코드를 아래와 같이 작성할 수 있습니다.import { alias } from &quot;#api/alias&quot;; 마치면서이상으로 Babel의 module resolver 플러그인을 이용한 별칭 경로 설정 방법이였습니다. 만약 본인이 Webpack 설정과 겹쳐 고민이 있다면 다음 글[JS] babelrc와 webpack.config을 참고해주세요.","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-Babel-1-22-07-05/"},{"title":"[JS] Class 간단 정리","text":"이채현 💡 Javascript class 클래스 class 선언은 프로토타입 기반 상속을 사용 정의: 함수 정의방법과 동일하게 가능, 함수 표현식과 함수 선언을 class표현식에서 사용 가능 1234567891011function Person(name, age) { this.name = name; this.age = age;}class Person { constructor(name, age) { this.name = name; this.age = age; }} 인스턴스 싱글리터럴로 만든 객체도 각자의 인스턴스를 뜻함..객체이지만 인스턴스 생성자 함수와 클래스를 활용하여…new 연산자와 더불어 만듬 123456function Func() {} // 생성자함수의 이름은 Pascal case로..class Class {}const newInstance = new Func();const newInstance2 = new Class(); 12345678910111213141516171819202122232425262728function Person(name, age) { this.name = name; this.age = age; this.location = location;}Person.prototype.getName = function () { return this.name + ' 입니다.';}=============================================class Person { constructor(name, age) { this.name = name; this.age = age; this.location = location; } getName() { return this.name + ' 입니다.'; }}const one = new Person('one', 1, 'Korea');const two = new Person('two', 2, 'Korea');console.log(one.getName()); // one 입니다. 클래스는 뿐만 아니라 Private키워드, 정적메서드 등 수 많은 기능을 제공 클래스 확장 (extends, 상속)12345678910111213141516171819202122232425262728293031// Super Classclass Animal { constructor(name, sound) { this.name = name this.sound = sound; } getInfo() { return this.name + '가(이)' + this.sound + '소리를 낸다.'; }}// Sub Classclass Friends extends Animal { constructor(name, sound) { super(name, sound); // 부모의 생성자함수를 호출가능 }}const dog = new Friends('개', '멍멍');const cat = new Friends('고양이', '냐옹');console.log(dog.getInfo()); // 개가(이)멍멍소리를 낸다.console.log(cat.getInfo()); // 고양이가(이)냐옹소리를 낸다.-------------------------------------------------dog.contructor.name // Friendscat.contructor.name // Friendsdog instanceof Friends // truedog instanceof Animal // true","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-Class-1-22-02-12/"},{"title":"[JS] 선언한 모듈로 이동하기 (alias) - Go to declaration","text":"이채현 💡 Javascript Babel & IDE `Go to declaration` 문제많은 사람들은 선언한 모듈들을 command/ctrl + click으로 해당 파일로 바로 이동하거나 자동완성이 되게하는 IDE나 Editor의 기능을 사용할 것이다. 그리고 babel-plugin-module-resolver을 통해 모듈의 경로를 별칭으로 바꿔서 사용할 것이다. 하지만 별칭으로 바꾸면서 위 기능이 깨지는 문제가 종종 있다. 그리고 이 문제는 플러그인쪽에서는 해결되지 않고 있다. npm에 올라온 최신버전은 이미 2년이 지났다. babel-plugin-module-resolver 해결우리는 jsconfig.json을 사용하여 IDE가 사용자 지정 resolve규칙을 따르도록 하는 것이 좋다. 이 접근 방식은 Webstorm과 VS Code 모두 작동한다. 12345678910111213141516171819202122232425{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;#api/*&quot;: [ &quot;./src/api/*&quot; ], &quot;#assets/*&quot;: [ &quot;./src/assets/*&quot; ], &quot;#common/*&quot;: [ &quot;./src/common/*&quot; ], &quot;#component/*&quot;: [ &quot;./src/component/*&quot; ], &quot;#constant/*&quot;: [ &quot;./src/constant/*&quot; ], &quot;#container/*&quot;: [ &quot;./src/container/*&quot; ] } }}","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-Babel-3-22-07-06/"},{"title":"2021년 08월 27일 금요일 IT뉴스","text":"1. 구글 ‘픽셀폰’ 국내 출시되나…관련 인력 채용 공고구글 ‘픽셀폰’ 국내 출시되나…관련 인력 채용 공고 최근 구글은 이와 관련된 인력 채용에 나서며, 국내 출시에 대한 기대감을 키우고 있다. 이에 따라 ‘외산폰의 무덤’으로 불리는 국내 시장에서 구글이 LG전자의 빈자리를 채우며 의미 있는 성과를 낼 수 있을지 주목된다. 2. 정부 인정 첫 민간인증서는 ‘페이코’…네이버·카카오보다 빨랐다정부 인정 첫 민간인증서는 ‘페이코’…네이버·카카오보다 빨랐다 독점적 공인인증서 제도 폐지 이후 정부가 처음 인정한 사설 인증서는 ‘페이코 인증서’가 됐으며 NHN페이코가 네이버·카카오·토스 등 쟁쟁한 경쟁자들에 한 발 앞서 ‘전자서명인증사업자’ 인정을 획득한 것이라 눈길을 끈다. 회사 측은 이번 정부 인정 획득으로 페이코 인증서의 공신력이 한층 높아져 공공·금융 등 다양한 분야로 사용처를 확대할 발판을 마련했다고 기대했다. 기존에 공인인증서만 허용하던 연말정산 같은 인증 서비스를 간편하게 사용할 수 있는 게 대표적 사례이고, 뿐만 아니라 ‘마이데이터’ 시장 공략에도 앞서나갈 수 있게 됐다. 내년 1월부터 시행되는 마이데이터 서비스의 통합인증 수단에는 전자서명인증사업자 평가·인정을 받은 민간 인증서도 허용된다. 3. 애플, ‘인앱결제 강제’ 사실상 포기…“외부결제 홍보 가능””애플, ‘인앱결제 강제’ 사실상 포기…“외부결제 홍보 가능” 우리나라에서 세계 최초로 구글과 애플 등 앱장터에서의 인앱결제 강제화를 금지하는 법안이 국회 본회의 통과를 앞둔 가운데 애플이 외부결제를 사실상 허용하도록 정책을 변경했습니다. 애플은 27일 미국 개발자와의 집단 소송과 관련해 앱 사업자가 자사 결제시스템이 아닌 외부결제 방식을 홍보할 수 있도록 하는 내용 등 7가지 사항에 합의했다고 밝혔습니다. 합의 사항은 ▲ 연 매출 100만 달러 미만 사업자에 대한 수수료 감면(30%→15%) 최소 3년 유지 ▲ 앱스토어 검색 시스템 3년 유지 ▲ 외부결제 방식에 대한 정보의 이메일 공유 허용 ▲ 개발자 선택 가능한 기준 가격 수의 확장(100개 미만→500개 이상) ▲ 앱 불승인 시 이의 제기 절차 유지 ▲ 연간 투명성 보고서 작성 및 앱 심사 절차에 대한 통계 공유 ▲ 소규모 개발자 지원 기금 설립 등입니다. 4. “메타버스 성공 위해선 킬러앱 나와야”“메타버스 성공 위해선 킬러앱 나와야” 이병호 서울대 전기정보공학부 교수는 27일 최종현학술원이 ‘메타버스 세계화’를 주제로 개최한 웨비나에서 “현재 메타버스의 콘텐츠는 주로 게임, 단기 이벤트 등에 치중돼 있다”며 “메타버스가 진정으로 사회적 영향력을 발휘하려면 일상적인 사용을 위한 앱이나 대중의 수요를 채워줄 수 있는 킬러 앱이 개발돼야 합니다.”라고 지적했다. 그는 “메타버스가 대중화를 이루려면 AR·VR 기기의 시각적 피로를 최소화하고, 기기의 크기를 줄이면서 시야각 등을 개선해야 한다”지적했다. 특히 시각적 피로도를 낮추려면 지연성을 줄이는 게 관건이다. 5. 전기차 충전 플랫폼 ‘모두의충전’, 서울 전역으로 서비스 확대전기차 충전 플랫폼 ‘모두의충전’, 서울 전역으로 서비스 확대 데이터를 기반으로 운영하는 ‘모두의 충전’은 지난 8개월 동안 강남 3구(송파-강남-서초)에 대리충전 서비스를 제공해왔으며, 최근 전문 탁송 기업과의 신규 계약을 통해 서비스 지역을 서울권 전역으로 확대했다. 스칼라데이터 윤예찬 대표는 “전기차 최대 등록지인 서울을 시작으로 향후 부산, 대구, 제주 등으로 서비스 지역을 확대할 계획으로 머신러닝 기반 충전 스케줄링 서비스, 충전 통합 결제 시스템, 전기차 베터리 보험 상품 연계 등 전기차와 관련한 다양한 서비스를 제공할 예정”이라며, ”전기차 충전을 생각하면 가장 먼저 떠오르는 스타트업이 되겠다.”라고 밝혔다.","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84%20IT%EB%89%B4%EC%8A%A4/21-08-27-IT_News/"},{"title":"[JS] 클로저 간단 정리","text":"이채현 💡 Javascript closure 클로저는 먼저 자바스크립트 변수의 유효범위를 이해해야한다. 클로저를 명확히 무엇이다라고 말하기는 어렵다. 1234567891011121314151617181920212223242526272829function returnX(){ return 'x';}const x = returnX()console.log(typeof x) // string----------------------------------------------function returnX() { let x = 'x'; return function returnY() { return x + 'y'; }}const x = returnX()console.log(typeof x) // function =&gt; return 값이 함수 덩어리이기 때문에const x = returnX()();console.log(typeof x) // stringfunction sum(num1) { return function (num2) { return num1 + num2; };}const sum5 = sum(5); // 숫자5가 계속 바인딩되어 있는 상태console.log(sum5(10)); // 15 은닉화1234567891011121314151617181920212223242526function privateData() { let temp = 'a'; return temp;}const result = privateData(); // privateData를 실행시켜야만 temp값을 알 수 있다.console.log(result);-------------------------------------function privateData() { let temp = 'a'; return { value: () =&gt; { return temp; }, changeValue: (newVal) =&gt; { temp = newVal; } };}const private = privateData();console.log(private.value()); // aprivate.changeValue('b');console.log(private.value()); // b 활용사례 고민해봤을 때 debounce와 throttle에서 …사용 debounce: 어떤 이벤트를 실행할 때 과하게 실행되는 것을 지연시켜주는 역할 (클릭지연..무한스크롤 지연) 12345678910111213141516buttonElement.addEventListener( 'click', debounce(handleClick, 500),)function debounce(func, timeout = 300) { let timer; return (...args) =&gt; { clearTimeout(timer); timer = setTimeout(() =&gt; { func.apply(this, args); }) }}","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-Closure-1-22-02-012/"},{"title":"[JS] 자료 다루기","text":"이채현 💡 Javascript 자료 다루기 객체Object.keys() 객체의 키들이다~~라는 느낌으로 객체의 키들이 배열로 반환된다. 12345678const object1 = { a: 'somestring', b: 42, c: false};console.log(Object.keys(object1));// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] Object.values() 객체의 값들이다~~라는 느낌으로 객체의 Value들이 배열로 반환된다. 12345678const object1 = { a: 'somestring', b: 42, c: false};console.log(Object.values(object1));// expected output: Array [&quot;somestring&quot;, 42, false] Object.entries() 객체를 인자로 받아, key와 value를 쌍으로 가진 배열을 반환한다. for…in와 같은 순서로 주어진 객체 자체의 enumerable 속성을 가짐 인덱스마다 배열을 가져서, 첫번째가 key, 두번째가 value이다. 배열안에 배열 123456789101112const object1 = { a: 'somestring', b: 42};for (const [key, value] of Object.entries(object1)) { console.log(`${key}: ${value}`);}// expected output:// &quot;a: somestring&quot;// &quot;b: 42&quot; 배열요소 추가와 제거 unshift ⇒ 배열의 앞에 요소 추가 push ⇒ 배열의 끝에 요소 추가 shift ⇒ 배열의 앞에 요소 제거 pop ⇒ 배열의 끝에 요소 제거 splice ⇒ 배열의 인덱스를 기반으로 요소 추가 및 제거 123456789101112array.splice(start[, deleteCount[, item1[, item2[, ...]]]])const months = ['Jan', 'March', 'April', 'June'];months.splice(1, 0, 'Feb');// inserts at index 1console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]months.splice(4, 1, 'May');// replaces 1 element at index 4console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;] 요소 병합 concat 12345678910111213141516const array1 = ['a', 'b', 'c'];const array2 = ['d', 'e', 'f'];const array3 = array1.concat(array2);console.log(array3);// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]const alpha = ['a', 'b', 'c'];alpha.concat(1, [2, 3]);// 결과: ['a', 'b', 'c', 1, 2, 3]--------const newArr = [...array1, ...array2];// ['a', 'b', 'c', 'd', 'e', 'f'] 고차 함수로 조작 (내장 메서드) 대표적으로 map, filter, reduce map12345const langs = ['JS', 'HTML', 'CSS'];const newLangs = langs.map(lang =&gt; lang + ' 언어');console.log(newLangs);// [ 'JS 언어', 'HTML 언어', 'CSS 언어' ] filter12345678910111213141516171819202122232425262728293031const langs = ['JS', 'HTML', 'CSS', 0, 1, 2, 3];const numbers = langs.filter(lang =&gt; { if (typeof lang === 'number') { return true; }});console.log(numbers);// [ 0, 1, 2, 3 ]const strings = langs.filter(lang =&gt; { if (typeof lang === 'string') { return lang; }})console.log(strings)// [ 'JS', 'HTML', 'CSS' ]const isNumber = function (el) { if (typeof el === 'number') { return true; }}const numbers = langs.filter(isNumber);console.log(numbers)const isString = (el) =&gt; typeof el === 'string';const strings = langs.filter(isString)console.log(string)// [ 0, 1, 2, 3 ]// [ 'JS', 'HTML', 'CSS' ] reduce 그전에 전형적인 명령어 프로그래밍 방식 12345678910111213141516171819202122// argument로 받거나// 인자에 spread형식으로 받거나...function sumTotal() { let temp = 0; for (let i = 0; i &lt; arguments.length; i++) { temp = temp + arguments[i]; } return temp;}console.log(sumTotal(1, 2, 3, 4, 5, 6, 7));// 28function sumTotal(...numbers) { let temp = 0; // reduce((누적값, 현재값){},초기값) return numbers.reduce((total, current) =&gt; total + current, 0); // 첫번째는 초기값(total(0))+ 인자(1)이 total로 들어가고 // 그 다음 total(1)+인자(cur(2))}console.log(sumTotal(1, 2, 3, 4, 5, 6, 7)); 요소 정렬sort12345678910const numbers = [4, 2, 5, 1, 3];const orderNumbers = numbers.sort((a, b) =&gt; a - b)console.log(orderNumbers);// [ 1, 2, 3, 4, 5 ]const strings = ['마', '가', '라', '나', '다'];const orderStrings = strings.sort((a, b) =&gt; a.localeCompare(b));console.log(orderStrings);//[ '가', '나', '다', '라', '마' ] 값 검색1234567891011121314151617const strings = ['마', '가', '라', '나', '다'];const result = strings.find((string) =&gt; string === '나');console.log(result);// 나 ///없으면 undefindedconst result = strings.findIndex((string) =&gt; string === '나');console.log(result);// 3const result = strings.indexOf('나'); // 왼쪽부터,,, lastIndexOf()console.log(result);// 3const result = strings.includes('나');console.log(result);// true","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-Data-1-22-02-06/"},{"title":"[JS] babelrc와 webpack.config","text":"이채현 💡 Javascript Babel & Webpack Webpack으로 React 프로젝트를 초기 설정하다가 , 123456789101112presets: [ [ '@babel/preset-env', { targets: { browsers: ['&gt; 5% in KR', 'last 2 chrome versions'], }, debug: true, }, ], '@babel/preset-react',], 위 코드의 presets가 과연 .babelrc에 있어야 하는지, webpack.config.js에 있어야하는지 잘 모르겠어서 각 파일의 목적을 정리해보았다. babelrc.babelrc는 babel의 설정을 위해 사용한다. 1234{ &quot;presets&quot;: [...], &quot;plugins&quot;: [...]} webpack.config물론 webpack.config.js는 webpack의 설정을 위해 사용한다. 프로젝트 파일의 번들링과 관련된 설정들을 작성해준다. 그리고 babel과 관련된 설정들을 .babelrc가 아닌 webpack.config.js에서 babel-loader를 설정한 부분에 작성해줄 수도 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051...module.exports = {...module: { rules: [ { test: /\\\\.js?/, loader: 'babel-loader', options: { presets: [ [ '@babel/preset-env', { targets: { browsers: ['&gt; 5% in KR', 'last 2 chrome versions'], }, debug:true, }, ], '@babel/preset-react', ], plugins: [ '@babel/plugin-proposal-class-properties', 'react-refresh/babel', [ 'module-resolver', { root: ['./src'], alias: { '#api': './src/api/', '#assets': './src/asset/', '#common': './src/common/', '#component': './src/component/', '#constant': './src/constant/', '#container': './src/container/', }, }, ], ], exclude: /node_modules/, }, }, ], },...} 결론결론은, babel의 presets는 webpack.config.js와 .babelrc 파일 둘 중 한 곳에만 있으면 된다! 그러나 babel cli를 이용하여 직접 코드 변환을 수행하거나 babel test 등을 돌릴 때에는 webpack을 거치지 않기 때문에 .babelrc에 작성하는 방식이 권장된다. 나는 webpack.config.js 내에 적어서 사용한다.","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-Babel-2-22-07-06/"},{"title":"[JS] ES6 - Functions","text":"이채현 💡 Javascript ES6 문법을 배워보자 - 함수 FunctionsArrow Functions기존 함수의 모습을 개선했다. 기존 함수 1234567891011function Hello() { return &quot;hi&quot;;}console.log(Hello());const names = [&quot;kim&quot;, &quot;lee&quot;, &quot;park&quot;];const hearts = names.map(function (name) { return name + &quot; ❤️&quot;;});console.log(hearts); Arrow Functions(1) - base 1234567891011const Hello = () =&gt; { return &quot;hi&quot;;};console.log(Hello());const names = [&quot;kim&quot;, &quot;lee&quot;, &quot;park&quot;];const hearts = names.map((name) =&gt; { return name + &quot; ❤️&quot;;});console.log(hearts); Arrow Functions(2) - implicit return 1234567const Hello = () =&gt; &quot;hi&quot;;console.log(Hello());const names = [&quot;kim&quot;, &quot;lee&quot;, &quot;park&quot;];const hearts = names.map(name =&gt; name + &quot; ❤️&quot;);console.log(hearts); this in Arrow Functions (Event listener in arrow function)일반 콜백 함수안에서 this는 이벤트리스너에 연결 된 엘리먼트를 가리킨다. 하지만, arrow function안에서 this는 window를 가리킨다. 결론, this를 함수 안에 익명함수로 사용할 때는 Arrow Function이 아닌 일반 표준 funtion 형태로 사용해야한다. 1234567891011121314const thisTest = { cnt: 0, addCnt() { this.cnt++; }, addCnt2: () =&gt; { this.cnt++; },};console.log(thisTest.cnt); // 0thisTest.addCnt();console.log(thisTest.cnt); // 1thisTest.addCnt2;console.log(thisTest.cnt); // 1 Default Values123456const sayHi = (aName = &quot;anon&quot;) =&gt; { return `Hello ${aName}`;}console.log(sayHi());console.log(sayHi('chaehyeon'));","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ES6-2-22-01-01/"},{"title":"[JS] DOM 문서 객체 모델","text":"이채현 💡 Javascript DOM DOM (문서 객체 모델…Document Object Model) HTML ⇒ 문서 문서를 조작하는 언어 ⇒ JavaScript Document Object Model ← JavaScript가 DOM을 통해 HTML을 조작 DOM 내부에는 Node: HTML 요소 하나하나 전부를 지칭 Node는 Tree형태로 부모노드가 자식노드를, 자식노드가 그 자식노드를… 각 Node에는 수 많은 Properties, Methods…가 존재 결론 HTML문서를 JavaScript로 모델링 한 것이 DOM 인터페이스를 하나하나 자르면 단위가 Node이며, Node는 Tree구조로 이루어져있다. Eg) ’li’ 태그를 뽑아보면 정보가아래처럼 수 많이 담겨있다. 123456789accessKey: &quot;&quot;ariaAtomic: nullariaAutoComplete: nullariaBusy: nullariaChecked: nullariaColCount: nullariaColIndex: nullariaColSpan: null... Dom 선택자바스크립트에서 HTML 특정 Element들을 가져오는 법 (고전적) Document.getElementById() 문서에 특정 id만 가져오고 싶을 때 Element.getElementsByClassName() 클래스 이름으로… 모든 자식의 엘리먼트를 가져온다. → HTML Collection 형태로 가져온다. Document.getElementsByTagName() 태그 이름으로 가져온다. 자바스크립트에서 HTML 특정 Element들을 가져오는 법 (비교적 최신) Document.querySelector() id(.), class(#), tag name 모두에 사용가능, 첫번째로 보이는 것을 가져온다. document.querySelectorAll() 해당하는 것을 모두 가져온다. (문자열 O) ⇒ NodeList로 가져오기 때문에 Array로 변환해서 사용한다. 그 외 다양한 조합으로 사용가능하다. eg) div.note → div태그 내에 note id를 가져온다. Dom 조작조작하기 위한 method들도 매우 많기 때문에 MDN문서를 보면서… textContent()… 텍스트 삽입 removeChild()… child 제거 createElement()…element 삽입 appendChild() innerHTML을 통해서 문자열로 컨트롤 가능하다.","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-DOM-1-22-02-02/"},{"title":"[JS] ES6 - Variables","text":"이채현 💡 Javascript ES6 문법을 배워보자 - 변수 VariablesLet and Constvar를 절대 사용하지 않고 let &amp; const 사용하기 var를 쓰면 안되는 이유 var hoisting 때문에… var는 라이프사이클에서… 선언과 초기화를 동시에 한다. global scope에 변수/함수를 선언할 경우 아무리 아래에 선언해도 제일 위로 올라간다. → 어디서 선언했든 상관없이, 항상 제일 위로 선언을 끌어올려준다. block scope를 철저히 무시한다. ⇒ 이러한 유연성으로 작은 어플리케이션을 금방 만들 수 있지만, 프로젝트의 규모가 커지면서 나중에서는 선언하지도 않은 값이 멋대로 출력되거나, 개발자들간의 협업에서 여러가지 문제점이 생길 수 있다. let은 선언과 초기화가 분리되어 그 사이에 TDZ가 생성되고, 접근할 경우 Reference Error가 발생한다. const는 선언과 초기화가 동시에 진행되지만, 선언 이전에 TDZ가 생성되어 접근하면 Reference Error가 발생한다. Dead Zonetemporal dead zone(TDZ)에 영향을 받는 구문은 크게.. const 변수 let 변수 class 구문 constructor() 내부의 super() 기본 함수 매개변수 Block Scopelet &amp; const는 block scope {}를 가짐 외부에서 접근 불가능하다. var는 function scope를 가짐 function 안에서 생성 된 var변수는 외부 function에서 접근 할 수 없지만, if/else, for등안에서 생성 된 var는 어디서는 접근 가능하다. Immutabe Data Typesprimitive types, frozen objects … 값이 바뀌지 않은 type CONSTANTS는 Immutable Data Types이며, 프로그래밍할 때 왠만하면 Immutable Data Types를 사용하자. 💁🏻‍♀️ Immutable Data Types을 사용해야 하는 이유 security 해커들이 코드의 값을 바꾸는 것을 방지한다. thread safety 어플리케이션을 실행하면 한가지의 프로세스가 할당되고, 그 프로세스 안에서 다양한 thread가 동시에 돌아가게 된다.이때 이 다양한 thread가 동시에 변수에 접근해서 값을 변경할 수 있게 되는 위험성이 생기는데, 이것을 방지한다. reduce human mistakes 앞으로 해당 코드를 변경할 더 좋은 방안이 없다면, const 를 이용해 작성하여 본인 혹은 다른 개발자가 코드를 변경할때 발생할 수 있는 실수를 방지해준다.","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ES6-1-22-01-01/"},{"title":"[JS] ES6 - Strings","text":"이채현 💡 Javascript ES6 문법을 배워보자 - 문자열 StringsTemplate Literalvariable을 가진 문자열을 쓰는 방법에 대한 개선 12345678910111213141516const sayHi = (aName = &quot;anon&quot;) =&gt; { return &quot;Hello &quot; + aName;};==&gt;/*** 변수*/const sayHi = (aName = &quot;anon&quot;) =&gt; { return `Hello ${aName}`;}/** * 함수 */const add = (a, b) =&gt; a + b;console.log(`hello how are you ${add(6, 6)}`); HTML Fragments 11234567891011const wrapper = document.querySelector(&quot;.wrapper&quot;);const addWelcome = () =&gt; { const div = document.createElement(&quot;div&quot;); const h1 = document.createElement(&quot;h1&quot;); h1.innerText = &quot;Hello&quot;; div.append(h1); wrapper.append(div);};setTimeout(addWelcome, 1000); ⇒ 12345678const addWelcome = () =&gt; { const div = ` &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/div&gt; `; wrapper.innerHTML = div;}; template literal은 ``` … space를 고려한다. HTML Fragments 212345678910const alphas = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;];const ul = document.createElement(&quot;ul&quot;);const list = ` &lt;h1&gt;Alphabet&lt;/h1&gt; &lt;ul&gt; ${alphas.map(alpha =&gt; `&lt;li&gt;${alpha}&lt;/li&gt;`).join(&quot;&quot;)} &lt;/ul&gt; `;wrapper.innerHTML = list; Cloning Styled Components12345678910111213141516171819202122232425262728/** * Cloning Styled Components */const styled = (aElement) =&gt; { const el = document.createElement(aElement); return (args) =&gt; { const styles = args[0]; el.style = styles; return el; };};// 아래 코드는 함수를 두변 연속 호출 하는 꼴이기 때문에// 위 함수에서 클로저로 함수를 또 한번 호출할 필요가 있다.const title = styled(&quot;h1&quot;)` background-color: red; color: blue;`;const subTitle = styled(&quot;span&quot;)` color: green;`;title.innerText = &quot;We just cloned&quot;;subTitle.innerText = &quot;Styled Components&quot;;document.body.append(title, subTitle); More String Improvements1234567891011121314151617181920/** * includes() */const isEmail = (email) =&gt; email.includes(&quot;@&quot;);console.log(isEmail(&quot;myEmail@google.com&quot;)); // trueconsole.log(isEmail(&quot;myEmail&quot;)); // false/** * repeat() */const CC_NUMBER = &quot;6060&quot;; // ************6060로 보여주기const displayName = `${&quot;*&quot;.repeat(10)}${CC_NUMBER}`;console.log(displayName); // **********6060/** * startsWith(), endsWith() */const name = &quot;Mr. abc&quot;;console.log(name.startsWith(&quot;Mr&quot;)); // trueconsole.log(name.endsWith(&quot;abc&quot;)); // true","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ES6-3-22-01-01/"},{"title":"[JS] ES6 - Array","text":"이채현 💡 Javascript ES6 문법을 배워보자 - 배열 ArrayArray.of()무엇이든 Array로 만들어준다. 1234// Array.of()const alphabet = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];const alphabet = Array.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)const alphabet = Array.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2, 3);;console.log(alphabet); Array.from()Array.from(array같이 생긴 것) 😠 querySelector나 getElementbyClassName으로 엘리먼트 찾으면 array 같지만 아닌 다른 저장 포맷으로 저장된다 array-like object를 array로 바꿔준다. 1234567891011const buttons = document.getElementsByClassName(&quot;btn&quot;);console.log(buttons);// buttons는 Array가 아니기 때문에// 아래와 같이 forEach를 사용할 수 없다.buttons.forEach((button) =&gt; { button.addEventListener(&quot;click&quot;, () =&gt; console.log(&quot;I ve been clickeds&quot;));});----------------Array.from(buttons).forEach((button) =&gt; { button.addEventListener(&quot;click&quot;, () =&gt; console.log(&quot;I ve been clickeds&quot;));}); Array.find()Array.prototype.find() - JavaScript | MDN 123456789101112131415/** * Array.find() */const friends = [ &quot;nico@gmail.com&quot;, &quot;lynn@naver.com&quot;, &quot;dal@yahoo.com&quot;, &quot;dal2@yahoo.com&quot;,];const target1 = friends.find((friend) =&gt; friend.includes(&quot;@yahoo.com&quot;));// 조건을 넣어주면 forEach를 돌리면서 그에 맞는 값을 리턴해준다// 찾은 첫번째 값만 반환해준다// 없으면 undefined반환한다console.log(target1); Array.findIndex()Array.prototype.findIndex() - JavaScript | MDN 12345678910/** * Array.findIndex() */const target2 = friends.findIndex((friend) =&gt; friend.includes(&quot;@yahoo.com&quot;));// 인덱스가 필요할때!// 없으면 -1반환한다console.log(target2);const userName = friends[target2].split(&quot;@&quot;)[0];const email = &quot;yahoo.com&quot;;console.log(`${userName}@${email}`); Array.fill()Array.prototype.fill() - JavaScript | MDN 12345if (target2 !== -1) { friends.fill(&quot;*&quot;.repeat(5), target2 + 1); // target부터 모든 변수는 다 채울값으로 채워줌}console.log(friends);","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ES6-4-22-01-01/"},{"title":"[JS] ES6 - Rest and Spread","text":"이채현 💡 Javascript ES6 문법을 배워보자 - Rest & Spread Rest and SpreadSpread기본적으로 변수를 가져와 풀어 해쳐 전개해놓는 것. 12345678910111213141516171819202122232425262728293031/** * Spread */const friends = [1, 2, 3, 4];console.log(friends); // [1, 2, 3, 4]console.log(...friends); // 1 2 3 4const family = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];console.log(friends + family); // 1,2,3,4a,b,cconsole.log([friends, family]); // [ [ 1, 2, 3, 4 ], [ 'a', 'b', 'c' ] ]console.log([...friends, ...family]); // [ 1, 2, 3, 4, 'a', 'b', 'c' ]// spread를 통해 모든 요소를 담고 있는 하나의 object를 얻을 수 있다.// array.push()를 이용하지 않고 값을 추가하여 새로운 객체를 만든다.const newFriends = [...friends, 5, 6, 7];console.log(newFriends); // [ 1, 2, 3, 4, 5, 6, 7]const admin = { username: &quot;admin&quot;,};console.log({ ...admin, password: 123 }); // { username: 'admin', password: 123 }// 조건식// lastName을 입력받았을 때 값이 있을 때만 객체에 넣어주기const lastName = prompt(&quot;Last name: &quot;);const person = { username: &quot;person&quot;, age: 24, ...(lastName !== &quot;&quot; &amp;&amp; { lastName }), // spread로 전개하려면 데이터가 object여야하므로, 중괄호로 감싸줌 // lastName: lastName !== &quot;&quot; ? lastName : undefined,};console.log(person); Rest Parameters끝없는 인자를 받아 볼때 유용하게 이용할 수있다 spread는 죄다 펼쳐 확대시키는 것이고, ****rest는 하나에 담아서 축소시키는것 어디에 들어가느냐에 따라 spread와 rest(parameter부분에 들어가면 )로 갈릴수있음 1234567891011121314const infiniteArge = (...kimchi) =&gt; console.log(kimchi);infiniteArge(&quot;1&quot;, 2, true, &quot;lalala&quot;, [1, 2, 3, 4]);// 전부 배열에 넣어서 출력된다.const bestFriends = (firstPotato, ...potatos) =&gt; { console.log(`he is ${firstPotato}`); console.log(potatos);}bestFriends(&quot;nico&quot;, &quot;lynn&quot;, &quot;steve&quot;, &quot;flynn&quot;);// he is nico// [&quot;lynn&quot;, &quot;steve&quot;, &quot;flynn&quot;]// 이렇게 출력된다 Rest + Spread + Destructure Magicobject를 지우거나 정리할 때 유용하다 123456789101112131415161718const user = { name :&quot;nico&quot;, age:24, password : 12345};const killPassword = ({password, ...rest}) =&gt; rest; // destructure + rest// destructuring을 통해 user의 password를 가져오고, 나머지를 rest에 저장const cleanUser = killPassword(user)console.log(cleanUser) // {name:&quot;nico&quot;, age:24} 출력한다const setCountry = ({ country = &quot;KR&quot;, ...rest }) =&gt; ({ country, ...rest });// default 설정 + rest + spreadconsole.log(setCountry(user));// {country : &quot;KR&quot;, name :&quot;nico&quot;, age:24, password : 12345} 출력","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ES6-6-22-01-02/"},{"title":"[JS] ES6 - Destructuring","text":"이채현 💡 Javascript ES6 문법을 배워보자 - 비구조화 Destructuringdestructuring(비구조화)는 object나 array 등 안의 변수를 바깥으로 끄집어내는 것 Object Destructuring1234567891011121314151617181920/** * Object Destructuring */const settings = { notifications: { follow: true, alerts: true, unfollow: false, }, color: { theme: &quot;dakr&quot;, },};if (settingss.notifications.follow) { // send email}// 기존에는 위와 같이 사용했다. 보기에 매우 불편하다.// 만약 follow라는 값이 없느면 undefined오류가 발생할 것이다. ⇒ 123456789101112// 기본적으로 settings를 열어 notifications에 접근하여 follow를 가져오는 것const { notifications: { follow = false } = {}, color } = settings;// settings에 notifications가 없으면 {}, notifications에 follow가 없으면 false로// default 값 세팅을 해준다.console.log(follow); // trueconsole.log(color); // { theme: 'dark' }// 이 때 notifications는 변수가 아님 -&gt; notifications를 console.log에 찍으면 is not defined 오류 발생// 이런 방식은 큰 Object에서 특정 변수나 그 안에 속한 작은 Object에 접근할 수 있도록 해주는 것// Array Destructuringarray destructuring은 보통 가져온 정보를 조작하기 않을 때 쓰기 좋다. 12345678910/** * Array Destructuring */const days = [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;];const [mon, tue, wed, , , , sun, aaa = &quot;AAA&quot;] = days; // ,,,은 skippin// mon 에는 &quot;Mon&quot; , tue에는 &quot;Tue&quot;, wed 에는 &quot;Wed&quot; sun에는 &quot;Sun&quot;이 들어가있음// aaa는 AAAconsole.log(sun); Renamingapi등에서 받아온 데이터의 이름이 별로일 때 바꿔보자 123456789101112131415161718192021222324252627/** * Renaming */const settings = { color: { chosen_color: &quot;dark&quot;, },};const { color: { chosen_color: chosenColor = &quot;light&quot; },} = settings;// :를 붙혀 새로운 변수를 생성하고 그 변수에 값을 담는다.-----------------let chosenColor = &quot;blue&quot;; // 변수가 미리 있다면console.log(chosenColor); // blue({ color: { chosen_color: chosenColor = &quot;light&quot; },} = settings);// 위와 같이 적어 이미 정의가 되어있는 choseColor의 값을 업데이트한다.console.log(chosenColor); // dark Function Destructuring123456789101112131415161718192021222324252627282930/** * Function Destructuring */function saveSettings(followAlert, unfollowAlert, mrkAlert, themeColor) {} // argument가 너무 길다function saveSettings({ follow, alert, color = &quot;blue&quot; }) { console.log(color); // green}saveSettings({ follow: true, alert: true, mkt: true, color: &quot;green&quot;,});----------- 더 간단히..function saveSettings({ notifications, color: { theme = &quot;blue&quot; } = {} }) { console.log(theme); // blue}saveSettings({ notifications: { follow: true, alert: true, mkt: true, }, // color: { theme: &quot;green&quot; },}); Value shorthands123456789101112131415161718const follow = checkFollow();const alert = checkAlert();const settings = { notifications: { follow: follow, alert: alert, },};// 위 아래 같다. key와 value가 같다면...const settings = { notifications:{ follow, alert }}","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ES6-5-22-01-02/"},{"title":"[JS] ES6 - For","text":"이채현 💡 Javascript ES6 문법을 배워보자 - For ForforEach123456789const friends = [&quot;me&quot;, &quot;you&quot;, &quot;nico&quot;];const addHeart = (current, index, array ) =&gt; ( console.log(current, index, array));friends.forEach(addHeart); // 파라미터 첫번째로 값을 주고 두번째로 인덱스를 주고 세번째로 현재 배열을 준다 // me 0 [&quot;me&quot;, &quot;you&quot;, &quot;nico&quot;] // you 1 [&quot;me&quot;, &quot;you&quot;, &quot;nico&quot;] // nico 2 [&quot;me&quot;, &quot;you&quot;, &quot;nico&quot;] for…of123456789101112131415161718for (const friend of friends) { // 장점 1) const, let 뭐로 할건지 결정가능, forEach에서는 안됨 console.log(friend); // 모두다 출력됨}for (const char of &quot;strings&quot;) { console.log(char); // s t r i n g s 출력}// 장점 2) iterable한 모든것에서 작동한다for (const friend of friends) { if (friend === &quot;steve&quot;) { break; } else { console.log(char); // &quot;me&quot;, &quot;you&quot;, &quot;nico&quot; 이렇게만 출력 }}// 장점 3) 루프를 멈출수가있음!, 최고장점","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ES6-7-22-01-02/"},{"title":"[JS] ES6 - Promise","text":"이채현 💡 Javascript ES6 문법을 배워보자 - Promise Promisesasync자바스크립트는 순차적으로 처리되는게 아니라 한꺼번에 실행된다. ⇒ 자바스크립트의 비동기성(async) 이벤트 루프에서 비동기적으로 실행시킨다. PromisePromise는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타낸다. 내가 아직 모르는 값이랑 같이 일하게 해준다 금방 끝나진 않겠지만 곧 오면 이걸 가지고 작업할 게 표시 해주는 것 123456789101112131415const promiseTest1 = new Promise((resolve, reject) =&gt; { setTimeout(resolve, 3000, &quot;Test Pass&quot;);});// setInterval(console.log, 1000, promiseTest1);promiseTest1.then((value) =&gt; console.log(value));const promiseTest1 = new Promise((resolve, reject) =&gt; { setTimeout(reject, 3000, &quot;Test Fail&quot;);});// setInterval(console.log, 1000, promiseTest1);promiseTest1 .then((value) =&gt; console.log(value)) .catch((error) =&gt; console.log(error)); Chaining Promise.then().then()…. 할때 리턴 필요 12345678910const promiseTest2 = new Promise((resolve, reject) =&gt; { resolve(2);});promiseTest2 .then((number) =&gt; { console.log(number * 2); return number * 2; }) .then((otherNumber) =&gt; console.log(otherNumber * 2)); Propmise.allPromise.all은 주어진 모든 Promise를 실행한 후 진행되는 하나의 Promise를 반환한다. 123456789101112131415161718192021222324/** * Promise.all */const p1 = new Promise((resolve) =&gt; { setTimeout(resolve, 5000, &quot;first&quot;);});const p2 = new Promise((resolve) =&gt; { setTimeout(resolve, 1000, &quot;second&quot;);});const p3 = new Promise((resolve) =&gt; { setTimeout(resolve, 3000, &quot;third&quot;);});const motherPromise = Promise.all([p1, p2, p3]);motherPromise .then((values) =&gt; console.log(values)) .catch((err) =&gt; console.log(err));// 모든 프로미스가 resolve 해야지 출력// 5초후 마지막 first 끝나야 최종출력// 중간에 reject 뜨면 바로 중단 Promise.race기본적으로 promise all이랑 같지만 하나만 resolve 되거나 reject하면 된다. 가장 빨리 리턴 되는 걸로 결정, 부모프로미스를 차지하고 그 값 하나 리턴함 12345678910/** * Promise.race */ const motherPromise2 = Promise.race([p1, p2, p3]); motherPromise2 .then((values) =&gt; console.log(values)) .catch((err) =&gt; console.log(err));// second finally뭘하든 마지막에 실행된다. 보통 작업이 다 끝나고 로딩 끝낼 때 쓴다. 12345678/** * Finally */const p1 = new Promise((resolve) =&gt; { setTimeout(resolve, 3000, &quot;first&quot;);}) .then((value) =&gt; console.log(value)) .finally(() =&gt; console.log(&quot;I'm done&quot;));","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ES6-8-22-01-03/"},{"title":"[JS] ESLint 알고쓰기 : 설정 설명","text":"이채현 💡 ESLint 설정하기 노션 링크 이 문서는 eslint.org를 참고하여 eslint 7.32.0 버전에서 작성되었으며, 아래 프로젝트를 기반으로 작성했습니다. https://github.com/chlee1001/react-typescript-simple-boilerplate 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061{ &quot;env&quot;: { &quot;browser&quot;: true, &quot;es2021&quot;: true, &quot;node&quot;: true }, &quot;extends&quot;: [ &quot;airbnb&quot;, &quot;airbnb-typescript&quot;, &quot;airbnb/hooks&quot;, &quot;plugin:@typescript-eslint/recommended&quot;, &quot;plugin:@typescript-eslint/recommended-requiring-type-checking&quot;, &quot;plugin:import/recommended&quot;, &quot;plugin:import/typescript&quot;, &quot;plugin:jsx-a11y/recommended&quot;, &quot;plugin:prettier/recommended&quot;, &quot;plugin:react/recommended&quot;, &quot;plugin:react-hooks/recommended&quot; ], &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;, &quot;parserOptions&quot;: { &quot;project&quot;: [ &quot;./tsconfig.json&quot; ], &quot;ecmaFeatures&quot;: { &quot;jsx&quot;: true }, &quot;ecmaVersion&quot;: &quot;latest&quot;, &quot;sourceType&quot;: &quot;module&quot; }, &quot;plugins&quot;: [ &quot;react&quot;, &quot;@typescript-eslint&quot;, &quot;import&quot; ], &quot;rules&quot;: { &quot;import/prefer-default-export&quot;: &quot;off&quot;, &quot;import/no-unresolved&quot;: 0, &quot;import/extensions&quot;: [ &quot;off&quot; ], &quot;react/function-component-definition&quot;: [ 2, { &quot;namedComponents&quot;: &quot;arrow-function&quot;, &quot;unnamedComponents&quot;: &quot;arrow-function&quot; } ] }, &quot;ignorePatterns&quot;: [ &quot;paths.js&quot;, &quot;webpack.*.js&quot;, &quot;dist/*&quot;, &quot;node_modules/*&quot; ], &quot;settings&quot;: { &quot;react&quot;: { &quot;version&quot;: &quot;detect&quot; } }} ENV browser - browser global variables : true를 하게되면 **console.log()**를 에러없이 사용할 수 있다. node - Node.js global variables and Node.js scoping : true를 하게되면 전역에서 require를 에러없이 사용할 수 있게된다. es2021 - adds all ECMAScript 2021 globals and automatically sets the ecmaVersion parser option to 12. EXTENDSextends는 추가한 플러그인에서 사용할 규칙을 설정한다. 플러그인을 설치하여도, 플러그인은 일련의 규칙집합이며 플러그인을 추가하여도 규칙은 적용되지 않는다. 규칙을 적용하기 위해서는 추가한 플러그인 중, 사용할 규칙을 extends 내에 추가해야한다. 보통 대부분의 플러그인은 recommended나 strict, all 등의 자체 설정을 제공한다. recommended: 프로젝트에 권장하는 규칙 집합 1234567891011121314151617... &quot;extends&quot;: [ &quot;airbnb&quot;, // airbnb의 규칙 사용 &quot;airbnb-typescript&quot;, // TS를 지원하는 airbnb 규칙 구성 향상 &quot;airbnb/hooks&quot;, // React hooks를 위한 airbnb 규칙사용 &quot;plugin:@typescript-eslint/recommended&quot;, // ESLint가 TypeScript를 지원할 수 있도록 하는 모든 도구를 위한 Monorepo &quot;plugin:@typescript-eslint/recommended-requiring-type-checking&quot;, // 일부 highly valuable rules를 올바르게 구현하기 위해 유형 검사를 위한 추천 요구 유형 검사 &quot;plugin:import/recommended&quot;, // import명이나 잘못 작성한 파일 경로에 대한 이슈를 방지해주는 플러그인 (아래 errors와 warnings의 집합) // &quot;plugin:import/errors&quot;, // &quot;plugin:import/warnings&quot;, &quot;plugin:import/typescript&quot;, // TS에서 `eslint-plugin-import`를 사용하기 위해 추가 &quot;plugin:jsx-a11y/recommended&quot;, // JSX 요소에 대한 접근성 규칙 &quot;plugin:prettier/recommended&quot;, // prettier 규칙을 적용하여 틀릴 경우 eslint 문제로 처리 &quot;plugin:react/recommended&quot;, // eslint-plugin-react의 추천 규칙 사용 &quot;plugin:react-hooks/recommended&quot; ],... PARSER코드를 분석하기 위한 파싱툴이다. 기본값은 espress이고, 보통 js 워크스페이스에서는 @babel/eslint-parser를 사용하고 ts 워크스페이스인 경우 @typescript-eslint/parser를 사용한다. 사실 plugin:@typescript-eslint/recommended를 포함시키면 @typescript-eslint/parser가 자동으로 포함되기도 한다. 1&quot;parser&quot;: &quot;@typescript-eslint/parser&quot; PARSER OPTIONSparserOptions은 ESLint 사용을 위해 지원하려는 Javascript 언어 옵션을 지정할 수 있습니다. project: 이 옵션을 사용하면 제공된 tsconfig에서 정의한 프로젝트에 포함되지 않은 파일이 허용되도록 요청할 수 있다. ecmaVersion: 사용할 ECMAScript 버전을 설정 sourceType: parser의 export 형태를 설정 ecmaFeatures: ECMAScript의 언어 확장 기능을 설정 globalReturn: 전역 스코프의 사용 여부 (node, commonjs 환경에서 최상위 스코프는 module) impliedStric: strict mode 사용 여부 jsx: ECMScript 규격의 JSX 사용 여부 12345678910&quot;parserOptions&quot;: { &quot;project&quot;: [ &quot;./tsconfig.json&quot; ], &quot;ecmaFeatures&quot;: { &quot;jsx&quot;: true }, &quot;ecmaVersion&quot;: &quot;latest&quot;, &quot;sourceType&quot;: &quot;module&quot;}, PLUGIN플러그인 패키지를 설치하고, 해당 플러그인을 plugins에 추가하여 사용할 수 있다. 12345&quot;plugins&quot;: [ &quot;react&quot;, &quot;@typescript-eslint&quot;, &quot;import&quot;], RULESESLint에는 프로젝트에서 사용하는 규칙을 수정할 수 있다. 규칙을 변경하는 경우, 다음과 같은 방법으로 설정해야한다. &quot;off&quot; 또는 0: 규칙을 사용하지 않음 &quot;warn&quot; 또는 1: 규칙을 경고로 사용 &quot;error” 또는 2: 규칙을 오류로 사용 규칙에 추가 옵션이 있는 경우에는 배열 리터럴 구문을 사용하여 지정할 수 있다. 1234567891011121314&quot;rules&quot;: { &quot;import/prefer-default-export&quot;: &quot;off&quot;, &quot;import/no-unresolved&quot;: 0, &quot;import/extensions&quot;: [ &quot;off&quot; ], &quot;react/function-component-definition&quot;: [ 2, { &quot;namedComponents&quot;: &quot;arrow-function&quot;, &quot;unnamedComponents&quot;: &quot;arrow-function&quot; } ] } 규칙 무시하기파일 디렉토리 제외ignorePatterns 필드 또는 .eslintignore 파일을 작성하여 파일 및 디렉토리를 제외하도록 지정할 수 있습니다. 12345678910111213// .eslintrc 파일 ignorePatterns 설정&quot;ignorePatterns&quot;: [ &quot;paths.js&quot;, &quot;webpack.*.js&quot;, &quot;dist/*&quot;, &quot;node_modules/*&quot;],//.eslintignore 파일 생성config/dist/node_modules/ 대체파일 사용.eslintignore를 현재 작업 디렉토리가 아닌 다른 파일을 사용하려면 --ignore-path 옵션을 사용하여 명령행에 파일을 지정할 수 있다. 1$ eslint --ignore-path .gitignore file.js 인라인으로 규칙 비활성화123456789101112131415161718**// 전체 파일 규칙 경고 비활성화, 파일 맨위에 아래 블록 주석 추가**/* eslint-disable */....../* eslint-enable no-alert, no-console */**// 경고 비활성화 블록 주석**/* eslint-disable */alert('foo');/* eslint-enable */**// 특정 규칙 경고 비활성화**/* eslint-disable no-alert, no-console */alert('foo');console.log('bar');**// 다음 한줄 경고 비활성화**// eslint-disable-next-line 참고Configuring ESLint - ESLint - Pluggable JavaScript Linter https://velog.io/@kyusung/eslint-config-2 ESLint 알고 쓰기","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ESLint-1-22-07-07/"},{"title":"[JS] 프로토타입 간단 정리","text":"이채현 💡 Javascript Prototype 자바스크립트는 프로토타입 기반의 언어다. constructor (생성자)12345678910function Person(name, age) { this.name = name; this.age = age;}class Paerson { constructor() { }} 생성자함수는 프로토타입이 모든 자바스크립트에 들어있듯이 생성자도 모든 자바스크립트에서 확인가능하다. 12345const one = new Person('one', 1);const two = new Person('two', 2);console.log(one.constructor); // [Function: Person]console.log(two.constructor.name); // Person 어떠한 생성자로부터 생성되었는지 유추할 수 있다. instanceof로 식별 object instanceof constructor proto브라우저에서 비표준으로 제공했던… 1array.__proto__ ...로 array의 프로토타입에 접근 자바스크립트의 프로토타입에 직접 접근이 아니라 접근제어자로 접근할 수 있도록 도와주는 것으로 생각하면 됨. ⇒ 하지만 사용하지 않는 것이 좋음 ECMA Script2015부터는 표준화 된 getPrototypeOf() setPrototypeOf() 를 사용하는 것을 추천 프로토타입 체인123456789const animal = { sayName() { return 'ANIMAL'; }}console.log(animal.sayName()); // ANIMALconst dog = Object.create(animal);console.log(dog.sayName()); // ANIMAL 프로토타입 확장 (extends, 상속)부모 ⇒ 자식 … 상속보단 확장이란 개념이 더 이해하기 쉽다. 부모가 가진 기능보다 자식이 더 많이 가질 수 있기 때문 123456789101112131415161718192021222324252627282930// Super Classfunction Animal(name, sound) { this.name = name this.sound = sound;}Animal.prototype.getInfo = function () { return this.name + '가(이)' + this.sound + '소리를 낸다.';}// Sub Classfunction Friends(name, sound) { Animal.call(this, name, sound); // 명시적 바인딩 -&gt; Animal함수의 this를 Friends로 바인딩}Friends.prototype = Object.create(Animal.prototype);Friends.prototype.constructor = Friends;const dog = new Friends('개', '멍멍');const cat = new Friends('고양이', '냐옹');console.log(dog.getInfo()); // 개가(이)멍멍소리를 낸다.console.log(cat.getInfo()); // 고양이가(이)냐옹소리를 낸다.-------dog.contructor.name // Friendsdog instanceof Friends // truedog instanceof Animal // true","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-Prototype-1-22-02-10/"},{"title":"[JS] 스코프 간단 정리","text":"이채현 💡 Javascript Scope 전역 스코프 (Global) 그냥 가장 바깥쪽 언제 어디서나 접근 가능하기 때문에 재정의가 가능하다 ← 큰 문제 그 결과, 프로그램의 실행 결과 때 내가 만든 변수들의 결과를 예측하기 어려워짐 → 팀 단위로 개발할 때 최악 지역 스코프함수 스코프블록 스코프123456789{// 블록}function func() { // 함수 스코프 블록}if (true) { // 블록 스코프 블록} 전역 객체브라우저⇒ window NodeJS⇒ Global // this 브라우저에서 호출하면 window불러옴 호이스팅 (Hoisting)123456789function foo() { console.log(hoist); // undefined var hoist = '호이스팅'; console.log(hoist); // 호이스팅}foo(); 첫번 째 console.log가 오류나지 않는 이유는 변수 선언을 직접적으로 끌어올림 그래서 위 코드와 아래 코드랑 같다. 123456789function foo() { var hoist; // 1. 변수 선언 console.log(hoist); // undefined // 2. 실행 hoist = '호이스팅'; // 3. 재할당 console.log(hoist); // 호이스팅}foo(); 애초부터 var를 안쓰면 된다. 123456789function foo() { console.log(hoist); // Cannnot access 'hoist' before initialization let/const hoist = '호이스팅'; console.log(hoist); // 호이스팅}foo(); // Cannnot access 'hoist' before initialization 임시적 사각지대 (TDZ)가 생긴다. 내부적으로 호이스팅이 일어나지만, 사용자에게는 보이지 않는것처럼 에러를 준다. IIFE (즉시 실행 함수 표현)123456789101112131415function func() {}func();==&gt;(function () { })();(function (num) { console.log(num); // 1})(1); 함수를 괄호안에 넣고 바로 실행 함수 공간을 완전히 분리할 수 있기 때문에 사용한다. 그래서 let/const가 없을 때에 사람들이 외부에서 접근할 수 없게 블록스코프를 흉내내게 사용했다.","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-Scope-1-22-02-10/"},{"title":"[JS] Object 객체","text":"이채현 💡 Javascript Object 객체 생성일반적으로 생성 할 수 있는 객체 싱글 리터럴 (Literal) 객체1234const object = { property: 'value', method: function () {},} 생성자 함수 객체 // PascalCase12345function NewObject(name) { this.name = name;}const newObject = new NewObject(’Lee’); 파스칼 케이스 → 암묵적, 명시적 생성자 함수 Object.Create()123456789101112131415const newObject2 = Object.create(Object.prototype, { name: { value: 'lee', writable: true, // 덮어쓸 수 있는지 enumerable: true, // forin문과 같은 것으로 열거할 수 있는지 configurable: true, // 객체 기술자를 수정할 수 있는지 },});// const newObject2 = Object.create(프로토타입, 객체 서술자(기술자));newObject2.name = 'Kim';for (const key in newObject2) { console.log(key);} 프로퍼티 열거12345678910111213141516171819const obj = { prop1: 'value1', prop2: 'value2', prop3: 'value3', prop4: 'value4',};const prop = 'prop';const prop1 = 'prop1';obj.prop1 // value1obj['prop1'] // value1obj[prop + 1] // value1obj[prop1] // value1for (const key in obj) { console.log(key); // prop1, prop2, prop3, prop4 console.log(obj[key]); // value1, value2, value3, value4} 체인닝 방지를 위해블록 스코프 내에 변수가 없으면 그 위로 찾아 간다… 123456for (const key in obj) { if (obj.hasOwnProperty(key)) { console.log(obj[key]); // value1, value2, value3, value4 }}// 상속되거나 확장되어 사용 된 객체의 상위에서 꺼내오지 않도록 하는 방어문 프로퍼티 조작123456789101112131415const person = { firstName: &quot;Chaehyeon&quot;, location: &quot;Korea&quot;,}// 추가person.lastName: &quot;Lee&quot;// 수정person.lastName: &quot;lee&quot;// 삭제delet person.location;person; // { firstName: &quot;Chaehyeon&quot;, lastName: &quot;lee&quot; }// const는 재할당을 막는 것... 그래서 가능 프로퍼티 접근자 (getter, setter)123456789101112131415161718192021222324252627282930// 추가, 수정, 삭제 등을 접근해서 조작할 때 안전하게 하기 위해const person = { _firstName: &quot;Chaehyeon&quot;, lastName: &quot;Lee&quot;, get firstName() { return this._firstName.toUpperCase(); } set firstName(newFirstName) { if (typeof newFirstName !== 'string') { this._firstName = 'undefinedName'; return; } this._firstName = newFirstName; } get fullName() { return this._firstName + this.lastName + '입니다'. }}// console.log(person.firstName); // CHAEHYEON// console.log(person.fullName); // LeeChaehyeon입니다person.firstName = 12345;console.log(person.firstName); // UNDEFINDEDNAME 인스턴스OOP 인스턴스 === 유일한, 고유한 객체? 객체 하나하나가 곧 인스턴스이다. 123456789101112131415161718const me = { name: 'chaehyeon', age: 26, locaiton: 'korea',};const me2 = { name: 'chaehyeon', age: 26, locaiton: 'korea',};console.log(me === me2); // falseconsole.log(me.name === me2.name); // true// 객체 그 자체를 비교할 때에는 객체의 메모리 주소를 본다.// 당연히 메모리주소는 다르다 생성자1234567891011121314151617181920212223const me = { name: 'chaehyeon', age: 26, locaiton: 'korea',};// 객체를 자주 만들고 싶을 때 -&gt; 생성자 함수function Person(name, age, location) { this.name = name; this.age = age; this.location = location; this.getName = function () { return this.name + ' 입니다'; }}// 여기서 this는 &quot;생성 될&quot; 인스턴스를 가리킨다.const me2 = new Person('ChaehyeonLee', 26, 'korea');// Person { name: 'ChaehyeonLee', age: 26, location: 'korea' }const you new Person('Kim', 20, 'korea');// Person { name: 'Kim', age: 20, location: 'korea' }","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-Object-1-22-02-02/"},{"title":"[JS] this 간단 정리","text":"이채현 💡 Javascript this JavaScript에서 함수의 this 키워드는 다른 언어와 조금 다르게 동작한다. 엄격모드와 비엄격 모드에서도 일부 차이가 있다. this는 scope와 관계가 있다. 객체에도 영향을 준다. this가 어디에 묶여있냐를 아는 것이 코드를 작성하는 시점, 동작하는 시점에 차이가 있을 수 있다. (함수를 어떻게 호출했는지 상관하지 않고 this값을 설정할 수 있는 bind메서드를 도입했고, ES2015는 스스로의 this 바인딩을 제공하지 않는 화살표 함수 를 추가했습니다.) 암시적 바인딩암시적인 this 바인딩.. 사용자가 생각하지 않은대로 동작할 수 있다. 전역 공간에서의 this node.js 환경에서의 this는 global 브라우저에서의 this는 window 함수 함수에서의 this는 window ⇒ 전역공간에서의 this와 다르지 않다. 객체 (메서드) this는 호출되는 대상의 객체를 가리키고 있다. 12345678const obj = { name: 'obj', method: function() { return this.name }}obj.method() // 'obj' 명시적 바인딩 call(), bind(), apply() 12345678910111213const person = { name: 'Lee', sayName: function () { return this.name + '입니다'; }}const zero = { name: '베이스', sayName: function () { return this.name + '입니다'; }} call() 12345function sayFullName(firstName) { return firstName + this.sayName()}const result = sayFullName.call(person, 'Chaehyeon ');// Chaehyeon Lee입니다. apply() 123456function sayFullName(firstName) { return arguments[1] + this.sayName()}const result = sayFullName.apply(person, ['Chaehyeon ','채현 ']);// 채현 Lee입니다. bind() this를 묶어서 사용가능한다. React Class Component에서 사용했다. 123456789function sayFullName(firstName) { return firstName + this.sayName()}const sayFullNamePerson = sayFullName.bind(person);const sayFullNameZero = sayFullName.bind(zero);console.log(sayFullNamePerson('Chaehyeon'));// ChaehyeonLee입니다","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-This-1-22-02-10/"},{"title":"[React] React의 setState는 비동기로 동작한다","text":"이채현 💡 React의 setState는 비동기일까? 123456789101112131415161718192021222324function App() { const [state, setState] = useState(0); const handleClick = () =&gt; { setState(state + 1); setState(state + 1); setState(state + 1); }; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;{state}&lt;/p&gt; &lt;button onClick={() =&gt; { handleClick(); }} &gt; +3 &lt;/button&gt; &lt;/div&gt; );}export default App; 위 코드의 결과는 버튼을 눌러도 1씩 증가한다. 이유는? 💡 하나의 페이지나 컴포넌트 내에도 수많은 상태값이 존재한다. 만약 이 상태 하나하나가 바뀔 때마다 화면을 리렌더링 한다면 문제가 생길수도 있다. 때문에 리액트는 성능의 향상을 위해서 setState를 연속 호출하면 배치 처리하여 한 번에 렌더링하도록 하였다. 아무리 많은 setState가 연속적으로 사용되었어도 배치 처리에 의해서 한 번의 렌더링으로 최신 상태를 유지하는 것이다. 결국, 위 코드는 setState 는 동일한 key 값에 대하여 이전의 값을 계속해서 덮어써서, 마지막 명령어만 수행되는 셈이다. setState를 동기적으로 처리하려면!setState의 인자로 함수를 집어넣는 것이다. 1234567...const handleClick = () =&gt; { setState((prevState) =&gt; prevState + 1); setState((prevState) =&gt; prevState + 1); setState((prevState) =&gt; prevState + 1); };... 위와 같이 작성하면 setState 내 함수의 매개변수로 이전 상태 값이 들어오므로, 동기적으로 동작하는 것을 확인할 수 있다. 이제 한번의 버튼 클릭으로 카운트가 3씩 증가하는 것을 볼 수 있다. 결론 💡 - useState는 비동기적으로 동작하는 훅이다. 비동기적으로 동작하는 이유는 성능 최적화 때문이며, setState를 배치처리한다. useState를 동기적으로 처리하는 간단한 방법으로 인자에 함수를 넣는다.","link":"/categories/%EC%9B%B9%EC%95%B1/React/REACT-setState-1-22-06-27/"},{"title":"왜 클래스 기반 ZebraLabelService를 선택했는가","text":"Zebra 라벨 프린터 통합: 왜 클래스 기반 ZebraLabelService를 선택했는가 “React 생태계에서 굳이 클래스를?”하드웨어(프린터)를 다룰 때는 이야기가 달라집니다. 단일 연결, 복잡한 초기화, 상태/리소스 수명 주기… 이 모든 것을 안전하고 일관되게 관리해야 합니다.본 글은 실제 프로덕션에서 Zebra 라벨 프린터를 통합하며 내린 결정—클래스 기반 싱글톤 서비스—의 이유와 구현을 원문 코드 중심으로 정리한 내용입니다. 문제 정의와 선택 배경Zebra 라벨 프린터 통합은 하드웨어라는 단일·희소 자원을 다룹니다. 동시에 웹 앱(특히 React)에서는 화면 전환/재렌더링, 비동기 초기화, 중복 호출이 일어나기 쉽죠.다음 요구사항이 핵심이었습니다: 싱글 연결: 물리 프린터는 사실상 단일 연결/세션 가정이 안전 상태 일관성: 앱 전역에서 동일한 프린터/연결 상태 공유 초기화 중복 방지: 비동기 초기화 경쟁 조건(Race Condition) 제거 명확한 라이프사이클: 초기화 → 사용(출력) → 정리의 수명 주기 캡슐화 따라서 클래스 기반 싱글톤 서비스가 자연스러운 해법. 함수 vs 클래스함수형 예시1234567891011121314151617181920212223// ❌ 문제가 될 수 있는 함수형 접근let browserPrint: ZebraBrowserPrintWrapper | null = null; // 전역 변수let isInitialized = false;let selectedPrinter: ZebraDevice | null = null;export const createPrinterService = () =&gt; { return { initialize: async () =&gt; { /* ... */ }, printLabel: async () =&gt; { /* ... */ }, cleanup: () =&gt; { /* ... */ }, };};// 문제점들:const service1 = createPrinterService(); // 독립적 인스턴스const service2 = createPrinterService(); // 또 다른 독립적 인스턴스// → 하드웨어 리소스 충돌 가능성 단점: 함수형으로는 인스턴스 통제와 프라이빗 상태 보호가 약하고, 전역 모듈 상태는 캡슐화에 불리합니다. 클래스 기반 예시12345678910111213141516export class ZebraLabelService { // ✅ 캡슐화된 상태 private static instance: ZebraLabelService; private browserPrint: ZebraBrowserPrintWrapper | null = null; // ✅ 인스턴스 제어 private constructor() {} static getInstance(): ZebraLabelService { /* ... */ } // ✅ 타입 안전성 async ensurePrinterReady(): Promise&lt;void&gt; { /* ... */ }} 장점: 상태 캡슐화 &amp; 은닉 싱글톤으로 유일 인스턴스 보장 this 컨텍스트로 상태 일관 접근 타입 안전성 확보 왜 싱글톤인가?1. 하드웨어 리소스 충돌 방지, 2) 전역 상태 일관성, 3) 메모리/초기화 비용 절감, 4) 초기화 재사용. 서비스 레이어 아키텍처와 의존성 관리프레젠테이션(UI)과 비즈니스 로직을 분리한 Service Layer 패턴을 채택합니다. 12345// Service Layer (Business Logic)ZebraLabelService.getInstance().printSeparateLabels(asset);// Presentation Layer (React Hook)const {printSeparateLabels, isInitialized} = useAssetLabelOutput(); 의존성 생성 지점을 초기화 시점으로 미루는 형태: 12345// 외부 의존성을 생성자가 아닌 메서드에서 주입async initialize(options: PrinterInitOptions = {}) { this.browserPrint = new ZebraBrowserPrintWrapper(); // ...} 테스트 시 Mock 주입 용이 교체 가능성 확보 단계별 실용 가이드1) 중복 초기화 방지: Promise 캐싱123456789101112131415161718async initialize(options: PrinterInitOptions = {}): Promise&lt;boolean&gt; { // 이미 초기화된 경우 if (this.isInitialized &amp;&amp; this.selectedPrinter &amp;&amp; this.browserPrint) { return true; } // 초기화 진행 중인 경우 - Promise 재사용 if (this.initPromise) { return this.initPromise; } // 새로운 초기화 시작 this.initPromise = this.performInitialization(options); const result = await this.initPromise; this.initPromise = null; return result;} 효과: 동시 호출에서도 단 한 번만 초기화 수행 장점: 리소스 절약, Race Condition 예방 2) 상태 기반 사전 검증: fail-fast1234567891011121314151617async ensurePrinterReady(): Promise&lt;void&gt; { if (!this.isInitialized || !this.browserPrint) { throw new Error('프린터가 초기화되지 않았습니다'); } const status = await this.checkPrinterStatus(); if (!status.isConnected) { throw new Error(`프린터가 연결되지 않았습니다: ${status.errorMessage}`); } if (!status.isReady) { throw new Error('프린터가 준비되지 않았습니다. 프린터 상태를 확인하고 용지와 리본을 점검해주세요.'); }} 명확한 전제조건 확인 친절한 에러 메시지로 문제 지점 즉시 파악 3) 수명 주기(Lifecycle) 명료화123456789// 초기화async initialize(options: PrinterInitOptions = {}): Promise&lt;boolean&gt;// 사용async printSeparateLabels(asset: AssetLabelData): Promise&lt;boolean&gt;async ensurePrinterReady(): Promise&lt;void&gt;// 정리cleanup(): void 초기화 → 사용 → 정리의 경로가 코드 레벨에서 분명 UI/로직 레이어가 이 계약을 신뢰하고 사용 가능 성능/메모리 관점 구현 방식 인스턴스 수 메모리 사용량 초기화 비용 함수형 (팩토리) N개 N × 기본메모리 N × 비용 클래스형 (싱글톤) 1개 1 × 기본메모리 1 × 비용 싱글톤은 단 한 번 초기화로 비용/부하를 낮추고, GC 압박도 줄입니다. React Hook과의 통합 &amp; 에러 처리 일관성Hook 통합 예시 (UI는 UI만, 서비스는 로직만) 1234567891011121314151617// useAssetLabelOutput.ts에서의 사용const printSeparateLabels = useCallback( async (asset: AssetLabelData): Promise&lt;boolean&gt; =&gt; { if (!isInitialized) { await initializePrinter(); } setIsPrinting(true); try { const service = ZebraLabelService.getInstance(); // 싱글톤 접근 return await service.printSeparateLabels(asset); } finally { setIsPrinting(false); } }, [isInitialized, initializePrinter, modals],); 책임 분리가 뚜렷: Hook은 상태/인터랙션, Service는 비즈니스 로직 에러 처리 표준화 123456789// 모든 메서드에서 일관된 에러 처리try { await this.ensurePrinterReady(); // 실제 작업 수행} catch (error) { const printError = createPrintError(error, {tagNo, assetId}); logServerError(printError); throw printError;} 로그 포맷/전송 일관성 상위(UI)로 의미 있는 예외만 전달 의사결정 매트릭스 &amp; 권장 사항클래스 기반 싱글톤을 권장하는 상황 단일 하드웨어 또는 외부 리소스와 연결(프린터, 스캐너, 시리얼 장치 등) 초기화 비용이 크고 재사용 가치가 높은 경우 앱 전역에서 동일한 상태/연결을 공유해야 할 때 Race Condition과 중복 초기화를 반드시 피해야 할 때 주의/한계전역 싱글톤 남용은 테스트 격리/병렬성 저하를 유발 가능→ 본 설계는 테스트에서 Mock 주입 경로(초기화 시점 의존성 생성)로 이 문제를 최소화 실전 체크리스트 초기화는 반드시 한 번만: initPromise로 동시 호출 수렴 모든 퍼블릭 메서드 전에 ensurePrinterReady 선행 검증 Hook에서는 UI 상태(로딩/에러/완료)만 관리 에러 포맷/로깅 일관성 유지 cleanup() 경로 마련: 페이지 이탈/앱 종료 시 안전 해제 테스트에서 Mock 가능한 경계(래퍼/드라이버 주입 지점) 확보 결론클래스 기반 싱글톤 ZebraLabelService는 하드웨어 통합의 현실적 제약(단일 연결, 비싼 초기화, 복잡한 상태/수명 주기)을 안전하게 캡슐화하고React UI와는 느슨하게 결합해 유지보수성/재사용성/테스트 용이성을 모두 확보합니다. 서비스 레이어(비즈니스 로직) ↔ Hook 레이어(UI 상태) ↔ 컴포넌트 레이어(UI 렌더)의 관심사 분리가 명확해져 실무에서 바로 적용 가능한 구조를 제공합니다.","link":"/categories/%EC%9B%B9%EC%95%B1/React/react-why_use_class-1-250827/"},{"title":"함수형도 싱글톤 되잖아요? 그럼에도 클래스를 택한 이유","text":"“함수형도 싱글톤 만들 수 있는데요?”맞습니다. 기술적으로 가능합니다.하지만 저는 단순히 ‘싱글 인스턴스’를 만드는 것만으로는 부족했습니다.본 글은 지난 “왜 클래스 기반 ZebraLabelService를 선택했는가” 글에 이은 후속 글 입니다. 함수형도 싱글톤이 될 수 있습니다사실 함수형으로도 싱글톤은 만들 수 있습니다. 1234567891011121314151617181920// 함수형 싱글톤 패턴 (즉시 실행 함수)const PrinterService = (() =&gt; { let isInitialized = false; return { async initialize() { if (!isInitialized) { // 초기화 작업 isInitialized = true; } }, async print() { if (!isInitialized) throw new Error('초기화 필요'); // 인쇄 작업 }, cleanup() { isInitialized = false; }, };})(); 이렇게 구현하면 모듈 자체가 싱글 인스턴스처럼 동작하므로 기본적인 싱글톤 조건은 충족합니다. 하지만 ‘기술적으로 된다’와 ‘현실에 적합하다’는 다릅니다.함수형 싱글톤도 구현은 되지만, 프린터와 같은 하드웨어 통합 환경에서는 아래와 같은 이유로 클래스 기반 설꼐가 더 적합했습니다. 클래스 기반이 더 적합했던 이유1. 상태 은닉과 캡슐화의 명확성 함수형에서는 상태가 클로저 안에 숨어있고, 테스트나 디버깅 시 추적이 어렵습니다. 클래스에서는 상태가 명시적으로 필드로 존재하며, 추적과 주입이 쉽습니다. 1234// 클래스class ZebraLabelService { private browserPrint: ZebraBrowserPrintWrapper | null = null;} → 코드를 보는 순간, 어떤 상태를 갖고 있는지 명확합니다. 함수 vs 클래스 2. 의존성 주입 시점 통제1234// 클래스에서는 메서드 단위 주입 가능async initialize() { this.browserPrint = new ZebraBrowserPrintWrapper(); // 여기서 주입} 생성자나 메서드에서 외부 객체를 주입받을 수 있어 Mock 테스트가 수월 함수형은 클로저 내에서 의존성을 고정하거나 외부에서 따로 관리해야 함 → 유연성 떨어짐 3. 초기화 중복 방지(Promise 캐싱) 구조가 깔끔함123456789// 클래스 예시async initialize(): Promise&lt;boolean&gt; { if (this.initPromise) return this.initPromise; this.initPromise = this.performInitialization(); const result = await this.initPromise; this.initPromise = null; return result;} 클래스에서는 비동기 초기화 중복 호출을 방지하는 로직을 인스턴스 내부에 안전하게 구현할 수 있음 함수형은 별도 상태 관리 또는 모듈 스코프 변수가 필요 → 명확한 책임 분리가 어려움 4. 명확한 수명 주기 관리12345// 클래스 기반 수명 주기initialize()ensurePrinterReady()printSeparateLabels()cleanup() 클래스에서는 수명 주기 메서드가 한 객체 안에서 명확하게 정의되어 있어, 사용하는 쪽에서는 사용 규약을 명확히 따를 수 있음 함수형 모듈은 내부에 상태를 숨기다 보면 초기화/해제 로직이 분산되기 쉽습니다. 5. 확장성과 인터페이스 구현의 유리함 클래스 기반 서비스는 IPrinterService 등의 인터페이스 구현이 자연스럽고 테스트 시 Mock 클래스로 교체하기도 용이합니다. 123class MockZebraLabelService implements IPrinterService { /* 테스트용 로직 */} → 구조적 유연성에서 함수형보다 객체지향 방식이 확장에 유리 함수형 싱글톤은 ‘가능’, 클래스 기반은 ‘현실적’ 비교 항목 함수형 싱글톤 클래스 기반 싱글톤 싱글 인스턴스 보장 가능 (모듈/클로저로) 가능 (static 필드) 상태 관리 클로저 기반, 추적 어려움 명시적 필드, 디버깅 용이 초기화/해제 관리 외부 분산될 수 있음 라이프사이클 메서드로 일관 의존성 주입 어려움 (클로저 바깥 주입 필요) 용이 (생성자/메서드 주입) 테스트/Mock 용이성 낮음 높음 설계 유연성/확장성 낮음 높음 결론React 기반에서도 대부분 함수형으로 충분합니다.하지만, 프린터처럼 하드웨어 리소스 통합과 상태 일관성이 중요한 환경에서는 단순히 ‘싱글 인스턴스를 만들 수 있다’는 수준의 함수형 접근은 한계가 있습니다. 클래스 기반 싱글톤은 기능뿐 아니라 책임, 수명 주기, 상태, 의존성까지 안전하게 감싸는 구조입니다. 이러한 이유로 우리는 함수형 싱글톤이 가능함에도 불구하고,클래스 기반 싱글톤을 선택했습니다. 기억해두면 좋은 체크리스트 함수형이 싱글톤 구현이 가능한 건 맞다 하지만 클래스는 캡슐화, 라이프사이클, 테스트성까지 아우른다 하드웨어 통합에서는 초기화/상태/의존성 관리가 핵심이다 클래스 기반은 책임 분리가 명확하여 협업/유지보수에 유리하다","link":"/categories/%EC%9B%B9%EC%95%B1/React/react-why_use_class-2-250828/"},{"title":"[JS] ES2022 신기능 중 4가지","text":"이채현 💡 Javascript ES2022 신기능 4가지 노션에서 보기 Top level await기존 await를 사용하려면 async 함수 내에서만 가능했다. 123(async function () { await foo();})(); 하지만, ES2022부터 이러한 규칙이 사라지고, await를 async함수없이 모듈에서 아래와 같이 작성가능해졌다. 1await foo(); Error Cause이 기능을 통해 오류의 원인을 설명하여, 더 나은 오류 메시지를 만들 수 있다. 기존 오류를 만들 때는 오류 메시지를 작성하는 것 밖에 할 수 없었다. 1new Error(&quot;This is the Error Message!&quot;); 하지만 ES2022부터 무엇이 오류를 발생시켰는지에 대해 설명할 수 있다. 그래서 정확히 무엇이 잘못되었는지 구체적으로 알 수 있으며, 동일한 오류메시지를 사용하지만 다른 원인을 작성할 수 있다. 또한, .cause를 액세스할 수 있다. 1234const err = new Error(&quot;This is the Error Message!&quot;, { cause: &quot;Test Message&quot; });err.message; // This is the Error Message!err.cause; // Test Message .at().at을 활용하면, 배열의 모든 인덱스에 액세스할 수 있다. 123const number = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;];number.at(2); // 2 이전에도 대괄호를 사용하여 액세스할 수 있었지만, 대괄호와의 차이점은 뒤로 검색가능하다는 점이다. 대괄호는 -1 로 검색할 수 없었지만, .at을 통하면 가능하다. 12345const number = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;];number.at(2); // 2nubmer.at(-1); // 5~~number[-1]; // 불가능~~ Class Fields이것을 통해, 자바스크립트가 조금 더 OOP스럽게 느껴지게 한다. 이전에는 불가능했던 Private 메서드 및 속성을 가질 수 있으며, static 메서드를 사용할 수 있다. 그리고 속성을 초기화하기 위해 constructor를 사용할 필요도 없어진다. Private 메서드 및 속성private 메서드나 속성을 만들려면 이름 앞에 # 기호를 사용하면 된다. 123456789101112class Message { #destruct() { console.log(&quot;booom!!&quot;); }}const but = new Message();~~btn.#destruct(); // 작동하지 않는다~~class Message { #text = &quot;Hi&quot;;} 위 코드처럼 private한 메서드 및 텍스트를 만들 수 있으며, constructor를 사용하지 않는다. 12345class Message { constructor() { this.text = &quot;Hi&quot;; }} Static 메서드123456789101112131415class Message { // body}Message.build(){ // body}====class Message { static build() { // body }} 출처 방금 출시된 ⚡️자바스크립트 미친 신기능 4개!","link":"/categories/%EC%9B%B9%EC%95%B1/Javascript/JS-ES2022-1-22-07-11%20/"}],"tags":[{"name":"리눅스","slug":"리눅스","link":"/tags/%EB%A6%AC%EB%88%85%EC%8A%A4/"},{"name":"우분투","slug":"우분투","link":"/tags/%EC%9A%B0%EB%B6%84%ED%88%AC/"},{"name":"압축","slug":"압축","link":"/tags/%EC%95%95%EC%B6%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"개발자블로그","slug":"개발자블로그","link":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"컨퍼런스후기","slug":"컨퍼런스후기","link":"/tags/%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4%ED%9B%84%EA%B8%B0/"},{"name":"개발자일상","slug":"개발자일상","link":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%BC%EC%83%81/"},{"name":"기술블로그시작","slug":"기술블로그시작","link":"/tags/%EA%B8%B0%EC%88%A0%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%8B%9C%EC%9E%91/"},{"name":"FECConf2025","slug":"FECConf2025","link":"/tags/FECConf2025/"},{"name":"백준","slug":"백준","link":"/tags/%EB%B0%B1%EC%A4%80/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"자바스크립트","slug":"자바스크립트","link":"/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Devops","slug":"Devops","link":"/tags/Devops/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"EC2","slug":"EC2","link":"/tags/EC2/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"계정생성","slug":"계정생성","link":"/tags/%EA%B3%84%EC%A0%95%EC%83%9D%EC%84%B1/"},{"name":"권한관리","slug":"권한관리","link":"/tags/%EA%B6%8C%ED%95%9C%EA%B4%80%EB%A6%AC/"},{"name":"계정삭제","slug":"계정삭제","link":"/tags/%EA%B3%84%EC%A0%95%EC%82%AD%EC%A0%9C/"},{"name":"RPI","slug":"RPI","link":"/tags/RPI/"},{"name":"라즈베리파이","slug":"라즈베리파이","link":"/tags/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"CRIU","slug":"CRIU","link":"/tags/CRIU/"},{"name":"container","slug":"container","link":"/tags/container/"},{"name":"checkpoint","slug":"checkpoint","link":"/tags/checkpoint/"},{"name":"Fastlane","slug":"Fastlane","link":"/tags/Fastlane/"},{"name":"패스트래인","slug":"패스트래인","link":"/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EB%9E%98%EC%9D%B8/"},{"name":"앱","slug":"앱","link":"/tags/%EC%95%B1/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"빌드","slug":"빌드","link":"/tags/%EB%B9%8C%EB%93%9C/"},{"name":"자동화","slug":"자동화","link":"/tags/%EC%9E%90%EB%8F%99%ED%99%94/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"그래프","slug":"그래프","link":"/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"},{"name":"그래프 탐색","slug":"그래프-탐색","link":"/tags/%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89/"},{"name":"너비 우선 탐색","slug":"너비-우선-탐색","link":"/tags/%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89/"},{"name":"깊이 우선 탐색","slug":"깊이-우선-탐색","link":"/tags/%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"수학","slug":"수학","link":"/tags/%EC%88%98%ED%95%99/"},{"name":"다이나믹 프로그래밍","slug":"다이나믹-프로그래밍","link":"/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"피보나치 수","slug":"피보나치-수","link":"/tags/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98/"},{"name":"그리디","slug":"그리디","link":"/tags/%EA%B7%B8%EB%A6%AC%EB%94%94/"},{"name":"그리디알고리즘","slug":"그리디알고리즘","link":"/tags/%EA%B7%B8%EB%A6%AC%EB%94%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"구현","slug":"구현","link":"/tags/%EA%B5%AC%ED%98%84/"},{"name":"브루트포스","slug":"브루트포스","link":"/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"},{"name":"문자열","slug":"문자열","link":"/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"해시","slug":"해시","link":"/tags/%ED%95%B4%EC%8B%9C/"},{"name":"집합","slug":"집합","link":"/tags/%EC%A7%91%ED%95%A9/"},{"name":"맵","slug":"맵","link":"/tags/%EB%A7%B5/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"스택","link":"/tags/%EC%8A%A4%ED%83%9D/"},{"name":"분할 정복","slug":"분할-정복","link":"/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/"},{"name":"선형대수학","slug":"선형대수학","link":"/tags/%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98%ED%95%99/"},{"name":"큐","slug":"큐","link":"/tags/%ED%81%90/"},{"name":"덱","slug":"덱","link":"/tags/%EB%8D%B1/"},{"name":"별","slug":"별","link":"/tags/%EB%B3%84/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"재귀","slug":"재귀","link":"/tags/%EC%9E%AC%EA%B7%80/"},{"name":"자료 구조","slug":"자료-구조","link":"/tags/%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"},{"name":"그리디 알고리즘","slug":"그리디-알고리즘","link":"/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"우선순위 큐","slug":"우선순위-큐","link":"/tags/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90/"},{"name":"이분 탐색","slug":"이분-탐색","link":"/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/"},{"name":"LIS","slug":"LIS","link":"/tags/LIS/"},{"name":"O(n log n)","slug":"O-n-log-n","link":"/tags/O-n-log-n/"},{"name":"백트래킹","slug":"백트래킹","link":"/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"},{"name":"우선순위큐","slug":"우선순위큐","link":"/tags/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90/"},{"name":"좌표 압축","slug":"좌표-압축","link":"/tags/%EC%A2%8C%ED%91%9C-%EC%95%95%EC%B6%95/"},{"name":"트리","slug":"트리","link":"/tags/%ED%8A%B8%EB%A6%AC/"},{"name":"시뮬레이션","slug":"시뮬레이션","link":"/tags/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"분할정복","slug":"분할정복","link":"/tags/%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5/"},{"name":"이분탐색","slug":"이분탐색","link":"/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/"},{"name":"누적 합","slug":"누적-합","link":"/tags/%EB%88%84%EC%A0%81-%ED%95%A9/"},{"name":"기하학","slug":"기하학","link":"/tags/%EA%B8%B0%ED%95%98%ED%95%99/"},{"name":"브루트포스 알고리즘","slug":"브루트포스-알고리즘","link":"/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"그래프 이론","slug":"그래프-이론","link":"/tags/%EA%B7%B8%EB%9E%98%ED%94%84-%EC%9D%B4%EB%A1%A0/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"코딩 테스트","slug":"코딩-테스트","link":"/tags/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"완전탐색","slug":"완전탐색","link":"/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"},{"name":"Bruteforce","slug":"Bruteforce","link":"/tags/Bruteforce/"},{"name":"힙","slug":"힙","link":"/tags/%ED%9E%99/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"},{"name":"카카오 인턴","slug":"카카오-인턴","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%9D%B8%ED%84%B4/"},{"name":"SWEA","slug":"SWEA","link":"/tags/SWEA/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Certbot","slug":"Certbot","link":"/tags/Certbot/"},{"name":"letsencrypt","slug":"letsencrypt","link":"/tags/letsencrypt/"},{"name":"인증서","slug":"인증서","link":"/tags/%EC%9D%B8%EC%A6%9D%EC%84%9C/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"key","slug":"key","link":"/tags/key/"},{"name":"id_rsa","slug":"id-rsa","link":"/tags/id-rsa/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"git한글깨짐","slug":"git한글깨짐","link":"/tags/git%ED%95%9C%EA%B8%80%EA%B9%A8%EC%A7%90/"},{"name":"IT뉴스","slug":"IT뉴스","link":"/tags/IT%EB%89%B4%EC%8A%A4/"},{"name":"IT Issues","slug":"IT-Issues","link":"/tags/IT-Issues/"},{"name":"주간IT정리","slug":"주간IT정리","link":"/tags/%EC%A3%BC%EA%B0%84IT%EC%A0%95%EB%A6%AC/"},{"name":"인앱결제","slug":"인앱결제","link":"/tags/%EC%9D%B8%EC%95%B1%EA%B2%B0%EC%A0%9C/"},{"name":"구글","slug":"구글","link":"/tags/%EA%B5%AC%EA%B8%80/"},{"name":"애플","slug":"애플","link":"/tags/%EC%95%A0%ED%94%8C/"},{"name":"앱스토어","slug":"앱스토어","link":"/tags/%EC%95%B1%EC%8A%A4%ED%86%A0%EC%96%B4/"},{"name":"branch","slug":"branch","link":"/tags/branch/"},{"name":"브랜치","slug":"브랜치","link":"/tags/%EB%B8%8C%EB%9E%9C%EC%B9%98/"},{"name":"클론","slug":"클론","link":"/tags/%ED%81%B4%EB%A1%A0/"},{"name":"clone","slug":"clone","link":"/tags/clone/"},{"name":"메타버스","slug":"메타버스","link":"/tags/%EB%A9%94%ED%83%80%EB%B2%84%EC%8A%A4/"},{"name":"VR","slug":"VR","link":"/tags/VR/"},{"name":"AR","slug":"AR","link":"/tags/AR/"},{"name":"네트워크","slug":"네트워크","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"클라우드","slug":"클라우드","link":"/tags/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C/"},{"name":"노동조합","slug":"노동조합","link":"/tags/%EB%85%B8%EB%8F%99%EC%A1%B0%ED%95%A9/"},{"name":"노조","slug":"노조","link":"/tags/%EB%85%B8%EC%A1%B0/"},{"name":"내 생각","slug":"내-생각","link":"/tags/%EB%82%B4-%EC%83%9D%EA%B0%81/"},{"name":"네이버","slug":"네이버","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84/"},{"name":"카카오","slug":"카카오","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4/"},{"name":"이커머스","slug":"이커머스","link":"/tags/%EC%9D%B4%EC%BB%A4%EB%A8%B8%EC%8A%A4/"},{"name":"패션","slug":"패션","link":"/tags/%ED%8C%A8%EC%85%98/"},{"name":"콘텐츠","slug":"콘텐츠","link":"/tags/%EC%BD%98%ED%85%90%EC%B8%A0/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"가상화폐","slug":"가상화폐","link":"/tags/%EA%B0%80%EC%83%81%ED%99%94%ED%8F%90/"},{"name":"채굴","slug":"채굴","link":"/tags/%EC%B1%84%EA%B5%B4/"},{"name":"그래픽카드","slug":"그래픽카드","link":"/tags/%EA%B7%B8%EB%9E%98%ED%94%BD%EC%B9%B4%EB%93%9C/"},{"name":"클라우드 게임","slug":"클라우드-게임","link":"/tags/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B2%8C%EC%9E%84/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"Transaction","slug":"Transaction","link":"/tags/Transaction/"},{"name":"트랜잭션","slug":"트랜잭션","link":"/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"name":"스프링","slug":"스프링","link":"/tags/%EC%8A%A4%ED%94%84%EB%A7%81/"},{"name":"스프링부트","slug":"스프링부트","link":"/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"자바","slug":"자바","link":"/tags/%EC%9E%90%EB%B0%94/"},{"name":"데이터베이스","slug":"데이터베이스","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"},{"name":"격리성","slug":"격리성","link":"/tags/%EA%B2%A9%EB%A6%AC%EC%84%B1/"},{"name":"ACID","slug":"ACID","link":"/tags/ACID/"},{"name":"Json","slug":"Json","link":"/tags/Json/"},{"name":"LG전자","slug":"LG전자","link":"/tags/LG%EC%A0%84%EC%9E%90/"},{"name":"MC사업부","slug":"MC사업부","link":"/tags/MC%EC%82%AC%EC%97%85%EB%B6%80/"},{"name":"넷플릭스","slug":"넷플릭스","link":"/tags/%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4/"},{"name":"IntelliJ","slug":"IntelliJ","link":"/tags/IntelliJ/"},{"name":"intellij","slug":"intellij","link":"/tags/intellij/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"Overloading","slug":"Overloading","link":"/tags/Overloading/"},{"name":"Overriding","slug":"Overriding","link":"/tags/Overriding/"},{"name":"톰캣","slug":"톰캣","link":"/tags/%ED%86%B0%EC%BA%A3/"},{"name":"WAS","slug":"WAS","link":"/tags/WAS/"},{"name":"웹서버","slug":"웹서버","link":"/tags/%EC%9B%B9%EC%84%9C%EB%B2%84/"},{"name":"학생인증","slug":"학생인증","link":"/tags/%ED%95%99%EC%83%9D%EC%9D%B8%EC%A6%9D/"},{"name":"Educational Licenses","slug":"Educational-Licenses","link":"/tags/Educational-Licenses/"},{"name":"Ultimate","slug":"Ultimate","link":"/tags/Ultimate/"},{"name":"빅테크","slug":"빅테크","link":"/tags/%EB%B9%85%ED%85%8C%ED%81%AC/"},{"name":"소셜미디어","slug":"소셜미디어","link":"/tags/%EC%86%8C%EC%85%9C%EB%AF%B8%EB%94%94%EC%96%B4/"},{"name":"자율주행","slug":"자율주행","link":"/tags/%EC%9E%90%EC%9C%A8%EC%A3%BC%ED%96%89/"},{"name":"인공지능","slug":"인공지능","link":"/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"요기요","slug":"요기요","link":"/tags/%EC%9A%94%EA%B8%B0%EC%9A%94/"},{"name":"크래프톤","slug":"크래프톤","link":"/tags/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4/"},{"name":"포괄임금제","slug":"포괄임금제","link":"/tags/%ED%8F%AC%EA%B4%84%EC%9E%84%EA%B8%88%EC%A0%9C/"},{"name":"갤럭시버즈프로","slug":"갤럭시버즈프로","link":"/tags/%EA%B0%A4%EB%9F%AD%EC%8B%9C%EB%B2%84%EC%A6%88%ED%94%84%EB%A1%9C/"},{"name":"로블록스","slug":"로블록스","link":"/tags/%EB%A1%9C%EB%B8%94%EB%A1%9D%EC%8A%A4/"},{"name":"샤오미","slug":"샤오미","link":"/tags/%EC%83%A4%EC%98%A4%EB%AF%B8/"},{"name":"전기차","slug":"전기차","link":"/tags/%EC%A0%84%EA%B8%B0%EC%B0%A8/"},{"name":"삼성전자","slug":"삼성전자","link":"/tags/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90/"},{"name":"CSR","slug":"CSR","link":"/tags/CSR/"},{"name":"AR글래스","slug":"AR글래스","link":"/tags/AR%EA%B8%80%EB%9E%98%EC%8A%A4/"},{"name":"OTT","slug":"OTT","link":"/tags/OTT/"},{"name":"아이폰","slug":"아이폰","link":"/tags/%EC%95%84%EC%9D%B4%ED%8F%B0/"},{"name":"삼성","slug":"삼성","link":"/tags/%EC%82%BC%EC%84%B1/"},{"name":"안드로이드폰","slug":"안드로이드폰","link":"/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%ED%8F%B0/"},{"name":"OLED","slug":"OLED","link":"/tags/OLED/"},{"name":"BOE","slug":"BOE","link":"/tags/BOE/"},{"name":"티맵","slug":"티맵","link":"/tags/%ED%8B%B0%EB%A7%B5/"},{"name":"우버","slug":"우버","link":"/tags/%EC%9A%B0%EB%B2%84/"},{"name":"우티","slug":"우티","link":"/tags/%EC%9A%B0%ED%8B%B0/"},{"name":"아마존","slug":"아마존","link":"/tags/%EC%95%84%EB%A7%88%EC%A1%B4/"},{"name":"헬스케어","slug":"헬스케어","link":"/tags/%ED%97%AC%EC%8A%A4%EC%BC%80%EC%96%B4/"},{"name":"라이브커머스","slug":"라이브커머스","link":"/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EC%BB%A4%EB%A8%B8%EC%8A%A4/"},{"name":"한글과컴퓨터","slug":"한글과컴퓨터","link":"/tags/%ED%95%9C%EA%B8%80%EA%B3%BC%EC%BB%B4%ED%93%A8%ED%84%B0/"},{"name":"ESG","slug":"ESG","link":"/tags/ESG/"},{"name":"디즈니","slug":"디즈니","link":"/tags/%EB%94%94%EC%A6%88%EB%8B%88/"},{"name":"롯데","slug":"롯데","link":"/tags/%EB%A1%AF%EB%8D%B0/"},{"name":"중고나라","slug":"중고나라","link":"/tags/%EC%A4%91%EA%B3%A0%EB%82%98%EB%9D%BC/"},{"name":"빅데이터","slug":"빅데이터","link":"/tags/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0/"},{"name":"컴퓨터보안","slug":"컴퓨터보안","link":"/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EB%B3%B4%EC%95%88/"},{"name":"해킹","slug":"해킹","link":"/tags/%ED%95%B4%ED%82%B9/"},{"name":"핀테크형 해외송금","slug":"핀테크형-해외송금","link":"/tags/%ED%95%80%ED%85%8C%ED%81%AC%ED%98%95-%ED%95%B4%EC%99%B8%EC%86%A1%EA%B8%88/"},{"name":"텐센트","slug":"텐센트","link":"/tags/%ED%85%90%EC%84%BC%ED%8A%B8/"},{"name":"위뱅크","slug":"위뱅크","link":"/tags/%EC%9C%84%EB%B1%85%ED%81%AC/"},{"name":"반도체","slug":"반도체","link":"/tags/%EB%B0%98%EB%8F%84%EC%B2%B4/"},{"name":"파운드리","slug":"파운드리","link":"/tags/%ED%8C%8C%EC%9A%B4%EB%93%9C%EB%A6%AC/"},{"name":"인텔","slug":"인텔","link":"/tags/%EC%9D%B8%ED%85%94/"},{"name":"채용","slug":"채용","link":"/tags/%EC%B1%84%EC%9A%A9/"},{"name":"가상현실","slug":"가상현실","link":"/tags/%EA%B0%80%EC%83%81%ED%98%84%EC%8B%A4/"},{"name":"빅테이터","slug":"빅테이터","link":"/tags/%EB%B9%85%ED%85%8C%EC%9D%B4%ED%84%B0/"},{"name":"당근","slug":"당근","link":"/tags/%EB%8B%B9%EA%B7%BC/"},{"name":"중고거래","slug":"중고거래","link":"/tags/%EC%A4%91%EA%B3%A0%EA%B1%B0%EB%9E%98/"},{"name":"SNS","slug":"SNS","link":"/tags/SNS/"},{"name":"코로나19","slug":"코로나19","link":"/tags/%EC%BD%94%EB%A1%9C%EB%82%9819/"},{"name":"DDR5","slug":"DDR5","link":"/tags/DDR5/"},{"name":"스타트업","slug":"스타트업","link":"/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"야놀자","slug":"야놀자","link":"/tags/%EC%95%BC%EB%86%80%EC%9E%90/"},{"name":"B2B","slug":"B2B","link":"/tags/B2B/"},{"name":"IPO","slug":"IPO","link":"/tags/IPO/"},{"name":"PMS","slug":"PMS","link":"/tags/PMS/"},{"name":"컨피덴셜 컴퓨팅","slug":"컨피덴셜-컴퓨팅","link":"/tags/%EC%BB%A8%ED%94%BC%EB%8D%B4%EC%85%9C-%EC%BB%B4%ED%93%A8%ED%8C%85/"},{"name":"카이스트","slug":"카이스트","link":"/tags/%EC%B9%B4%EC%9D%B4%EC%8A%A4%ED%8A%B8/"},{"name":"딥페이크","slug":"딥페이크","link":"/tags/%EB%94%A5%ED%8E%98%EC%9D%B4%ED%81%AC/"},{"name":"멜론","slug":"멜론","link":"/tags/%EB%A9%9C%EB%A1%A0/"},{"name":"유튜브뮤직","slug":"유튜브뮤직","link":"/tags/%EC%9C%A0%ED%8A%9C%EB%B8%8C%EB%AE%A4%EC%A7%81/"},{"name":"5G","slug":"5G","link":"/tags/5G/"},{"name":"한게임","slug":"한게임","link":"/tags/%ED%95%9C%EA%B2%8C%EC%9E%84/"},{"name":"IT노조","slug":"IT노조","link":"/tags/IT%EB%85%B8%EC%A1%B0/"},{"name":"한글과 컴퓨터","slug":"한글과-컴퓨터","link":"/tags/%ED%95%9C%EA%B8%80%EA%B3%BC-%EC%BB%B4%ED%93%A8%ED%84%B0/"},{"name":"DaaS","slug":"DaaS","link":"/tags/DaaS/"},{"name":"클라우드PC","slug":"클라우드PC","link":"/tags/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9CPC/"},{"name":"IP","slug":"IP","link":"/tags/IP/"},{"name":"웹툰","slug":"웹툰","link":"/tags/%EC%9B%B9%ED%88%B0/"},{"name":"웹소설","slug":"웹소설","link":"/tags/%EC%9B%B9%EC%86%8C%EC%84%A4/"},{"name":"웨이브","slug":"웨이브","link":"/tags/%EC%9B%A8%EC%9D%B4%EB%B8%8C/"},{"name":"디즈니플러스","slug":"디즈니플러스","link":"/tags/%EB%94%94%EC%A6%88%EB%8B%88%ED%94%8C%EB%9F%AC%EC%8A%A4/"},{"name":"네이버 주문","slug":"네이버-주문","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%A3%BC%EB%AC%B8/"},{"name":"네이버 페이","slug":"네이버-페이","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84-%ED%8E%98%EC%9D%B4/"},{"name":"국민비서","slug":"국민비서","link":"/tags/%EA%B5%AD%EB%AF%BC%EB%B9%84%EC%84%9C/"},{"name":"매그나칩","slug":"매그나칩","link":"/tags/%EB%A7%A4%EA%B7%B8%EB%82%98%EC%B9%A9/"},{"name":"DDI","slug":"DDI","link":"/tags/DDI/"},{"name":"노 테크데이","slug":"노-테크데이","link":"/tags/%EB%85%B8-%ED%85%8C%ED%81%AC%EB%8D%B0%EC%9D%B4/"},{"name":"샌드커맨드","slug":"샌드커맨드","link":"/tags/%EC%83%8C%EB%93%9C%EC%BB%A4%EB%A7%A8%EB%93%9C/"},{"name":"신세계","slug":"신세계","link":"/tags/%EC%8B%A0%EC%84%B8%EA%B3%84/"},{"name":"카카오모빌리티","slug":"카카오모빌리티","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EB%AA%A8%EB%B9%8C%EB%A6%AC%ED%8B%B0/"},{"name":"ML","slug":"ML","link":"/tags/ML/"},{"name":"머신러닝","slug":"머신러닝","link":"/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"},{"name":"ArmV9","slug":"ArmV9","link":"/tags/ArmV9/"},{"name":"ArmV8","slug":"ArmV8","link":"/tags/ArmV8/"},{"name":"배틀그라운드","slug":"배틀그라운드","link":"/tags/%EB%B0%B0%ED%8B%80%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C/"},{"name":"지그재그","slug":"지그재그","link":"/tags/%EC%A7%80%EA%B7%B8%EC%9E%AC%EA%B7%B8/"},{"name":"카카오커머스","slug":"카카오커머스","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%BB%A4%EB%A8%B8%EC%8A%A4/"},{"name":"개인정보","slug":"개인정보","link":"/tags/%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4/"},{"name":"개인정보 추적앱","slug":"개인정보-추적앱","link":"/tags/%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4-%EC%B6%94%EC%A0%81%EC%95%B1/"},{"name":"싸이월드","slug":"싸이월드","link":"/tags/%EC%8B%B8%EC%9D%B4%EC%9B%94%EB%93%9C/"},{"name":"쏘카","slug":"쏘카","link":"/tags/%EC%8F%98%EC%B9%B4/"},{"name":"센드버드","slug":"센드버드","link":"/tags/%EC%84%BC%EB%93%9C%EB%B2%84%EB%93%9C/"},{"name":"API 이코노미","slug":"API-이코노미","link":"/tags/API-%EC%9D%B4%EC%BD%94%EB%85%B8%EB%AF%B8/"},{"name":"전통주","slug":"전통주","link":"/tags/%EC%A0%84%ED%86%B5%EC%A3%BC/"},{"name":"술담화","slug":"술담화","link":"/tags/%EC%88%A0%EB%8B%B4%ED%99%94/"},{"name":"유니콘","slug":"유니콘","link":"/tags/%EC%9C%A0%EB%8B%88%EC%BD%98/"},{"name":"비상장","slug":"비상장","link":"/tags/%EB%B9%84%EC%83%81%EC%9E%A5/"},{"name":"금융","slug":"금융","link":"/tags/%EA%B8%88%EC%9C%B5/"},{"name":"핀테크","slug":"핀테크","link":"/tags/%ED%95%80%ED%85%8C%ED%81%AC/"},{"name":"마이데이터","slug":"마이데이터","link":"/tags/%EB%A7%88%EC%9D%B4%EB%8D%B0%EC%9D%B4%ED%84%B0/"},{"name":"웨어러블","slug":"웨어러블","link":"/tags/%EC%9B%A8%EC%96%B4%EB%9F%AC%EB%B8%94/"},{"name":"삼성SDS","slug":"삼성SDS","link":"/tags/%EC%82%BC%EC%84%B1SDS/"},{"name":"스페이셜","slug":"스페이셜","link":"/tags/%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%85%9C/"},{"name":"스마트폰","slug":"스마트폰","link":"/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%ED%8F%B0/"},{"name":"코로나","slug":"코로나","link":"/tags/%EC%BD%94%EB%A1%9C%EB%82%98/"},{"name":"하이퍼로컬","slug":"하이퍼로컬","link":"/tags/%ED%95%98%EC%9D%B4%ED%8D%BC%EB%A1%9C%EC%BB%AC/"},{"name":"당근마켓","slug":"당근마켓","link":"/tags/%EB%8B%B9%EA%B7%BC%EB%A7%88%EC%BC%93/"},{"name":"네이버웹툰","slug":"네이버웹툰","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84%EC%9B%B9%ED%88%B0/"},{"name":"카카오엔터프라이즈","slug":"카카오엔터프라이즈","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%97%94%ED%84%B0%ED%94%84%EB%9D%BC%EC%9D%B4%EC%A6%88/"},{"name":"지니","slug":"지니","link":"/tags/%EC%A7%80%EB%8B%88/"},{"name":"뉴스사용료","slug":"뉴스사용료","link":"/tags/%EB%89%B4%EC%8A%A4%EC%82%AC%EC%9A%A9%EB%A3%8C/"},{"name":"올림푸스","slug":"올림푸스","link":"/tags/%EC%98%AC%EB%A6%BC%ED%91%B8%EC%8A%A4/"},{"name":"페이스북","slug":"페이스북","link":"/tags/%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81/"},{"name":"인스타그램","slug":"인스타그램","link":"/tags/%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8/"},{"name":"광고","slug":"광고","link":"/tags/%EA%B4%91%EA%B3%A0/"},{"name":"바이두","slug":"바이두","link":"/tags/%EB%B0%94%EC%9D%B4%EB%91%90/"},{"name":"뱅크샐러드","slug":"뱅크샐러드","link":"/tags/%EB%B1%85%ED%81%AC%EC%83%90%EB%9F%AC%EB%93%9C/"},{"name":"KT","slug":"KT","link":"/tags/KT/"},{"name":"라인","slug":"라인","link":"/tags/%EB%9D%BC%EC%9D%B8/"},{"name":"빅블러","slug":"빅블러","link":"/tags/%EB%B9%85%EB%B8%94%EB%9F%AC/"},{"name":"카카오페이","slug":"카카오페이","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%8E%98%EC%9D%B4/"},{"name":"M1","slug":"M1","link":"/tags/M1/"},{"name":"BCI","slug":"BCI","link":"/tags/BCI/"},{"name":"뉴럴링크","slug":"뉴럴링크","link":"/tags/%EB%89%B4%EB%9F%B4%EB%A7%81%ED%81%AC/"},{"name":"소니픽처스","slug":"소니픽처스","link":"/tags/%EC%86%8C%EB%8B%88%ED%94%BD%EC%B2%98%EC%8A%A4/"},{"name":"NHN DATA","slug":"NHN-DATA","link":"/tags/NHN-DATA/"},{"name":"아이메시지","slug":"아이메시지","link":"/tags/%EC%95%84%EC%9D%B4%EB%A9%94%EC%8B%9C%EC%A7%80/"},{"name":"왓츠앱","slug":"왓츠앱","link":"/tags/%EC%99%93%EC%B8%A0%EC%95%B1/"},{"name":"카카오 바이크","slug":"카카오-바이크","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%B0%94%EC%9D%B4%ED%81%AC/"},{"name":"국가재난안전통신 전국망","slug":"국가재난안전통신-전국망","link":"/tags/%EA%B5%AD%EA%B0%80%EC%9E%AC%EB%82%9C%EC%95%88%EC%A0%84%ED%86%B5%EC%8B%A0-%EC%A0%84%EA%B5%AD%EB%A7%9D/"},{"name":"오라클","slug":"오라클","link":"/tags/%EC%98%A4%EB%9D%BC%ED%81%B4/"},{"name":"해커톤","slug":"해커톤","link":"/tags/%ED%95%B4%EC%BB%A4%ED%86%A4/"},{"name":"공인인증제도","slug":"공인인증제도","link":"/tags/%EA%B3%B5%EC%9D%B8%EC%9D%B8%EC%A6%9D%EC%A0%9C%EB%8F%84/"},{"name":"공인인증서","slug":"공인인증서","link":"/tags/%EA%B3%B5%EC%9D%B8%EC%9D%B8%EC%A6%9D%EC%84%9C/"},{"name":"전자서명법","slug":"전자서명법","link":"/tags/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85%EB%B2%95/"},{"name":"쿠팡","slug":"쿠팡","link":"/tags/%EC%BF%A0%ED%8C%A1/"},{"name":"우아한형제들","slug":"우아한형제들","link":"/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%98%95%EC%A0%9C%EB%93%A4/"},{"name":"배달의민족","slug":"배달의민족","link":"/tags/%EB%B0%B0%EB%8B%AC%EC%9D%98%EB%AF%BC%EC%A1%B1/"},{"name":"테슬라","slug":"테슬라","link":"/tags/%ED%85%8C%EC%8A%AC%EB%9D%BC/"},{"name":"기업복지","slug":"기업복지","link":"/tags/%EA%B8%B0%EC%97%85%EB%B3%B5%EC%A7%80/"},{"name":"NAS","slug":"NAS","link":"/tags/NAS/"},{"name":"랜섬웨어","slug":"랜섬웨어","link":"/tags/%EB%9E%9C%EC%84%AC%EC%9B%A8%EC%96%B4/"},{"name":"Q로커","slug":"Q로커","link":"/tags/Q%EB%A1%9C%EC%BB%A4/"},{"name":"네이버 웨일","slug":"네이버-웨일","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%9B%A8%EC%9D%BC/"},{"name":"M2","slug":"M2","link":"/tags/M2/"},{"name":"알리바바","slug":"알리바바","link":"/tags/%EC%95%8C%EB%A6%AC%EB%B0%94%EB%B0%94/"},{"name":"핀둬둬","slug":"핀둬둬","link":"/tags/%ED%95%80%EB%91%AC%EB%91%AC/"},{"name":"자율주행차","slug":"자율주행차","link":"/tags/%EC%9E%90%EC%9C%A8%EC%A3%BC%ED%96%89%EC%B0%A8/"},{"name":"에픽게임즈","slug":"에픽게임즈","link":"/tags/%EC%97%90%ED%94%BD%EA%B2%8C%EC%9E%84%EC%A6%88/"},{"name":"공유킥보드","slug":"공유킥보드","link":"/tags/%EA%B3%B5%EC%9C%A0%ED%82%A5%EB%B3%B4%EB%93%9C/"},{"name":"소니","slug":"소니","link":"/tags/%EC%86%8C%EB%8B%88/"},{"name":"다운푸어","slug":"다운푸어","link":"/tags/%EB%8B%A4%EC%9A%B4%ED%91%B8%EC%96%B4/"},{"name":"야후","slug":"야후","link":"/tags/%EC%95%BC%ED%9B%84/"},{"name":"네이버 지식인","slug":"네이버-지식인","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%A7%80%EC%8B%9D%EC%9D%B8/"},{"name":"네이버 엑스퍼트","slug":"네이버-엑스퍼트","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%97%91%EC%8A%A4%ED%8D%BC%ED%8A%B8/"},{"name":"줌","slug":"줌","link":"/tags/%EC%A4%8C/"},{"name":"대기업","slug":"대기업","link":"/tags/%EB%8C%80%EA%B8%B0%EC%97%85/"},{"name":"상호출자제한 기업집단","slug":"상호출자제한-기업집단","link":"/tags/%EC%83%81%ED%98%B8%EC%B6%9C%EC%9E%90%EC%A0%9C%ED%95%9C-%EA%B8%B0%EC%97%85%EC%A7%91%EB%8B%A8/"},{"name":"넥슨","slug":"넥슨","link":"/tags/%EB%84%A5%EC%8A%A8/"},{"name":"넷마블","slug":"넷마블","link":"/tags/%EB%84%B7%EB%A7%88%EB%B8%94/"},{"name":"배달앱","slug":"배달앱","link":"/tags/%EB%B0%B0%EB%8B%AC%EC%95%B1/"},{"name":"게임업계","slug":"게임업계","link":"/tags/%EA%B2%8C%EC%9E%84%EC%97%85%EA%B3%84/"},{"name":"크런치모드","slug":"크런치모드","link":"/tags/%ED%81%AC%EB%9F%B0%EC%B9%98%EB%AA%A8%EB%93%9C/"},{"name":"복지","slug":"복지","link":"/tags/%EB%B3%B5%EC%A7%80/"},{"name":"CES 2022","slug":"CES-2022","link":"/tags/CES-2022/"},{"name":"파이썬","slug":"파이썬","link":"/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"선물하기","slug":"선물하기","link":"/tags/%EC%84%A0%EB%AC%BC%ED%95%98%EA%B8%B0/"},{"name":"스마트워크","slug":"스마트워크","link":"/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"카카오워크","slug":"카카오워크","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9B%8C%ED%81%AC/"},{"name":"네이버웍스","slug":"네이버웍스","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84%EC%9B%8D%EC%8A%A4/"},{"name":"액면분할","slug":"액면분할","link":"/tags/%EC%95%A1%EB%A9%B4%EB%B6%84%ED%95%A0/"},{"name":"MaaS","slug":"MaaS","link":"/tags/MaaS/"},{"name":"CBDC","slug":"CBDC","link":"/tags/CBDC/"},{"name":"CJ온스타일","slug":"CJ온스타일","link":"/tags/CJ%EC%98%A8%EC%8A%A4%ED%83%80%EC%9D%BC/"},{"name":"안드로이드 오토","slug":"안드로이드-오토","link":"/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%98%A4%ED%86%A0/"},{"name":"카카오메이커스","slug":"카카오메이커스","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EB%A9%94%EC%9D%B4%EC%BB%A4%EC%8A%A4/"},{"name":"채팅플러스","slug":"채팅플러스","link":"/tags/%EC%B1%84%ED%8C%85%ED%94%8C%EB%9F%AC%EC%8A%A4/"},{"name":"문자","slug":"문자","link":"/tags/%EB%AC%B8%EC%9E%90/"},{"name":"메시지 보내기 취소","slug":"메시지-보내기-취소","link":"/tags/%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B3%B4%EB%82%B4%EA%B8%B0-%EC%B7%A8%EC%86%8C/"},{"name":"민간클라우드","slug":"민간클라우드","link":"/tags/%EB%AF%BC%EA%B0%84%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C/"},{"name":"디지털 영토 확장","slug":"디지털-영토-확장","link":"/tags/%EB%94%94%EC%A7%80%ED%84%B8-%EC%98%81%ED%86%A0-%ED%99%95%EC%9E%A5/"},{"name":"e커머스","slug":"e커머스","link":"/tags/e%EC%BB%A4%EB%A8%B8%EC%8A%A4/"},{"name":"테크핀","slug":"테크핀","link":"/tags/%ED%85%8C%ED%81%AC%ED%95%80/"},{"name":"퀵서비스","slug":"퀵서비스","link":"/tags/%ED%80%B5%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"광고시장","slug":"광고시장","link":"/tags/%EA%B4%91%EA%B3%A0%EC%8B%9C%EC%9E%A5/"},{"name":"개인정보 수집","slug":"개인정보-수집","link":"/tags/%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4-%EC%88%98%EC%A7%91/"},{"name":"갤럭시 노트","slug":"갤럭시-노트","link":"/tags/%EA%B0%A4%EB%9F%AD%EC%8B%9C-%EB%85%B8%ED%8A%B8/"},{"name":"단종","slug":"단종","link":"/tags/%EB%8B%A8%EC%A2%85/"},{"name":"카카오재팬","slug":"카카오재팬","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9E%AC%ED%8C%AC/"},{"name":"픽코마","slug":"픽코마","link":"/tags/%ED%94%BD%EC%BD%94%EB%A7%88/"},{"name":"은행","slug":"은행","link":"/tags/%EC%9D%80%ED%96%89/"},{"name":"금융사","slug":"금융사","link":"/tags/%EA%B8%88%EC%9C%B5%EC%82%AC/"},{"name":"MS 익스플로러","slug":"MS-익스플로러","link":"/tags/MS-%EC%9D%B5%EC%8A%A4%ED%94%8C%EB%A1%9C%EB%9F%AC/"},{"name":"IE","slug":"IE","link":"/tags/IE/"},{"name":"쿠팡이츠","slug":"쿠팡이츠","link":"/tags/%EC%BF%A0%ED%8C%A1%EC%9D%B4%EC%B8%A0/"},{"name":"인도","slug":"인도","link":"/tags/%EC%9D%B8%EB%8F%84/"},{"name":"디즈니+","slug":"디즈니","link":"/tags/%EB%94%94%EC%A6%88%EB%8B%88/"},{"name":"톡드립","slug":"톡드립","link":"/tags/%ED%86%A1%EB%93%9C%EB%A6%BD/"},{"name":"데이터3법","slug":"데이터3법","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B03%EB%B2%95/"},{"name":"암호화폐","slug":"암호화폐","link":"/tags/%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90/"},{"name":"비트코인","slug":"비트코인","link":"/tags/%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8/"},{"name":"도지코인","slug":"도지코인","link":"/tags/%EB%8F%84%EC%A7%80%EC%BD%94%EC%9D%B8/"},{"name":"롤러블폰","slug":"롤러블폰","link":"/tags/%EB%A1%A4%EB%9F%AC%EB%B8%94%ED%8F%B0/"},{"name":"농협은행","slug":"농협은행","link":"/tags/%EB%86%8D%ED%98%91%EC%9D%80%ED%96%89/"},{"name":"NH","slug":"NH","link":"/tags/NH/"},{"name":"디지털금융 표준플랫폼","slug":"디지털금융-표준플랫폼","link":"/tags/%EB%94%94%EC%A7%80%ED%84%B8%EA%B8%88%EC%9C%B5-%ED%91%9C%EC%A4%80%ED%94%8C%EB%9E%AB%ED%8F%BC/"},{"name":"타파스","slug":"타파스","link":"/tags/%ED%83%80%ED%8C%8C%EC%8A%A4/"},{"name":"카카오엔터테인먼트","slug":"카카오엔터테인먼트","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%97%94%ED%84%B0%ED%85%8C%EC%9D%B8%EB%A8%BC%ED%8A%B8/"},{"name":"음성","slug":"음성","link":"/tags/%EC%9D%8C%EC%84%B1/"},{"name":"비전","slug":"비전","link":"/tags/%EB%B9%84%EC%A0%84/"},{"name":"휴머니스틱AI","slug":"휴머니스틱AI","link":"/tags/%ED%9C%B4%EB%A8%B8%EB%8B%88%EC%8A%A4%ED%8B%B1AI/"},{"name":"안드로이드12","slug":"안드로이드12","link":"/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C12/"},{"name":"타이젠","slug":"타이젠","link":"/tags/%ED%83%80%EC%9D%B4%EC%A0%A0/"},{"name":"구글웨어OS","slug":"구글웨어OS","link":"/tags/%EA%B5%AC%EA%B8%80%EC%9B%A8%EC%96%B4OS/"},{"name":"카카오뱅크","slug":"카카오뱅크","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EB%B1%85%ED%81%AC/"},{"name":"망중립성","slug":"망중립성","link":"/tags/%EB%A7%9D%EC%A4%91%EB%A6%BD%EC%84%B1/"},{"name":"공공클라우드","slug":"공공클라우드","link":"/tags/%EA%B3%B5%EA%B3%B5%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C/"},{"name":"초거대 AI","slug":"초거대-AI","link":"/tags/%EC%B4%88%EA%B1%B0%EB%8C%80-AI/"},{"name":"GPT-3","slug":"GPT-3","link":"/tags/GPT-3/"},{"name":"하이퍼클로바","slug":"하이퍼클로바","link":"/tags/%ED%95%98%EC%9D%B4%ED%8D%BC%ED%81%B4%EB%A1%9C%EB%B0%94/"},{"name":"어도비","slug":"어도비","link":"/tags/%EC%96%B4%EB%8F%84%EB%B9%84/"},{"name":"CXM","slug":"CXM","link":"/tags/CXM/"},{"name":"TSMC","slug":"TSMC","link":"/tags/TSMC/"},{"name":"애플스토어","slug":"애플스토어","link":"/tags/%EC%95%A0%ED%94%8C%EC%8A%A4%ED%86%A0%EC%96%B4/"},{"name":"페이코","slug":"페이코","link":"/tags/%ED%8E%98%EC%9D%B4%EC%BD%94/"},{"name":"음성 커뮤니티","slug":"음성-커뮤니티","link":"/tags/%EC%9D%8C%EC%84%B1-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0/"},{"name":"통신사","slug":"통신사","link":"/tags/%ED%86%B5%EC%8B%A0%EC%82%AC/"},{"name":"IDC","slug":"IDC","link":"/tags/IDC/"},{"name":"ESG. 카카오엔터","slug":"ESG-카카오엔터","link":"/tags/ESG-%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%97%94%ED%84%B0/"},{"name":"알고리즘 공정성","slug":"알고리즘-공정성","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B3%B5%EC%A0%95%EC%84%B1/"},{"name":"간편결제","slug":"간편결제","link":"/tags/%EA%B0%84%ED%8E%B8%EA%B2%B0%EC%A0%9C/"},{"name":"역사 왜곡","slug":"역사-왜곡","link":"/tags/%EC%97%AD%EC%82%AC-%EC%99%9C%EA%B3%A1/"},{"name":"러스트","slug":"러스트","link":"/tags/%EB%9F%AC%EC%8A%A4%ED%8A%B8/"},{"name":"디즈니 플러스","slug":"디즈니-플러스","link":"/tags/%EB%94%94%EC%A6%88%EB%8B%88-%ED%94%8C%EB%9F%AC%EC%8A%A4/"},{"name":"특허","slug":"특허","link":"/tags/%ED%8A%B9%ED%97%88/"},{"name":"배달의 민족","slug":"배달의-민족","link":"/tags/%EB%B0%B0%EB%8B%AC%EC%9D%98-%EB%AF%BC%EC%A1%B1/"},{"name":"배민원","slug":"배민원","link":"/tags/%EB%B0%B0%EB%AF%BC%EC%9B%90/"},{"name":"토스","slug":"토스","link":"/tags/%ED%86%A0%EC%8A%A4/"},{"name":"CJ ENM","slug":"CJ-ENM","link":"/tags/CJ-ENM/"},{"name":"원앱","slug":"원앱","link":"/tags/%EC%9B%90%EC%95%B1/"},{"name":"김래아","slug":"김래아","link":"/tags/%EA%B9%80%EB%9E%98%EC%95%84/"},{"name":"리걸테크","slug":"리걸테크","link":"/tags/%EB%A6%AC%EA%B1%B8%ED%85%8C%ED%81%AC/"},{"name":"엔씨소프트","slug":"엔씨소프트","link":"/tags/%EC%97%94%EC%94%A8%EC%86%8C%ED%94%84%ED%8A%B8/"},{"name":"카카오T","slug":"카카오T","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4T/"},{"name":"6G","slug":"6G","link":"/tags/6G/"},{"name":"윈도우11","slug":"윈도우11","link":"/tags/%EC%9C%88%EB%8F%84%EC%9A%B011/"},{"name":"마이크로소프트","slug":"마이크로소프트","link":"/tags/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8/"},{"name":"CES2022","slug":"CES2022","link":"/tags/CES2022/"},{"name":"대출","slug":"대출","link":"/tags/%EB%8C%80%EC%B6%9C/"},{"name":"WWDC","slug":"WWDC","link":"/tags/WWDC/"},{"name":"페이스타임","slug":"페이스타임","link":"/tags/%ED%8E%98%EC%9D%B4%EC%8A%A4%ED%83%80%EC%9E%84/"},{"name":"패스틀리","slug":"패스틀리","link":"/tags/%ED%8C%A8%EC%8A%A4%ED%8B%80%EB%A6%AC/"},{"name":"잔디","slug":"잔디","link":"/tags/%EC%9E%94%EB%94%94/"},{"name":"실시간혼잡도","slug":"실시간혼잡도","link":"/tags/%EC%8B%A4%EC%8B%9C%EA%B0%84%ED%98%BC%EC%9E%A1%EB%8F%84/"},{"name":"서울 지하철","slug":"서울-지하철","link":"/tags/%EC%84%9C%EC%9A%B8-%EC%A7%80%ED%95%98%EC%B2%A0/"},{"name":"PHR","slug":"PHR","link":"/tags/PHR/"},{"name":"하이브리드 워크","slug":"하이브리드-워크","link":"/tags/%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C-%EC%9B%8C%ED%81%AC/"},{"name":"스마트워치","slug":"스마트워치","link":"/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%9B%8C%EC%B9%98/"},{"name":"SM엔터","slug":"SM엔터","link":"/tags/SM%EC%97%94%ED%84%B0/"},{"name":"블록체인","slug":"블록체인","link":"/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/"},{"name":"SSAFY","slug":"SSAFY","link":"/tags/SSAFY/"},{"name":"의류","slug":"의류","link":"/tags/%EC%9D%98%EB%A5%98/"},{"name":"편집숍","slug":"편집숍","link":"/tags/%ED%8E%B8%EC%A7%91%EC%88%8D/"},{"name":"무신사","slug":"무신사","link":"/tags/%EB%AC%B4%EC%8B%A0%EC%82%AC/"},{"name":"리뷰","slug":"리뷰","link":"/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"워크스페이스","slug":"워크스페이스","link":"/tags/%EC%9B%8C%ED%81%AC%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"SK하이닉스","slug":"SK하이닉스","link":"/tags/SK%ED%95%98%EC%9D%B4%EB%8B%89%EC%8A%A4/"},{"name":"웹케시","slug":"웹케시","link":"/tags/%EC%9B%B9%EC%BC%80%EC%8B%9C/"},{"name":"원격근무제","slug":"원격근무제","link":"/tags/%EC%9B%90%EA%B2%A9%EA%B7%BC%EB%AC%B4%EC%A0%9C/"},{"name":"에잇폴드","slug":"에잇폴드","link":"/tags/%EC%97%90%EC%9E%87%ED%8F%B4%EB%93%9C/"},{"name":"브랜디","slug":"브랜디","link":"/tags/%EB%B8%8C%EB%9E%9C%EB%94%94/"},{"name":"스마트스토어","slug":"스마트스토어","link":"/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%8A%A4%ED%86%A0%EC%96%B4/"},{"name":"구독","slug":"구독","link":"/tags/%EA%B5%AC%EB%8F%85/"},{"name":"할리스","slug":"할리스","link":"/tags/%ED%95%A0%EB%A6%AC%EC%8A%A4/"},{"name":"시즌","slug":"시즌","link":"/tags/%EC%8B%9C%EC%A6%8C/"},{"name":"검색조작","slug":"검색조작","link":"/tags/%EA%B2%80%EC%83%89%EC%A1%B0%EC%9E%91/"},{"name":"카풀","slug":"카풀","link":"/tags/%EC%B9%B4%ED%92%80/"},{"name":"라인파이낸셜","slug":"라인파이낸셜","link":"/tags/%EB%9D%BC%EC%9D%B8%ED%8C%8C%EC%9D%B4%EB%82%B8%EC%85%9C/"},{"name":"카카오게임즈","slug":"카카오게임즈","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EA%B2%8C%EC%9E%84%EC%A6%88/"},{"name":"카카오VX","slug":"카카오VX","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4VX/"},{"name":"골프","slug":"골프","link":"/tags/%EA%B3%A8%ED%94%84/"},{"name":"티빙","slug":"티빙","link":"/tags/%ED%8B%B0%EB%B9%99/"},{"name":"분데스리가","slug":"분데스리가","link":"/tags/%EB%B6%84%EB%8D%B0%EC%8A%A4%EB%A6%AC%EA%B0%80/"},{"name":"댓글","slug":"댓글","link":"/tags/%EB%8C%93%EA%B8%80/"},{"name":"평점","slug":"평점","link":"/tags/%ED%8F%89%EC%A0%90/"},{"name":"키워드","slug":"키워드","link":"/tags/%ED%82%A4%EC%9B%8C%EB%93%9C/"},{"name":"네이버페이","slug":"네이버페이","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84%ED%8E%98%EC%9D%B4/"},{"name":"IB","slug":"IB","link":"/tags/IB/"},{"name":"투자은행","slug":"투자은행","link":"/tags/%ED%88%AC%EC%9E%90%EC%9D%80%ED%96%89/"},{"name":"증권","slug":"증권","link":"/tags/%EC%A6%9D%EA%B6%8C/"},{"name":"보험","slug":"보험","link":"/tags/%EB%B3%B4%ED%97%98/"},{"name":"마블코믹스","slug":"마블코믹스","link":"/tags/%EB%A7%88%EB%B8%94%EC%BD%94%EB%AF%B9%EC%8A%A4/"},{"name":"인테리어","slug":"인테리어","link":"/tags/%EC%9D%B8%ED%85%8C%EB%A6%AC%EC%96%B4/"},{"name":"오늘의집","slug":"오늘의집","link":"/tags/%EC%98%A4%EB%8A%98%EC%9D%98%EC%A7%91/"},{"name":"집꾸미기","slug":"집꾸미기","link":"/tags/%EC%A7%91%EA%BE%B8%EB%AF%B8%EA%B8%B0/"},{"name":"하우저","slug":"하우저","link":"/tags/%ED%95%98%EC%9A%B0%EC%A0%80/"},{"name":"손정의","slug":"손정의","link":"/tags/%EC%86%90%EC%A0%95%EC%9D%98/"},{"name":"대출시장","slug":"대출시장","link":"/tags/%EB%8C%80%EC%B6%9C%EC%8B%9C%EC%9E%A5/"},{"name":"셧다운제","slug":"셧다운제","link":"/tags/%EC%85%A7%EB%8B%A4%EC%9A%B4%EC%A0%9C/"},{"name":"여가부","slug":"여가부","link":"/tags/%EC%97%AC%EA%B0%80%EB%B6%80/"},{"name":"공유키보드","slug":"공유키보드","link":"/tags/%EA%B3%B5%EC%9C%A0%ED%82%A4%EB%B3%B4%EB%93%9C/"},{"name":"제페토","slug":"제페토","link":"/tags/%EC%A0%9C%ED%8E%98%ED%86%A0/"},{"name":"갤럭시Z폴드3","slug":"갤럭시Z폴드3","link":"/tags/%EA%B0%A4%EB%9F%AD%EC%8B%9CZ%ED%8F%B4%EB%93%9C3/"},{"name":"카카오택시","slug":"카카오택시","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%83%9D%EC%8B%9C/"},{"name":"인터파크","slug":"인터파크","link":"/tags/%EC%9D%B8%ED%84%B0%ED%8C%8C%ED%81%AC/"},{"name":"도쿄올림픽","slug":"도쿄올림픽","link":"/tags/%EB%8F%84%EC%BF%84%EC%98%AC%EB%A6%BC%ED%94%BD/"},{"name":"구글코리아","slug":"구글코리아","link":"/tags/%EA%B5%AC%EA%B8%80%EC%BD%94%EB%A6%AC%EC%95%84/"},{"name":"개발자","slug":"개발자","link":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90/"},{"name":"바로팜","slug":"바로팜","link":"/tags/%EB%B0%94%EB%A1%9C%ED%8C%9C/"},{"name":"스팸","slug":"스팸","link":"/tags/%EC%8A%A4%ED%8C%B8/"},{"name":"후후","slug":"후후","link":"/tags/%ED%9B%84%ED%9B%84/"},{"name":"네이버쇼핑","slug":"네이버쇼핑","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84%EC%87%BC%ED%95%91/"},{"name":"슈퍼앱","slug":"슈퍼앱","link":"/tags/%EC%8A%88%ED%8D%BC%EC%95%B1/"},{"name":"여행","slug":"여행","link":"/tags/%EC%97%AC%ED%96%89/"},{"name":"고속버스","slug":"고속버스","link":"/tags/%EA%B3%A0%EC%86%8D%EB%B2%84%EC%8A%A4/"},{"name":"CJ","slug":"CJ","link":"/tags/CJ/"},{"name":"대한통운","slug":"대한통운","link":"/tags/%EB%8C%80%ED%95%9C%ED%86%B5%EC%9A%B4/"},{"name":"풀필먼트","slug":"풀필먼트","link":"/tags/%ED%92%80%ED%95%84%EB%A8%BC%ED%8A%B8/"},{"name":"당일배송","slug":"당일배송","link":"/tags/%EB%8B%B9%EC%9D%BC%EB%B0%B0%EC%86%A1/"},{"name":"새벽배송","slug":"새벽배송","link":"/tags/%EC%83%88%EB%B2%BD%EB%B0%B0%EC%86%A1/"},{"name":"왓슨","slug":"왓슨","link":"/tags/%EC%99%93%EC%8A%A8/"},{"name":"루닛","slug":"루닛","link":"/tags/%EB%A3%A8%EB%8B%9B/"},{"name":"MS","slug":"MS","link":"/tags/MS/"},{"name":"윈도우","slug":"윈도우","link":"/tags/%EC%9C%88%EB%8F%84%EC%9A%B0/"},{"name":"VDI","slug":"VDI","link":"/tags/VDI/"},{"name":"클라우드서비스","slug":"클라우드서비스","link":"/tags/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"유튜브","slug":"유튜브","link":"/tags/%EC%9C%A0%ED%8A%9C%EB%B8%8C/"},{"name":"틱복","slug":"틱복","link":"/tags/%ED%8B%B1%EB%B3%B5/"},{"name":"T멤버십","slug":"T멤버십","link":"/tags/T%EB%A9%A4%EB%B2%84%EC%8B%AD/"},{"name":"NHN페이코","slug":"NHN페이코","link":"/tags/NHN%ED%8E%98%EC%9D%B4%EC%BD%94/"},{"name":"QR코드결제","slug":"QR코드결제","link":"/tags/QR%EC%BD%94%EB%93%9C%EA%B2%B0%EC%A0%9C/"},{"name":"카카오웹툰","slug":"카카오웹툰","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9B%B9%ED%88%B0/"},{"name":"왓패드 웹툰 스튜디오","slug":"왓패드-웹툰-스튜디오","link":"/tags/%EC%99%93%ED%8C%A8%EB%93%9C-%EC%9B%B9%ED%88%B0-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4/"},{"name":"선불충전금","slug":"선불충전금","link":"/tags/%EC%84%A0%EB%B6%88%EC%B6%A9%EC%A0%84%EA%B8%88/"},{"name":"오픈뱅킹","slug":"오픈뱅킹","link":"/tags/%EC%98%A4%ED%94%88%EB%B1%85%ED%82%B9/"},{"name":"핀다","slug":"핀다","link":"/tags/%ED%95%80%EB%8B%A4/"},{"name":"AI리뷰","slug":"AI리뷰","link":"/tags/AI%EB%A6%AC%EB%B7%B0/"},{"name":"다날","slug":"다날","link":"/tags/%EB%8B%A4%EB%82%A0/"},{"name":"네이버인증서","slug":"네이버인증서","link":"/tags/%EB%84%A4%EC%9D%B4%EB%B2%84%EC%9D%B8%EC%A6%9D%EC%84%9C/"},{"name":"카카오톡","slug":"카카오톡","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"카카오뷰","slug":"카카오뷰","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EB%B7%B0/"},{"name":"텐서","slug":"텐서","link":"/tags/%ED%85%90%EC%84%9C/"},{"name":"픽셀","slug":"픽셀","link":"/tags/%ED%94%BD%EC%85%80/"},{"name":"XR","slug":"XR","link":"/tags/XR/"},{"name":"확장현실","slug":"확장현실","link":"/tags/%ED%99%95%EC%9E%A5%ED%98%84%EC%8B%A4/"},{"name":"가상세계","slug":"가상세계","link":"/tags/%EA%B0%80%EC%83%81%EC%84%B8%EA%B3%84/"},{"name":"AOMG","slug":"AOMG","link":"/tags/AOMG/"},{"name":"데이터유출","slug":"데이터유출","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9C%A0%EC%B6%9C/"},{"name":"사용자인증","slug":"사용자인증","link":"/tags/%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9D%B8%EC%A6%9D/"},{"name":"AI논문","slug":"AI논문","link":"/tags/AI%EB%85%BC%EB%AC%B8/"},{"name":"송금","slug":"송금","link":"/tags/%EC%86%A1%EA%B8%88/"},{"name":"노이즈캔슬링","slug":"노이즈캔슬링","link":"/tags/%EB%85%B8%EC%9D%B4%EC%A6%88%EC%BA%94%EC%8A%AC%EB%A7%81/"},{"name":"2단계인증","slug":"2단계인증","link":"/tags/2%EB%8B%A8%EA%B3%84%EC%9D%B8%EC%A6%9D/"},{"name":"보안","slug":"보안","link":"/tags/%EB%B3%B4%EC%95%88/"},{"name":"배민","slug":"배민","link":"/tags/%EB%B0%B0%EB%AF%BC/"},{"name":"개인정보유출","slug":"개인정보유출","link":"/tags/%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4%EC%9C%A0%EC%B6%9C/"},{"name":"해피톡","slug":"해피톡","link":"/tags/%ED%95%B4%ED%94%BC%ED%86%A1/"},{"name":"팁스","slug":"팁스","link":"/tags/%ED%8C%81%EC%8A%A4/"},{"name":"커피챗","slug":"커피챗","link":"/tags/%EC%BB%A4%ED%94%BC%EC%B1%97/"},{"name":"카페24","slug":"카페24","link":"/tags/%EC%B9%B4%ED%8E%9824/"},{"name":"카카오바이크","slug":"카카오바이크","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%EB%B0%94%EC%9D%B4%ED%81%AC/"},{"name":"NH농협은행","slug":"NH농협은행","link":"/tags/NH%EB%86%8D%ED%98%91%EC%9D%80%ED%96%89/"},{"name":"KAIST","slug":"KAIST","link":"/tags/KAIST/"},{"name":"보건의료","slug":"보건의료","link":"/tags/%EB%B3%B4%EA%B1%B4%EC%9D%98%EB%A3%8C/"},{"name":"딥브레인AI","slug":"딥브레인AI","link":"/tags/%EB%94%A5%EB%B8%8C%EB%A0%88%EC%9D%B8AI/"},{"name":"발명가","slug":"발명가","link":"/tags/%EB%B0%9C%EB%AA%85%EA%B0%80/"},{"name":"다부스","slug":"다부스","link":"/tags/%EB%8B%A4%EB%B6%80%EC%8A%A4/"},{"name":"VC","slug":"VC","link":"/tags/VC/"},{"name":"다나와","slug":"다나와","link":"/tags/%EB%8B%A4%EB%82%98%EC%99%80/"},{"name":"예스24","slug":"예스24","link":"/tags/%EC%98%88%EC%8A%A424/"},{"name":"yes24","slug":"yes24","link":"/tags/yes24/"},{"name":"기아차","slug":"기아차","link":"/tags/%EA%B8%B0%EC%95%84%EC%B0%A8/"},{"name":"플랫폼","slug":"플랫폼","link":"/tags/%ED%94%8C%EB%9E%AB%ED%8F%BC/"},{"name":"직방","slug":"직방","link":"/tags/%EC%A7%81%EB%B0%A9/"},{"name":"로톡","slug":"로톡","link":"/tags/%EB%A1%9C%ED%86%A1/"},{"name":"지문인식","slug":"지문인식","link":"/tags/%EC%A7%80%EB%AC%B8%EC%9D%B8%EC%8B%9D/"},{"name":"생체인식","slug":"생체인식","link":"/tags/%EC%83%9D%EC%B2%B4%EC%9D%B8%EC%8B%9D/"},{"name":"도미노피자","slug":"도미노피자","link":"/tags/%EB%8F%84%EB%AF%B8%EB%85%B8%ED%94%BC%EC%9E%90/"},{"name":"드론","slug":"드론","link":"/tags/%EB%93%9C%EB%A1%A0/"},{"name":"SKT","slug":"SKT","link":"/tags/SKT/"},{"name":"이프랜드","slug":"이프랜드","link":"/tags/%EC%9D%B4%ED%94%84%EB%9E%9C%EB%93%9C/"},{"name":"삼성페이","slug":"삼성페이","link":"/tags/%EC%82%BC%EC%84%B1%ED%8E%98%EC%9D%B4/"},{"name":"업비트","slug":"업비트","link":"/tags/%EC%97%85%EB%B9%84%ED%8A%B8/"},{"name":"본인확인","slug":"본인확인","link":"/tags/%EB%B3%B8%EC%9D%B8%ED%99%95%EC%9D%B8/"},{"name":"컴투스","slug":"컴투스","link":"/tags/%EC%BB%B4%ED%88%AC%EC%8A%A4/"},{"name":"얼굴수집","slug":"얼굴수집","link":"/tags/%EC%96%BC%EA%B5%B4%EC%88%98%EC%A7%91/"},{"name":"얼굴인식","slug":"얼굴인식","link":"/tags/%EC%96%BC%EA%B5%B4%EC%9D%B8%EC%8B%9D/"},{"name":"RPA","slug":"RPA","link":"/tags/RPA/"},{"name":"MG새마을금고중앙회","slug":"MG새마을금고중앙회","link":"/tags/MG%EC%83%88%EB%A7%88%EC%9D%84%EA%B8%88%EA%B3%A0%EC%A4%91%EC%95%99%ED%9A%8C/"},{"name":"DGB금융그룹","slug":"DGB금융그룹","link":"/tags/DGB%EA%B8%88%EC%9C%B5%EA%B7%B8%EB%A3%B9/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"stylesheet","slug":"stylesheet","link":"/tags/stylesheet/"},{"name":"하드웨어가속","slug":"하드웨어가속","link":"/tags/%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EA%B0%80%EC%86%8D/"},{"name":"3d","slug":"3d","link":"/tags/3d/"},{"name":"translate","slug":"translate","link":"/tags/translate/"},{"name":"NFT","slug":"NFT","link":"/tags/NFT/"},{"name":"크러스트","slug":"크러스트","link":"/tags/%ED%81%AC%EB%9F%AC%EC%8A%A4%ED%8A%B8/"},{"name":"그라운드X","slug":"그라운드X","link":"/tags/%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9CX/"},{"name":"백신예약","slug":"백신예약","link":"/tags/%EB%B0%B1%EC%8B%A0%EC%98%88%EC%95%BD/"},{"name":"갤럭시Z플립3","slug":"갤럭시Z플립3","link":"/tags/%EA%B0%A4%EB%9F%AD%EC%8B%9CZ%ED%94%8C%EB%A6%BD3/"},{"name":"NHN","slug":"NHN","link":"/tags/NHN/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Babel","slug":"Babel","link":"/tags/Babel/"},{"name":"바벨","slug":"바벨","link":"/tags/%EB%B0%94%EB%B2%A8/"},{"name":"클래스","slug":"클래스","link":"/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"class","slug":"class","link":"/tags/class/"},{"name":"인스턴스","slug":"인스턴스","link":"/tags/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"},{"name":"상속","slug":"상속","link":"/tags/%EC%83%81%EC%86%8D/"},{"name":"extends","slug":"extends","link":"/tags/extends/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"웹팩","slug":"웹팩","link":"/tags/%EC%9B%B9%ED%8C%A9/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"},{"name":"Webstorm","slug":"Webstorm","link":"/tags/Webstorm/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"픽셀폰","slug":"픽셀폰","link":"/tags/%ED%94%BD%EC%85%80%ED%8F%B0/"},{"name":"민간인증서","slug":"민간인증서","link":"/tags/%EB%AF%BC%EA%B0%84%EC%9D%B8%EC%A6%9D%EC%84%9C/"},{"name":"공동인증서","slug":"공동인증서","link":"/tags/%EA%B3%B5%EB%8F%99%EC%9D%B8%EC%A6%9D%EC%84%9C/"},{"name":"충전","slug":"충전","link":"/tags/%EC%B6%A9%EC%A0%84/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"클로저","slug":"클로저","link":"/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/"},{"name":"은닉화","slug":"은닉화","link":"/tags/%EC%9D%80%EB%8B%89%ED%99%94/"},{"name":"debounce","slug":"debounce","link":"/tags/debounce/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"객체","slug":"객체","link":"/tags/%EA%B0%9D%EC%B2%B4/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"배열","slug":"배열","link":"/tags/%EB%B0%B0%EC%97%B4/"},{"name":"자료","slug":"자료","link":"/tags/%EC%9E%90%EB%A3%8C/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"ESLint","slug":"ESLint","link":"/tags/ESLint/"},{"name":"lint","slug":"lint","link":"/tags/lint/"},{"name":"ecma","slug":"ecma","link":"/tags/ecma/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"es2022","slug":"es2022","link":"/tags/es2022/"},{"name":"es2021","slug":"es2021","link":"/tags/es2021/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"프로토타입","slug":"프로토타입","link":"/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"},{"name":"프로토타입 체인","slug":"프로토타입-체인","link":"/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8/"},{"name":"생성자","slug":"생성자","link":"/tags/%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"Scope","slug":"Scope","link":"/tags/Scope/"},{"name":"스코프","slug":"스코프","link":"/tags/%EC%8A%A4%EC%BD%94%ED%94%84/"},{"name":"Hoisting","slug":"Hoisting","link":"/tags/Hoisting/"},{"name":"호이스팅","slug":"호이스팅","link":"/tags/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/"},{"name":"IIFE","slug":"IIFE","link":"/tags/IIFE/"},{"name":"전역객체","slug":"전역객체","link":"/tags/%EC%A0%84%EC%97%AD%EA%B0%9D%EC%B2%B4/"},{"name":"블록","slug":"블록","link":"/tags/%EB%B8%94%EB%A1%9D/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"bind","slug":"bind","link":"/tags/bind/"},{"name":"바인딩","slug":"바인딩","link":"/tags/%EB%B0%94%EC%9D%B8%EB%94%A9/"},{"name":"reactjs","slug":"reactjs","link":"/tags/reactjs/"},{"name":"리액트","slug":"리액트","link":"/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/"},{"name":"ES2022","slug":"ES2022","link":"/tags/ES2022/"},{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"Private","slug":"Private","link":"/tags/Private/"},{"name":"Static","slug":"Static","link":"/tags/Static/"},{"name":"at","slug":"at","link":"/tags/at/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"비동기","slug":"비동기","link":"/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"name":"ECMA","slug":"ECMA","link":"/tags/ECMA/"},{"name":"프론트엔드","slug":"프론트엔드","link":"/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/"},{"name":"FE","slug":"FE","link":"/tags/FE/"}],"categories":[{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Javascript","slug":"Algorithm/Javascript","link":"/categories/Algorithm/Javascript/"},{"name":"C++","slug":"Algorithm/C","link":"/categories/Algorithm/C/"},{"name":"AWS","slug":"DevOps/AWS","link":"/categories/DevOps/AWS/"},{"name":"MySQL","slug":"DevOps/MySQL","link":"/categories/DevOps/MySQL/"},{"name":"Raspberry Pi","slug":"DevOps/Raspberry-Pi","link":"/categories/DevOps/Raspberry-Pi/"},{"name":"Fastlane","slug":"DevOps/Fastlane","link":"/categories/DevOps/Fastlane/"},{"name":"Python","slug":"Algorithm/Python","link":"/categories/Algorithm/Python/"},{"name":"Ubuntu","slug":"DevOps/Ubuntu","link":"/categories/DevOps/Ubuntu/"},{"name":"Git&#x2F;Github","slug":"Programming/Git-Github","link":"/categories/Programming/Git-Github/"},{"name":"IT정보","slug":"IT정보","link":"/categories/IT%EC%A0%95%EB%B3%B4/"},{"name":"Spring Boot","slug":"Programming/Spring-Boot","link":"/categories/Programming/Spring-Boot/"},{"name":"주간 IT정리","slug":"IT정보/주간-IT정리","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EC%A3%BC%EA%B0%84-IT%EC%A0%95%EB%A6%AC/"},{"name":"매일30분 IT뉴스","slug":"IT정보/매일30분-IT뉴스","link":"/categories/IT%EC%A0%95%EB%B3%B4/%EB%A7%A4%EC%9D%BC30%EB%B6%84-IT%EB%89%B4%EC%8A%A4/"},{"name":"Web&#x2F;App","slug":"Web-App","link":"/categories/Web-App/"},{"name":"Javascript","slug":"Web-App/Javascript","link":"/categories/Web-App/Javascript/"},{"name":"CSS","slug":"Web-App/CSS","link":"/categories/Web-App/CSS/"},{"name":"React","slug":"Web-App/React","link":"/categories/Web-App/React/"}],"pages":[]}